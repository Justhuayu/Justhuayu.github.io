<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络 io 与 select，poll，epoll</title>
      <link href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
      <url>/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="网络-io-与-select，poll，epoll"><a href="#网络-io-与-select，poll，epoll" class="headerlink" title="网络 io 与 select，poll，epoll"></a>网络 io 与 select，poll，epoll</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令使用</title>
      <link href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux-命令使用"><a href="#Linux-命令使用" class="headerlink" title="Linux 命令使用"></a>Linux 命令使用</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 中插入 Latex 公式 hexo -g 报错</title>
      <link href="/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/"/>
      <url>/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>在md文档中插入了 $Latex$ 公式，使用 <code>hexo -g</code>时报错如下：</p></blockquote><img src="/Users/justhuayu/Library/Application Support/typora-user-images/image-20240221141850987.png" alt="image-20240221141850987" style="zoom:30%;" /><blockquote><p>​出现这种情况是因为 $Latex$ 公式块中有<code>&#123;&#123;&#125;&#125;</code>这样的双花括号，与另外的某些模块，如 Nunjucks 模块发生了冲突。</p></blockquote><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​将<code>&#123;&#123;&#125;&#125;</code>改为<code>&#123;&#125;</code>单花括号即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation</title>
      <link href="/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/"/>
      <url>/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ClipSAM"><a href="#ClipSAM" class="headerlink" title="ClipSAM"></a>ClipSAM</h1><img src="/Users/justhuayu/Desktop/610c334d0084c2b8c8875.png" alt="image-20240220155331043" style="zoom:30%;" /><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-ZSAD（零样本异常检测）任务"><a href="#1-ZSAD（零样本异常检测）任务" class="headerlink" title="1. ZSAD（零样本异常检测）任务"></a>1. ZSAD（零样本异常检测）任务</h3><p>​需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。</p><h3 id="2-CLIP-用于ZSAS问题"><a href="#2-CLIP-用于ZSAS问题" class="headerlink" title="2. CLIP 用于ZSAS问题"></a>2. CLIP 用于ZSAS问题</h3><blockquote><p>​CLIP主要关注不同输入之间的全局特征对齐，&#x3D;&#x3D;导致局部异常部分的分割不精确&#x3D;&#x3D;。</p></blockquote><h3 id="3-SAM-用于ZSAS问题"><a href="#3-SAM-用于ZSAS问题" class="headerlink" title="3. SAM 用于ZSAS问题"></a>3. SAM 用于ZSAS问题</h3><blockquote><p>​SAM会&#x3D;&#x3D;产生大量冗余掩码&#x3D;&#x3D;，&#x3D;&#x3D;需要合适的提示&#x3D;&#x3D;。&#x3D;&#x3D;简单的文本提示不能有效描述异常区域&#x3D;&#x3D;，导致异常定位性能欠佳，SAM功能利用率不足。同时，&#x3D;&#x3D;模糊的提示会产生冗余的掩码&#x3D;&#x3D;。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-CLIP-和-SAM-协同"><a href="#1-CLIP-和-SAM-协同" class="headerlink" title="1. CLIP 和 SAM 协同"></a>1. CLIP 和 SAM 协同</h3><blockquote><p>​CLIP进行&#x3D;&#x3D;异常定位和粗分割&#x3D;&#x3D;，SAM利用定位和粗分割结果进行&#x3D;&#x3D;细分割&#x3D;&#x3D;。</p></blockquote><h3 id="2-统一多尺度跨模态交互-UMCI-模块"><a href="#2-统一多尺度跨模态交互-UMCI-模块" class="headerlink" title="2.  统一多尺度跨模态交互(UMCI)模块"></a>2.  统一多尺度跨模态交互(UMCI)模块</h3><blockquote><p>​UMCI (Unified Multi-scale Cross-modal Interaction) 实现CLIP&#x3D;&#x3D;不同层次的多模态特征融合&#x3D;&#x3D;，以获得异常定位和粗分割。</p></blockquote><p>​UMCI将&#x3D;&#x3D;水平方向和垂直方向&#x3D;&#x3D;的图像patch tokens 聚合，并利用&#x3D;&#x3D;相应的行、列特征与 text 特征交互&#x3D;&#x3D;，感知不同方向的局部异常。UMCI还考虑了语言和多尺度视觉特征的相互作用。</p><p>​该模块通过在&#x3D;&#x3D;行-列和多尺度级别&#x3D;&#x3D;上的语言特征与视觉特征交互来学习异常部件的局部和全局语义。</p><h3 id="3-多级掩码细化-MMR-模块"><a href="#3-多级掩码细化-MMR-模块" class="headerlink" title="3. 多级掩码细化(MMR)模块"></a>3. 多级掩码细化(MMR)模块</h3><blockquote><p>​MMR (Multi-level Mask Refinement) 利用CLIP的定位信息来指导SAM进行分割细化</p></blockquote><p>​首先从CLIP的异常定位结果中&#x3D;&#x3D;提取不同的点和边界框&#x3D;&#x3D;提示，然后使用这些提示来&#x3D;&#x3D;指导SAM生成&#x3D;&#x3D;精确的掩码。最后，将这些&#x3D;&#x3D;掩码与基于不同掩码置信度的CLIP结果融合&#x3D;&#x3D;。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-CLIP-部分"><a href="#1-CLIP-部分" class="headerlink" title="1.CLIP 部分"></a>1.CLIP 部分</h3><img src="https://telegraph-image-9wl.pages.dev/file/394ad1f18de0a39c09f69.png" alt="image-20240221100305823" style="zoom:30%;" /><p>​主要关注&#x3D;&#x3D;提示词&#x3D;&#x3D;的设计，对于上图中CLIP Text的两个输入：</p><ol><li>上面输入，表示有 $n$ 个&#x3D;&#x3D;描述短语&#x3D;&#x3D;。</li><li>左边输入，表示有 $m_{normal}$ 个&#x3D;&#x3D;描述正常状态的词&#x3D;&#x3D;， $m_{abnormal}$ 个&#x3D;&#x3D;描述异常状态的词&#x3D;&#x3D;。</li><li>对于&#x3D;&#x3D;同一类&#x3D;&#x3D;（类&#x3D;&#x3D;默认已知&#x3D;&#x3D;，未知类用&#x3D;&#x3D;[object]站位&#x3D;&#x3D;），总有 $n \times (m_{normal} + m_{abnormal})$ 个&#x3D;&#x3D;提示句子&#x3D;&#x3D;。</li><li>所有句子通过CLIP Text，计算文本特征&#x3D;&#x3D;平均值&#x3D;&#x3D;。</li></ol><h3 id="2-统一多尺度跨模态交互-UMCI-模块-1"><a href="#2-统一多尺度跨模态交互-UMCI-模块-1" class="headerlink" title="2.统一多尺度跨模态交互(UMCI)模块"></a>2.统一多尺度跨模态交互(UMCI)模块</h3><img src="https://telegraph-image-9wl.pages.dev/file/028a98e00e7ca82792078.png" alt="image-20240221100638886" style="zoom:41%;" /><blockquote><p>​UMCI模块的输入为CLIP编码器处理后得到的文本特征 $L$ （与WinCLIP一致）和第 $i$ 阶段生成的 patch tokens $P_i$ 。</p></blockquote><p>​UMCI模型由两条并行路径组成：&#x3D;&#x3D;条形路径(Strip Path)和比例路径(Scale Path)&#x3D;&#x3D;。Strip Path捕获 patch tokens 的&#x3D;&#x3D;行级和列级特征&#x3D;&#x3D;，&#x3D;&#x3D;以精确定位位置&#x3D;&#x3D;。Scale Path 侧重于掌握图像的&#x3D;&#x3D;各种尺度的全局特征&#x3D;&#x3D;，从而全面了解异常。</p><ol><li>&#x3D;&#x3D;Strip path&#x3D;&#x3D; 条形路径、 &#x3D;&#x3D;Scale path&#x3D;&#x3D; 比例路径，算法中 $B(.)$ 指双线性插值。</li></ol><div style="display:flex; justify-content:space-between;">  <img src="https://telegraph-image-9wl.pages.dev/file/c1d36198d0ebcdf6612e9.png" alt="image-20240221130203205" style="width: 48%;">  <img src="https://telegraph-image-9wl.pages.dev/file/2f1978ec8967f2947e030.png" alt="image-20240221130246384" style="width: 48%;"></div><ol start="2"><li>输出&#x3D;&#x3D;最终结果&#x3D;&#x3D;。</li></ol><p>$$<br>v_{ori} &#x3D; {conv}_{ori}^{3 \times 3}(\hat{P})<br>$$</p><p>$$<br>M_{all} &#x3D; {conv}<em>{all}^{3 \times 3}({concat}(v</em>{ori}, M_{row,col}, M_{g_1}, M_{g_2}))<br>$$</p><p>$$<br>O &#x3D; {MLP}({ReLU}(M_{all} + \hat{P}))<br>$$</p><ol start="3"><li>如果编码器中&#x3D;&#x3D;有 $n$ 个阶段&#x3D;&#x3D;，将第 $i$ 阶段的分割输出设为 $O_i$ ，则&#x3D;&#x3D;最终的分割结果&#x3D;&#x3D;可计算为。</li></ol><p>$$<br>O &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} O_i<br>$$</p><h3 id="3-SAM部分，多级掩码细化-MMC"><a href="#3-SAM部分，多级掩码细化-MMC" class="headerlink" title="3. SAM部分，多级掩码细化(MMC)"></a>3. SAM部分，多级掩码细化(MMC)</h3><img src="https://telegraph-image-9wl.pages.dev/file/a28dbdcfac76ca5f7113c.png" alt="image-20240221103130908" style="zoom:40%;" /><blockquote><p>​MMC 的输入为 CLIP处理后的&#x3D;&#x3D;定位信息和粗分割&#x3D;&#x3D;，该模块流程如下：</p></blockquote><ol><li>根据输入，获得&#x3D;&#x3D;二进制掩码&#x3D;&#x3D;，&#x3D;&#x3D;1 表示异常像素点&#x3D;&#x3D;。</li></ol><p>$$<br>v(x, y)_b &#x3D;<br>\begin{cases}<br>1, &amp; \text{if } v(x, y)_f &gt; \text{threshold} \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p><ol start="2"><li>生成&#x3D;&#x3D;点提示&#x3D;&#x3D;。随机选择 $m$ 个点，$(x_{pm}, y_{pm})$ 表示第 $i$ 个点位置。</li></ol><p>$$<br>S_p &#x3D; \left[ (x_{p1}, y_{p1}), \ldots, (x_{pm}, y_{pm}) \right],<br>$$</p><ol start="3"><li>生成&#x3D;&#x3D;框提示&#x3D;&#x3D;。根据二进制掩码中&#x3D;&#x3D;连通区域的大小&#x3D;&#x3D;和&#x3D;&#x3D;第 $i$ 个点位置&#x3D;&#x3D;，生成 $q$ 个方框。</li></ol><p>$$<br>S_{b_i} &#x3D; \left[ (x_{b_i}, y_{b_i}, h_{b_i}, w_{b_i}) \right]，<br>{S}<em>{b} &#x3D; [{S}</em>{b_1}, \ldots, {S}_{b_q}]<br>$$</p><blockquote alt="info">    <p>        消融实验：点提示和框提示的有效性。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5e0b58ad16f56d91d70f1.png" alt="image-20240221110923658" style="zoom:70%;" /><ol start="4"><li>使用 SAM 分割原始图像。输入是&#x3D;&#x3D;原始图像和提示 $S$&#x3D;&#x3D; ，&#x3D;&#x3D;编码后特征为 $Z_i$和$Z_S$&#x3D;&#x3D;，解码后结果为&#x3D;&#x3D;掩码 $masks$ 和相应的置信度分数 $scores$&#x3D;&#x3D;。SAM 为每个框提示生成三个具有不同置信度分数的掩码。</li></ol><p>$$<br>S &#x3D; S_b \cup S_p<br>$$</p><p>$$<br>({masks}, {scores}) &#x3D; D_{sam}(z_i | z_s).<br>$$</p><p>$$<br>\text{masks} &#x3D; \left[<br>\begin{array}{ccc}<br>m_{1}^1 &amp; m_{1}^2 &amp; m_{1}^3 \<br>\vdots &amp; \vdots &amp; \vdots \<br>m_{q}^1 &amp; m_{q}^2 &amp; m_{q}^3 \<br>\end{array}<br>\right], \quad \text{scores} &#x3D; \left[<br>\begin{array}{ccc}<br>s_{1}^1 &amp; s_{1}^2 &amp; s_{1}^3 \<br>\vdots &amp; \vdots &amp; \vdots \<br>s_{q}^1 &amp; s_{q}^2 &amp; s_{q}^3 \<br>\end{array}<br>\right]<br>$$</p><ol start="5"><li>SAM 结果与原始输入叠加，得到&#x3D;&#x3D;最终结果&#x3D;&#x3D;。</li></ol><p>$$<br>O_{final} &#x3D; {Norm}\left(O + \sum_{i&#x3D;1}^{q} \sum_{j&#x3D;1}^{3} m_{i}^j \times s_{i}^j\right)<br>$$</p><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><blockquote><p>使用 Focal loss 和 Mice loss</p></blockquote><p>$$<br>L_{focal} &#x3D; -\frac{1}{H \times W} \sum_{i&#x3D;0}^{H \times W} (1 - p_i)^\gamma \log(p_i)，\gamma &#x3D; 2<br>$$</p><p>$$<br>L_{dice} &#x3D; 1 - \frac{2 \times \sum_{i&#x3D;1}^{N} y_i \hat{y}<em>i}{\sum</em>{i&#x3D;1}^{N} y_i^2 + \sum_{i&#x3D;1}^{N} \hat{y}_i^2}  ，N &#x3D; H \times W<br>$$</p><p>$$<br>L_{all} &#x3D; \sum_{i&#x3D;1}^{n} \lambda_i (L_{focal}^i + L_{dice}^i),<br>$$</p><p>​$λ_i$ 为第 $i$ 阶段的损失权值。CLIP编码器本文总共由4个阶段组成，$λ_i$ 分别为 &#x3D;&#x3D;0.1、0.1、0.1和0.7&#x3D;&#x3D;。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/164cbfacd619c4499eba5.png" alt="image-20240221104522472" style="zoom:60%;" /><blockquote><p>$AUROC$ 接收者特性曲线下方的面积</p></blockquote><p>​AUROC (area under the receiver operating characteristic) 接收者特性曲线下方的面积，&#x3D;&#x3D;AUROC值越大，正确率越高&#x3D;&#x3D;。AUROC 衡量模型在区分两个类别（如正类和负类）方面的能力，其中 $AUROC &#x3D; 0.5$ 表示随机猜测。</p><p>​横坐标是&#x3D;&#x3D;假正率&#x3D;&#x3D;（False Positive Rate, FPR），纵坐标是&#x3D;&#x3D;真正率&#x3D;&#x3D;（True Positive Rate, TPR）。<br>$$<br>FRR &#x3D; \frac{FN}{FN + TP} &#x3D; \frac{假阳性数量}{实际阴性样本总数}<br>$$</p><p>$$<br>TPR &#x3D; \frac{TP}{TP + FN}&#x3D;\frac{真阳性数量}{实际阳性样本总数}<br>$$</p><blockquote><p>$F_1-max$ 在不同的决策阈值或不同的条件下，F1分数的最大值</p></blockquote><p>​F1分数（F1-Score）是一个用于衡量二分类模型性能的指标，它是模型&#x3D;&#x3D;精确率（Precision）和召回率（Recall）的调和平均数&#x3D;&#x3D;。F1分数的范围从0到1，1表示完美的精确率和召回率，0表示至少有一个为零。<br>$$<br>F_{1{-max}} &#x3D; \max \left(2 \times \frac{Precision} \times {Recall}{Precision} + {Recall}\right)<br>$$</p><p>$$<br>{Precision} &#x3D; \frac{TP}{TP + FP}<br>$$</p><p>$$<br>\text{Recall} &#x3D; \frac{TP}{TP + FN}<br>$$</p><blockquote><p>$AP$ 平均精度</p></blockquote><p>​AP (Average Precision) 平均精度是&#x3D;&#x3D;对精确率（Precision）在不同召回率（Recall）阈值下的表现进行平均的结果&#x3D;&#x3D;。AP考虑了模型在&#x3D;&#x3D;所有可能的分类阈值下的性能&#x3D;&#x3D;，因此是一个衡量模型整体性能的有力指标。<br>$$<br>AP &#x3D; \frac{1}{正例总数} \sum_{k&#x3D;1}^{n} (P(k) \times {rel}(k))<br>$$<br>​其中 $n$ 是返回结果的数量，$P(k)$ 是在前 $k$ 个返回结果中的精确率，$\text{rel}(k)$ 是一个指示函数，如果第 $k$ 个结果是正例，则为 $1$，否则为 $0$。</p><blockquote><p>$PRO$ (per-region-overlap)</p></blockquote><p>​PRO评价模型识别出的&#x3D;&#x3D;异常或目标区域与实际的异常或目标区域的匹配精度&#x3D;&#x3D;。<br>$$<br>PRO &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \frac{P \cap G_n}{G_n} &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \frac{TP_n}{TP_n + FN_n}<br>$$<br>​定位的缺陷结果和实际的真值按连通域划分为 $N$ 个区域，接着求出每个区域中预测结果 $P$ 和真值 $G_n$ 的交集，将交集除以 $G_n$ 后 $N$ 个区域加权平均即可求得 $PRO$ 值 。同时预测结果 $P$ 和真值 $G_n$ 的交集即真阳性样本 $TP_n$ ，故 $PRO$ 也可根据混淆矩阵计算。</p><p><a href="https://arxiv.org/abs/2303.14814">相关论文：WinCLIP</a></p><p><a href="https://arxiv.org/abs/2304.02643">相关论文：SAM</a></p><p><a href="https://arxiv.org/abs/2401.12665">论文链接</a></p><p><a href="https://github.com/Lszcoding/ClipSAM">代码链接（未上传）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式版本控制 Git</title>
      <link href="/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/"/>
      <url>/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-仓库"><a href="#1-仓库" class="headerlink" title="1. 仓库"></a>1. 仓库</h3><blockquote><p>git init –bare</p></blockquote><p>​&#x3D;&#x3D;初始化&#x3D;&#x3D;裸仓库 </p><blockquote><p>git clone …</p></blockquote><p>​&#x3D;&#x3D;克隆&#x3D;&#x3D;远程仓库</p><h3 id="2-ssh-协议"><a href="#2-ssh-协议" class="headerlink" title="2. ssh 协议"></a>2. ssh 协议</h3><blockquote><p>ssh-keygen -t rsa </p></blockquote><ul><li>生成 rsa 公钥(.pub)和私钥，使用<code>-f ~/.ssh/名字</code> 参数指定文件路径和名字。</li><li>生成目录：<code>/Users/用户/.ssh</code>，使用 <code>open ~/.ssh</code> 直接在 finder 打开。</li></ul><blockquote><p>将公钥内容拷贝至&#x3D;&#x3D;服务器.ssh&#x3D;&#x3D;文件夹中&#x3D;&#x3D;authorized_keys&#x3D;&#x3D;文件中。</p></blockquote><p>​本地目录可以使用ssh免密登陆服务器。</p><blockquote><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#x6a;&#x75;&#115;&#116;&#104;&#117;&#x61;&#x79;&#117;&#x40;&#49;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#x2e;&#49;">&#x6a;&#x75;&#115;&#116;&#104;&#117;&#x61;&#x79;&#117;&#x40;&#49;&#50;&#55;&#x2e;&#x30;&#x2e;&#48;&#x2e;&#49;</a>:&#x2F;home&#x2F;user&#x2F;git</p></blockquote><p>​从&#x3D;&#x3D;远程 ssh clone&#x3D;&#x3D; 代码到本地。</p><h3 id="3-配置用户名和密码"><a href="#3-配置用户名和密码" class="headerlink" title="3. 配置用户名和密码"></a>3. 配置用户名和密码</h3><blockquote><p>git config user.name justhuayu</p></blockquote><p>​配置&#x3D;&#x3D;用户名&#x3D;&#x3D;。</p><blockquote><p>git config user.email justhuayu@foxmailcom</p></blockquote><p>​配置&#x3D;&#x3D;邮件&#x3D;&#x3D;。</p><ul><li><code>git config --global</code>参数，&#x3D;&#x3D;全局生效&#x3D;&#x3D;配置。</li><li>配置文件在<code>.git/config</code>中。</li></ul><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4. 工作原理"></a>4. 工作原理</h3><img src="https://telegraph-image-9wl.pages.dev/file/88aaf326263b0a4da0ee8.png" alt="image-20240220191850348" style="zoom:67%;" /><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h2><p>###1. 基本操作</p><blockquote><p>git status</p></blockquote><p>​查看当前&#x3D;&#x3D;工作区状态&#x3D;&#x3D;。  </p><blockquote><p>git add .</p></blockquote><p>​提交当前目录所有文件(.)到&#x3D;&#x3D;暂存区Index&#x3D;&#x3D;。</p><blockquote><p>git commit . -m “提交日志”</p></blockquote><p>​提交当前目录所有文件到&#x3D;&#x3D;本地仓库 Repository&#x3D;&#x3D;。<code>-m &quot;&quot;</code>表示提交&#x3D;&#x3D;日志&#x3D;&#x3D;。</p><blockquote><p>git push origin 本地分支名：远程分支名</p></blockquote><p>​提交当前目录所有文件到&#x3D;&#x3D;远程仓库 Remote&#x3D;&#x3D;。<code>origin</code>是远程仓库地址的&#x3D;&#x3D;别称&#x3D;&#x3D;。</p><blockquote><p>git pull</p></blockquote><p>​&#x3D;&#x3D;拉取合并&#x3D;&#x3D;远程仓库到本地，相当于<code>git fetch + git merge</code>。</p><blockquote><p>git fetch</p></blockquote><p>​将远程仓库所包含分支的&#x3D;&#x3D;最新 commit-id 记录&#x3D;&#x3D;到本地文件，即知道落后远程几个版本。</p><blockquote><p>git log</p></blockquote><p>​查看提交commit日志，会&#x3D;&#x3D;显示40位hash的版本号&#x3D;&#x3D;。下面介绍一些参数：</p><ul><li><code>--oneline</code> 每条日志显示一行</li><li><code>-[length]</code> 只显示前面的length条日志</li><li><code>--skip=[number]</code> 跳过前面number条日志</li><li><code>-p</code> 显示一些统计信息以及文件的改动内容和行信息</li><li><code>--stat</code> 显示提交的作者，日期，message和文件内容统计信息</li><li><code>git shortlog</code> 显示每个 作者提交多少条</li></ul><blockquote alt="info">    <p>        git log 过滤查看commit的内容    </p></blockquote><ul><li><p>按日期：</p><p><code>git log --after=&quot;2001-7-14&quot;</code>、<code>git log --before=&quot;2024-2-20&quot;</code></p></li><li><p>按作者：<br><code>git log --author=&quot;justhuayu&quot;</code></p></li><li><p>按包含提交内容<br><code>git log --grep=&quot;bug&quot;</code> 按照提交本中是否包含bug的日志</p></li><li><p>按文件<br><code>git log --/user/just/go.cpp</code></p></li><li><p>按内容<br><code>git log -S &quot;ngx_free&quot;</code> 所有文件中包含了 ngx_free字符串的修改</p></li><li><p>按照范围<br><code>git log &lt;since&gt;..&lt;until&gt;</code> git log master..feature这可以显示出自从master分支fork之后，feature分支上所有的提交</p></li></ul><blockquote><p>git show commit-id 文件名</p></blockquote><p>​显示&#x3D;&#x3D;commit-id的提交内容&#x3D;&#x3D;，包括所有文件的修改信息</p><blockquote><p>git diff 文件名</p></blockquote><p>​查看本地对某个文件做了&#x3D;&#x3D;哪些修改&#x3D;&#x3D;。<code>git diff commit-id 文件名（commit-id）</code> 显示&#x3D;&#x3D;与某个commit间所有的差异&#x3D;&#x3D;，commit-id可以替换成HEAD，比如HEAD~2。</p><blockquote><p>HEAD 指针</p></blockquote><p>​head指向&#x3D;&#x3D;当前检出记录&#x3D;&#x3D;，最近一次提交<code>commit</code>的引用。</p><h3 id="2-逆向操作"><a href="#2-逆向操作" class="headerlink" title="2. 逆向操作"></a>2. 逆向操作</h3><blockquote><p>git restore -S 文件名</p></blockquote><p>​&#x3D;&#x3D;index -&gt; workspace&#x3D;&#x3D; ，从&#x3D;&#x3D;暂存区 Index回退&#x3D;&#x3D;文件。</p><blockquote><p>git reset –参数 版本号(head^)</p></blockquote><p>​从&#x3D;&#x3D;本地仓库回退&#x3D;&#x3D;文件，回退到哪有&#x3D;&#x3D;3种&#x3D;&#x3D;方式。<code>head^</code>是上个版本。</p><ul><li><code>git reset --soft</code>回退到&#x3D;&#x3D;暂存区Index&#x3D;&#x3D;。</li><li><code>git reset --mixed</code>回退到&#x3D;&#x3D;工作区workspace&#x3D;&#x3D;。 </li><li><code>git reset --hard</code>直接从本地仓库&#x3D;&#x3D;删除&#x3D;&#x3D;。</li></ul><blockquote><p>git checkout -f(强制参数)</p></blockquote><p>​将&#x3D;&#x3D;工作区workspace&#x3D;&#x3D;的所有&#x3D;&#x3D;状态删掉&#x3D;&#x3D;，例如创建了文件，修改了文件后，<code>git status</code>会有提示，使用<code>git checkout</code>后提示消失，但是对文件的创建和修改不会消失。</p><h3 id="3-本地仓库整理操作"><a href="#3-本地仓库整理操作" class="headerlink" title="3. 本地仓库整理操作"></a>3. 本地仓库整理操作</h3><blockquote><p>git commit –amend</p></blockquote><p>​整理&#x3D;&#x3D;上一次&#x3D;&#x3D;提交，即将这次的提交&#x3D;&#x3D;复用上次的提交&#x3D;&#x3D;。</p><blockquote><p>git rebase -i h1 h2</p></blockquote><p>​整理&#x3D;&#x3D;多次&#x3D;&#x3D;提交，从版本号 h1 到 h2，&#x3D;&#x3D;左开右闭&#x3D;&#x3D;。<code>git rebase -i</code>是所有提交。</p><p>​&#x3D;&#x3D;左开右闭的理解&#x3D;&#x3D;：从1到3的几次提交，2会依赖3，1会依赖2，所以是左开右闭。</p><blockquote alt="info">    <p>        对于前后两次提交a和b，整理a操作流程    </p></blockquote><ol><li><code>git rebase -i a版本号 b版本号</code>，版本号只要能区分即可，无论多少位。</li><li>在vim页面，修改 a 前缀为<code>edit</code>，b前缀不变，保存退出vim。</li><li>此时在变基状态，修改需要修改的对应内容。</li><li><code>git add .</code>提交修改的内容到暂缓区Index。</li><li><code>git commit -amend</code>整理提交这次的内容到 a 版本号。</li><li><code>git rebase --continue</code> 退出变基。</li></ol><blockquote alt="danger">    <p>        使用整理仓库，必须没有人基于这个分支开发    </p></blockquote><p>​从变基（rebase）那个节点开始，往后&#x3D;&#x3D;所有节点的commit-id&#x3D;&#x3D;都会变化。</p><h3 id="4-分支操作"><a href="#4-分支操作" class="headerlink" title="4. 分支操作"></a>4. 分支操作</h3><blockquote><p>git branch </p></blockquote><p>​&#x3D;&#x3D;显示&#x3D;&#x3D;本地所有分支。<code>git branch -a</code>会显示&#x3D;&#x3D;本地和远程&#x3D;&#x3D;的分支。</p><blockquote><p>git branch 分支名 || git checkout -b 分支名</p></blockquote><p>​&#x3D;&#x3D;创建&#x3D;&#x3D;新分支。<code>git checkout -b</code>在创建分支后会&#x3D;&#x3D;自动切换&#x3D;&#x3D;到新分支上，而<code>git branch </code>不会。</p><blockquote><p>git switch 分支名 || git checkout 分支名</p></blockquote><p>​&#x3D;&#x3D;切换&#x3D;&#x3D;分支。</p><blockquote><p>git merge 分支名 || git rebase（不建议使用）</p></blockquote><p>​&#x3D;&#x3D;合并&#x3D;&#x3D;分支，即将命令中分支合并到当前分支。</p><blockquote alt="info">    <p>        对于两个分支pub和pri（pub是公，pri是私），git merge 合并分支操作流程    </p></blockquote><ol><li>&#x3D;&#x3D;切换&#x3D;&#x3D;分支 pub 并&#x3D;&#x3D;拉取&#x3D;&#x3D; pub 最新数据，<code>git switch pub </code>&amp;&amp;<code>git pull</code>。</li><li>将pub的代码&#x3D;&#x3D;合并到pri&#x3D;&#x3D;，<code>git switch pri </code>&amp;&amp;<code>git merge pub </code>。</li><li>进入merge状态，解决冲突，&#x3D;&#x3D;HEAD&#x3D;&#x3D;是本分支内容。</li><li><code>git add .</code>提交&#x3D;&#x3D;暂缓区&#x3D;&#x3D;。</li><li><code>git commit . -i -m &quot;fix:merge pub&quot;</code> &#x3D;&#x3D;提交冲突&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;测试&#x3D;&#x3D;代码是否正确。</li><li>将 pri 的代码&#x3D;&#x3D;合并到pub&#x3D;&#x3D;，<code>git switch pub</code>&amp;&amp;<code>git merge pri</code>。</li><li>提交代码到远端 pub 分支，<code>git push origin pub</code>。</li></ol><blockquote alt="danger">    <p>        git rebase 合并分支操作流程 （不建议），除非没别人依赖于当前分支    </p></blockquote><p>​大部分与<code>git merge</code>相同，只是依赖于哪个分支时，合并将<code>git merge 依赖分支</code>改成如下几步骤：</p><ol><li><code>git rebase 依赖分支名</code></li><li><code>git add .</code></li><li><code>git rebase --continue</code></li></ol><blockquote alt="danger">    <p>        git rebase 与 git merge 区别    </p></blockquote><p>​两者主要在于&#x3D;&#x3D;时间线不同&#x3D;&#x3D;，使用<code>git rebase</code>时要求&#x3D;&#x3D;没别人依赖&#x3D;&#x3D;于当前分支，因为会&#x3D;&#x3D;改变commit-id。&#x3D;&#x3D;</p><img src="https://telegraph-image-9wl.pages.dev/file/3a0bb7860bfec739a515c.png" alt="image-20240220215853137" style="zoom:70%;" /><p>​上图理解：左图将两个分支&#x3D;&#x3D;直接合并&#x3D;&#x3D;，右图（lshift和mod是一个东西）将另一个分支的修改&#x3D;&#x3D;直接放在当前分支最新状态的后面。&#x3D;&#x3D;</p><blockquote alt="danger">    <p>        git rebase 原理    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/cd978a907ace8e9cc044b.png" alt="image-20240220220558946" style="zoom:67%;" /><p>​<code>git rebase</code>将待合并分支&#x3D;&#x3D;直接应用&#x3D;&#x3D;到当前分支&#x3D;&#x3D;最新状态的后面&#x3D;&#x3D;，并且会改变&#x3D;&#x3D;commit-id&#x3D;&#x3D;，即上图中 $\text{C}$ 和 $\text{C’}$ 的 &#x3D;&#x3D;commit-id不同&#x3D;&#x3D;，因此使用<code>git rebase</code>&#x3D;&#x3D;要求没人依赖&#x3D;&#x3D;。</p><blockquote><p>git branch -d 分支名</p></blockquote><p>​&#x3D;&#x3D;删除本地&#x3D;&#x3D;分支。</p><blockquote><p>git push origin -d 分支名</p></blockquote><p>​&#x3D;&#x3D;删除远端&#x3D;&#x3D;分支。</p><h3 id="5-冲突"><a href="#5-冲突" class="headerlink" title="5.冲突"></a>5.冲突</h3><blockquote><p>产生冲突原因</p></blockquote><p>​&#x3D;&#x3D;不同分支修改&#x3D;&#x3D;了同一文件的&#x3D;&#x3D;同一行或相邻行&#x3D;&#x3D;。</p><blockquote><p>解决原则</p></blockquote><p>​不影响其他人提交的功能，也不破坏自己提交的功能。协商解决。</p><blockquote><p>解决 git merge 冲突</p></blockquote><ol><li>修改冲突代码。</li><li><code>git add .</code></li><li><code>git commit . -i -m &quot;fix:...&quot;</code></li></ol><blockquote><p>解决 git rebase 冲突</p></blockquote><ol><li><p>修改冲突代码</p></li><li><p><code>git add .</code></p></li><li><p><code>git rebase --continue</code></p></li></ol><h2 id="3-使用规范"><a href="#3-使用规范" class="headerlink" title="3. 使用规范"></a>3. 使用规范</h2><h3 id="1-分支规范"><a href="#1-分支规范" class="headerlink" title="1. 分支规范"></a>1. 分支规范</h3><img src="https://telegraph-image-9wl.pages.dev/file/e0453fca5043662c7e18f.png" alt="image-20240220221741111" style="zoom:50%;" /><p>​上述图片中，&#x3D;&#x3D;黑框是有远端分支&#x3D;&#x3D;，其余没有远端分支。</p><img src="https://telegraph-image-9wl.pages.dev/file/b7a3c487821d87bf6b86c.png" alt="image-20240220222205748" style="zoom:45%;" />]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection</title>
      <link href="/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/"/>
      <url>/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="AnomalyCLIP"><a href="#AnomalyCLIP" class="headerlink" title="AnomalyCLIP"></a>AnomalyCLIP</h1><img src="https://telegraph-image-9wl.pages.dev/file/bde3dbfce428b9d30dc25.png" alt="image-20240220100508474" style="zoom:43%;" /><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-ZSAD（零样本异常检测）任务"><a href="#1-ZSAD（零样本异常检测）任务" class="headerlink" title="1. ZSAD（零样本异常检测）任务"></a>1. ZSAD（零样本异常检测）任务</h3><p>​需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。</p><h3 id="2-CLIP用于异常检测存在的问题"><a href="#2-CLIP用于异常检测存在的问题" class="headerlink" title="2. CLIP用于异常检测存在的问题"></a>2. CLIP用于异常检测存在的问题</h3><blockquote><p>​&#x3D;&#x3D;CLIP主要针对的是前景对象的类语义，而不是图像中的异常&#x2F;正常&#x3D;&#x3D;，这限制了它们在理解视觉异常&#x2F;正常时的泛化能力，导致ZSAD性能较弱。</p></blockquote><h3 id="3-之前的文本提示存在问题"><a href="#3-之前的文本提示存在问题" class="headerlink" title="3. 之前的文本提示存在问题"></a>3. 之前的文本提示存在问题</h3><blockquote><p>​使用手动定义的文本提示或可学习的提示，通常会导致快速嵌入，选择全局特征进行有效的对象语义对齐，&#x3D;&#x3D;未能捕捉到异常，这种异常通常表现为细粒度的局部特征&#x3D;&#x3D;。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-对象无关文本提示在ZSAD上的有效性"><a href="#1-对象无关文本提示在ZSAD上的有效性" class="headerlink" title="1. 对象无关文本提示在ZSAD上的有效性"></a>1. 对象无关文本提示在ZSAD上的有效性</h3><blockquote><p>​首次揭示了学习正常和异常的&#x3D;&#x3D;对象无关文本提示&#x3D;&#x3D;是一种简单而有效的准确的ZSAD方法，AnomalyCLIP模型&#x3D;&#x3D;允许对象不可知&#x3D;&#x3D;，具有很强的ZSAD性能。</p></blockquote><h3 id="2-对象无关提示模版"><a href="#2-对象无关提示模版" class="headerlink" title="2. 对象无关提示模版"></a>2. 对象无关提示模版</h3><blockquote><p>​定义了一个&#x3D;&#x3D;对象无关的提示模板&#x3D;&#x3D;，&#x3D;&#x3D;简化了提示符的设计&#x3D;&#x3D;，&#x3D;&#x3D;不需要修改提示词&#x3D;&#x3D;，即可用于不同领域。</p></blockquote><p>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{object}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{object}]<br>$$</p><h3 id="3-全局局部异常损失函数"><a href="#3-全局局部异常损失函数" class="headerlink" title="3. 全局局部异常损失函数"></a>3. 全局局部异常损失函数</h3><blockquote><p>​定义了一个&#x3D;&#x3D;全局局部异常损失函数&#x3D;&#x3D;。</p></blockquote><h3 id="4-对角突出注意力DPAM"><a href="#4-对角突出注意力DPAM" class="headerlink" title="4. 对角突出注意力DPAM"></a>4. 对角突出注意力DPAM</h3><blockquote><p>​DPAM(Diagonally Prominent Attention Map)，使得分割图的注意力更加突出。</p></blockquote><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-对象无关的提示词"><a href="#1-对象无关的提示词" class="headerlink" title="1. 对象无关的提示词"></a>1. 对象无关的提示词</h3><blockquote><p>​为区分异常和非异常，设计提示词 [damaged]</p></blockquote><p>​CLIP中常用提示 A photo of A [cls] ，主要&#x3D;&#x3D;关注对象语义&#x3D;&#x3D;。为了支持异常判别文本嵌入的学习，我们的&#x3D;&#x3D;目标是将先验异常语义整合到文本提示模板&#x3D;&#x3D;中。</p><p>​采用文本 damaged [cls] 为&#x3D;&#x3D;覆盖全面异常语义的通用提示模版&#x3D;&#x3D;，引入&#x3D;&#x3D;可学习的文本提示模板进行微调&#x3D;&#x3D;。<br>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{cls}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{cls}]<br>$$</p><blockquote><p>​为识别一般异常模式，忽略对象，设计提示词 [object]</p></blockquote><p>​对象语义上存在一些实质性的差异，但&#x3D;&#x3D;底层的异常模式可能是相似的&#x3D;&#x3D;。</p><p>​对于ZSAD来说，在对象感知的&#x3D;&#x3D;文本提示模板中包含对象语义通常是不必要的&#x3D;&#x3D;。它甚至会&#x3D;&#x3D;阻碍&#x3D;&#x3D;对学习过程中没有发现的类异常现象的检测。</p><p>​文本提示模板中排除对象语义允许可学习的文本提示模板&#x3D;&#x3D;专注于捕获异常本身的特征，而不是对象&#x3D;&#x3D;。</p><blockquote alt="info"><p>最终提示词</p></blockquote><p>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{object}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{object}]<br>$$</p><h3 id="2-全局局部异常损失函数"><a href="#2-全局局部异常损失函数" class="headerlink" title="2. 全局局部异常损失函数"></a>2. 全局局部异常损失函数</h3><blockquote alt="info"><p>最终损失</p></blockquote><p>$$<br>L_{total} &#x3D; L_{global} + \lambda \sum_{M_k \in M} L_{local}^{M_k}<br>$$</p><blockquote><p>​$L_{global}$是全局上下文优化，目的是强制我们的不可知对象的文&#x3D;&#x3D;本嵌入与全局视觉嵌入的图像匹配&#x3D;&#x3D;。</p></blockquote><p>​$L_{global}$  是交叉熵函数，匹配正常&#x2F;异常图像的文本嵌入和视觉嵌入之间的余弦相似度。<br>$$<br>L_{\text{global}} &#x3D; -\frac{1}{N} \sum_{i&#x3D;1}^{N} \left[ y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right]<br>$$</p><blockquote><p>​$L_{local}$是局部上下文优化，关注视觉编码器&#x3D;&#x3D;M中间层细粒度的局部异常区域&#x3D;&#x3D;。</p></blockquote><p>$$<br>S^{(j,k)}_n &#x3D; P(g_n, f_i^{m(j,k)}), \quad j \in [1,H], \quad k \in [1,W]<br>$$</p><p>$$<br>S^{(j,k)}_a &#x3D; P(g_a, f_i^{m(j,k)}), \quad j \in [1,H], \quad k \in [1,W<br>$$</p><p>$$<br>L_ &#x3D; {Focal}([{Up}(S_n), {Up}(S_a)], S) + {Dice}({Up}(S_n), I - S) + {Dice}({Up}(S_a), S)<br>$$</p><ul><li>$[^.,^.]$ 代表沿着哪个维度。</li><li>$U_P(.)$  代表上采样。</li><li>$I$ 代表全 1 向量</li><li>$f_i^{m(j,k)}$ 代表图片经视觉编码器后M层特征</li><li>$P()$ 代表CLIP概率  $p(y &#x3D; c | x_i) &#x3D; P(g_c, f_i) &#x3D; \frac{\exp(\langle g_c, f_i \rangle &#x2F; \tau)}{\sum_{c \in C} \exp(\langle g_c, f_i \rangle &#x2F; \tau)}$</li></ul><blockquote><p>​Focal Loss</p></blockquote><p>​主要用于解决&#x3D;&#x3D;目标检测中的类别不平衡问题&#x3D;&#x3D;。这个损失函数是交叉熵损失的一个变体，它通过&#x3D;&#x3D;减少易分类样本的相对损失来增加模型对难分类样本的关注&#x3D;&#x3D;。</p><p>​给定模型对正类的预测概率为 $P$ （对于负类为 $1-P$）。<br>$$<br>{Focal Loss}(p_t) &#x3D; -\alpha_t (1 - p_t)^\gamma \log(p_t)<br>$$</p><ul><li><p>$p_t$ 是模型对实际标签为 $t$  的预测概率。</p></li><li><p>$\alpha$ 是一个权重因子，用于平衡正负样本之间的不平衡。</p></li><li><p>$\gamma$ 是调节因子，用于减少易分类样本的权重，增强难分类样本的影响。</p></li></ul><blockquote><p>​Dice Loss</p></blockquote><p>​通常用于&#x3D;&#x3D;医学图像分割领域&#x3D;&#x3D;，用于解决&#x3D;&#x3D;分割任务中的类别不平衡问题&#x3D;&#x3D;。Dice Loss 是一种用于&#x3D;&#x3D;比较两个样本相似度的度量&#x3D;&#x3D;，特别是在分割任务中，用于&#x3D;&#x3D;比较预测分割图和真实分割图的相似度&#x3D;&#x3D;。</p><p>​给定预测结果 $P$ 和真实标签 $G$（均为二值图像）。</p><p>$$<br>{Dice Loss}(P,G) &#x3D; 1 - \frac{2 \sum_{i&#x3D;1}^{N} p_i g_i + \epsilon}{\sum_{i&#x3D;1}^{N} p_i^2 + \sum_{i&#x3D;1}^{N} g_i^2 + \epsilon}<br>$$</p><ul><li>$p_i$和$g_i$分别是预测结果和真实标签在像素 $i$处的值。</li><li>$N$ 是图像中的像素总数。</li><li>$\epsilon$ 是一个小的平滑项，用于防止分母为零，通常取一个很小的正数。</li></ul><h3 id="3-Text-encoder的细化"><a href="#3-Text-encoder的细化" class="headerlink" title="3. Text encoder的细化"></a>3. Text encoder的细化</h3><img src="https://telegraph-image-9wl.pages.dev/file/fff42825d595a8caaaf5e.png" alt="image-20240221100146558" style="zoom:50%;" /><blockquote><p>​为了便于通过损失函数学习更有区别的文本空间，通过在&#x3D;&#x3D;CLIP的文本编码器中添加额外的可学习标记&#x3D;&#x3D;来优化原始文本空间。</p></blockquote><ol><li>随机初始化 $M$ 层可学习标记 $t’_{m}$。</li><li>在通道层 channel 拼接可学习标记 $t’<em>{m}$ 和原始向量 $t’</em>{m}$，$[t’_{m},t_m]$。</li><li>通过$M$ 层神经网络 $T_M$，即 $[r’<em>{m+1},t</em>{m+1}] &#x3D; T_M([t’_{m},t_m])$。</li><li>丢弃 $r’<em>{m+1}$（提供&#x3D;&#x3D;更多可学习标记&#x3D;&#x3D;） ，重新初始化新的可学习标记 $t’</em>{m+1}$ ，重复上述步骤。</li></ol><h3 id="4-Local-visual-embedding-的细化"><a href="#4-Local-visual-embedding-的细化" class="headerlink" title="4. Local visual embedding 的细化"></a>4. Local visual embedding 的细化</h3><blockquote><p>​提出DPAM注意力机制，减少其他标记的干扰，改善局部视觉语义。</p></blockquote><p>​CLIP中使用的对比损耗使得 visual encoder 产生一个具有代表性的全局嵌入来识别语义类，这些标记可能有助于全局对象识别，但它们&#x3D;&#x3D;破坏了局部视觉语义&#x3D;&#x3D;，这直接&#x3D;&#x3D;阻碍了&#x3D;&#x3D;对对象无关文本提示中的&#x3D;&#x3D;细粒度异常的有效学习&#x3D;&#x3D;。<br>$$<br>{Attention}(Q,K,V)<em>i &#x3D; {softmax}\left( \frac{q_i K^{\top}}{\sqrt{D}} \right) V &#x3D; \frac{\sum</em>{j&#x3D;1}^{n} a_{ij}^{qk} v_j}{\sum_{j&#x3D;1}^{n} a_{ij}^{qk}}, \quad a_{ij}^{qk} &#x3D; e^{\frac{q_i k_j^{\top}}{\sqrt{D}}}<br>$$<br>​对于上述 CLIP 的 visual encoder 中的 $Q - K$ 注意力机制，将 $a_{ij}^{qk}$ 替换如下：<br>$$<br>a_{ij}^{qq} &#x3D; e^{\frac{q_i q_j^{\top}}{\sqrt{D}}}, \quad a_{ij}^{kk} &#x3D; e^{\frac{k_i k_j^{\top}}{\sqrt{D}}}, \quad a_{ij}^{vv} &#x3D; e^{\frac{v_i v_j^{\top}}{\sqrt{D}}}<br>$$</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/d925c1729c6052f540266.png" alt="image-20240220152918094" style="zoom:38%;" /><ol><li><p>Image-level 使用相似度分数 $P(g_a,f_i)$ 作为异常分数，$g_a$ 是 text embedding，$f_i$ 是visual embedding。$g_a&#x3D;f_i$ 时，$P(g_a,f_i) &#x3D; 1$。</p></li><li><p>Pixel-level  使用如下公式计算异常得分。<br>$$<br>\quad M &#x3D; G_{\sigma}\left(\text{Bilinear Interpolation}\left( \frac{1}{2} (I - S_n + S_a)\right)\right)，M \in \mathbb{R}^{H_{\text{image}} \times W_{\text{image}}}<br>$$</p></li></ol><p><a href="https://arxiv.org/abs/2310.18961">论文链接</a></p><p><a href="https://github.com/zqhang/AnomalyCLIP">代码链接（未上传）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install_name_tool 解决链接找不到动态库</title>
      <link href="/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>在学习cmake时，遇到链接动态库后，运行二进制文件找不到动态库的问题。</p><img src="https://telegraph-image-9wl.pages.dev/file/dbe8655627acc332ef9c7.png" alt="image-20240217224721043" style="zoom: 39%;" /></blockquote><p>​工程目录如下图</p><img src="https://telegraph-image-9wl.pages.dev/file/ac58a15f15d7acdb25de5.png" alt="image-20240217134118637" style="zoom:50%;" /><p>​在CMakeLists.txt文件中代码如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.8</span>.<span class="number">4</span>)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main main.c)</span><br><span class="line"><span class="comment">#添加项目头文件目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(../<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="comment">#设置项目lib库目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIB_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#链接动态库和项目</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main <span class="variable">$&#123;LIB_PATH&#125;</span>/libhello.dylib)</span><br><span class="line"><span class="comment">#在bin目录下生成二进制文件</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​我需要链接 libhello.dylib，但是打印链接路径却为</p><img src="https://telegraph-image-9wl.pages.dev/file/91608d55048c27e430d65.png" alt="image-20240217190928315" style="zoom:50%;" /><p>​这里的第一行 libhello.1.dylib 就是 libhello.dylib， libhello.dylib 的内部名称被设置为 libhello.1.dylib，使用 &#x3D;&#x3D;otool -D libhello.dylib&#x3D;&#x3D; 进行查看。</p><img src="https://telegraph-image-9wl.pages.dev/file/74d28ecd358f74d505746.png" alt="image-20240217224353351" style="zoom:80%;" /><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>install_name_tool 添加动态库路径</p></blockquote><blockquote><p>install_name_tool -change old_path new_path binary</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change libhello.1.dylib @executable_path/../../lib/libhello.1.dylib ./bin/main</span><br></pre></td></tr></table></figure><p>​查看此时链接文件路径：</p><img src="https://telegraph-image-9wl.pages.dev/file/112da3b94fbb6c6e98679.png" alt="image-20240217225920116" style="zoom:50%;" /><p>​直接运行二进制文件成功。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/"/>
      <url>/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="1-CMake使用"><a href="#1-CMake使用" class="headerlink" title="1. CMake使用"></a>1. CMake使用</h2><h3 id="1-内部构建"><a href="#1-内部构建" class="headerlink" title="1. 内部构建"></a>1. 内部构建</h3><blockquote><ol><li>&#x3D;&#x3D;cmake .&#x3D;&#x3D;  ，’ . ‘ 表示在当前目录构建。</li><li>在当前目录 &#x3D;&#x3D;make&#x3D;&#x3D;，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。</li></ol></blockquote><h3 id="2-外部构建"><a href="#2-外部构建" class="headerlink" title="2. 外部构建"></a>2. 外部构建</h3><blockquote><ol><li>创建目录 &#x3D;&#x3D;mkdir build&#x3D;&#x3D;。</li><li>构建 &#x3D;&#x3D;cmake ..&#x3D;&#x3D; ，’ .. ‘ 表示从上层构建。（其他路径构建用 &#x3D;&#x3D;cmake &lt;工程的全路径&gt;&#x3D;&#x3D;）</li><li>在当前目录 &#x3D;&#x3D;make&#x3D;&#x3D;，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。</li></ol></blockquote><blockquote alt="warn"><p>通过外部编译进行工程构建，PROJECT_SOURCE_DIR 仍然指代工程路径，即cmake/t1 而 PROJECT_BINARY_DIR 则指代编译路径，即cmake/t1/build</p></blockquote><h3 id="3-约定目录"><a href="#3-约定目录" class="headerlink" title="3. 约定目录"></a>3. 约定目录</h3><ol><li>子目录&#x3D;&#x3D;src&#x3D;&#x3D;，用来放置&#x3D;&#x3D;工程源代码&#x3D;&#x3D;。</li><li>子目录&#x3D;&#x3D;doc&#x3D;&#x3D;，用来放置这个工程的文档&#x3D;&#x3D;工程名.txt&#x3D;&#x3D;。</li><li>子目录&#x3D;&#x3D;lib&#x3D;&#x3D;，用于放置工程&#x3D;&#x3D;共享库&#x3D;&#x3D;。</li><li>工程目录添加文本文件 &#x3D;&#x3D;COPYRIGHT, README&#x3D;&#x3D;。</li><li>工程目录添加一个&#x3D;&#x3D;runhello.sh&#x3D;&#x3D; 脚本，用来&#x3D;&#x3D;调用工程二进制文件&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;构建后&#x3D;&#x3D;的目标文件放入构建目录的&#x3D;&#x3D;bin 子目录&#x3D;&#x3D;。</li><li>安装：将&#x3D;&#x3D;工程二进制&#x3D;&#x3D;与&#x3D;&#x3D;runhello.sh&#x3D;&#x3D; 安装至&#x2F;usr&#x2F;bin，将&#x3D;&#x3D;doc 目录的内容&#x3D;&#x3D;以及&#x3D;&#x3D;COPYRIGHT&#x2F;README&#x3D;&#x3D; 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;项目名。</li></ol><h3 id="4-安装共享库"><a href="#4-安装共享库" class="headerlink" title="4. 安装共享库"></a>4. 安装共享库</h3><p>​使用外部构建，即在build文件下执行下列操作。</p><ol><li>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;Users&#x2F;justhuayu&#x2F;mylibs ..  设置项目安装目录</li><li>make </li><li>make install</li></ol><h3 id="5-使用共享库"><a href="#5-使用共享库" class="headerlink" title="5. 使用共享库"></a>5. 使用共享库</h3><p>​项目路径如下。</p><img src="https://telegraph-image-9wl.pages.dev/file/ac58a15f15d7acdb25de5.png" alt="image-20240217134118637" style="zoom:50%;" /><p>​子目录 CMakeLists.txt 文件代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.8</span>.<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main main.c)</span><br><span class="line"><span class="comment">#添加项目头文件目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(../<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="comment">#设置项目lib库目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIB_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#MESSAGE(STATUS &quot;LIB_PATH is &quot; $&#123;LIB_PATH&#125;)</span></span><br><span class="line"><span class="comment">#链接动态库和项目</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main <span class="variable">$&#123;LIB_PATH&#125;</span>/libhello.dylib)</span><br><span class="line"><span class="comment">#在bin目录下生成二进制文件</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure><ol><li>cmake .. +  make 构建。</li><li>linux使用ldd bin&#x2F;main ，macos使用 otool -L bin&#x2F;main 查看链接库（静态库不显示）。</li></ol><h3 id="6-编译-debug-版和-release-版"><a href="#6-编译-debug-版和-release-版" class="headerlink" title="6. 编译 debug 版和 release 版"></a>6. 编译 debug 版和 release 版</h3><blockquote><p>编译debug版本</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>​生成的执行文件和库在 &#x2F;release&#x2F;linux&#x2F;Debug</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定构建类型的输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Debug)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Release)</span><br><span class="line"><span class="comment"># 对于库文件，也可以设置相应的目录</span></span><br><span class="line"><span class="comment"># set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ...)</span></span><br><span class="line"><span class="comment"># set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ...)</span></span><br></pre></td></tr></table></figure><blockquote><p>编译release版本</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><h3 id="1-PROJECT"><a href="#1-PROJECT" class="headerlink" title="1. PROJECT"></a>1. PROJECT</h3><blockquote><p>PROJECT(projectname [CXX] [C] [Java])</p></blockquote><p>​这个指令&#x3D;&#x3D;定义工程名称&#x3D;&#x3D;，并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。</p><p>​隐式的定义了两个 cmake 变量: <projectname>_BINARY_DIR 以及<projectname> _SOURCE_DIR。例如 <code>PROJECT(hello)</code>，则为 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。</p><p>​cmake 也预定义了 &#x3D;&#x3D;PROJECT_BINARY_DIR&#x3D;&#x3D; 和 &#x3D;&#x3D;PROJECT_SOURCE_DIR&#x3D;&#x3D;变量（&#x3D;&#x3D;建议使用&#x3D;&#x3D;），他们的值分别跟HELLO_BINARY_DIR 与HELLO_SOURCE_DIR 一致。</p><ol><li>PROJECT_BINARY_DIR 表示&#x3D;&#x3D;编译路径&#x3D;&#x3D;。</li><li>PROJECT_SOURCE_DIR 表示&#x3D;&#x3D;项目路径&#x3D;&#x3D;。</li></ol><h3 id="2-SET"><a href="#2-SET" class="headerlink" title="2. SET"></a>2. SET</h3><blockquote><p>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</p></blockquote><p>​SET 指令可以用来&#x3D;&#x3D;显式的定义变量&#x3D;&#x3D;。<code>SET(SRC_LIST main.c t1.c t2.c)</code>。</p><h3 id="3-MESSAGE"><a href="#3-MESSAGE" class="headerlink" title="3. MESSAGE"></a>3. MESSAGE</h3><blockquote><p>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “打印信息” …)</p></blockquote><p>​这个指令用于向终端&#x3D;&#x3D;输出用户定义的信息&#x3D;&#x3D;，包含了三种类型: </p><ol><li><p>&#x3D;&#x3D;SEND_ERROR&#x3D;&#x3D;，产生错误，生成过程被跳过。</p><p><code>message(SEND_ERROR &quot;cmake is error&quot;)</code></p></li><li><p>&#x3D;&#x3D;SATUS&#x3D;&#x3D;，输出前缀为—的信息。</p><p><code>message(STATUS &quot;This is BINARY dir &quot; $&#123;PROJECT_BINARY_DIR&#125;)</code></p></li><li><p>&#x3D;&#x3D;FATAL_ERROR&#x3D;&#x3D;，立即终止所有cmake 过程。</p></li></ol><h3 id="4-ADD-EXECUTABLE"><a href="#4-ADD-EXECUTABLE" class="headerlink" title="4. ADD_EXECUTABLE"></a>4. ADD_EXECUTABLE</h3><blockquote><p>ADD_EXECUTABLE(二进制文件名 ${源文件变量名})</p></blockquote><p>​生成可执行文件，相关的源文件是&#x3D;&#x3D;${源文件变量名}&#x3D;&#x3D;中定义的源文件列表。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello)</span><br><span class="line"><span class="keyword">SET</span>(src_file main.c)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;src_file&#125;</span>)</span><br></pre></td></tr></table></figure><p>​上述将 main.c 文件生成 hello 可执行文件，等价于</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c)</span><br></pre></td></tr></table></figure><h3 id="5-ADD-SUBDIRECTORY"><a href="#5-ADD-SUBDIRECTORY" class="headerlink" title="5. ADD_SUBDIRECTORY"></a>5. ADD_SUBDIRECTORY</h3><blockquote><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p></blockquote><p>​向当前工程&#x3D;&#x3D;添加存放源文件的子目录&#x3D;&#x3D;，并可以指定中间二进制和目标二进制存放的位置。</p><p>​EXCLUDE_FROM_ALL 参数的含义是将&#x3D;&#x3D;这个目录从编译过程中排除&#x3D;&#x3D;。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>​上述代码会将 src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。</p><h3 id="6-指定保存目标二进制位置"><a href="#6-指定保存目标二进制位置" class="headerlink" title="6. 指定保存目标二进制位置"></a>6. 指定保存目标二进制位置</h3><blockquote><p>EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><p>​上述代码写在哪个 CMakeLists.txt ：在哪里 ADD_EXECUTABLE  或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义。</p><h3 id="7-INSTALL"><a href="#7-INSTALL" class="headerlink" title="7. INSTALL **"></a>7. INSTALL **</h3><blockquote><p>INSTALL(TARGETS targets…</p><p>[[ARCHIVE|LIBRARY|RUNTIME]</p><p>[DESTINATION <dir>]</p><p>[PERMISSIONS permissions…]</p><p>[CONFIGURATIONS</p><p>[Debug|Release|…]]</p><p>[COMPONENT <component>]</p><p>[OPTIONAL]</p><p>] […])</p></blockquote><h3 id="8-清理工程"><a href="#8-清理工程" class="headerlink" title="8. 清理工程"></a>8. 清理工程</h3><blockquote><p>make clean</p></blockquote><p>​和 Makefile 一样，使用 <code>make clean</code> 对构建结果进行清理。</p><h3 id="9-ADD-LIBRARY"><a href="#9-ADD-LIBRARY" class="headerlink" title="9. ADD_LIBRARY"></a>9. ADD_LIBRARY</h3><blockquote><p>ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL]</p><p>source1 source2 … sourceN)</p></blockquote><p>​生成库文件。</p><p>​libname不用写全称，写 hello，cmake会自动生成 libhello.X。</p><ol><li><p>SHARED，动态库</p></li><li><p>STATIC，静态库</p></li><li><p>MODULE，在使用 dyld 的系统有效，如果不支持dyld，则被当作SHARED 对待。</p></li></ol><p>​EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。</p><blockquote><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})#SHARED动态库</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在 lib 目录下建立 CMakeLists.txt，内容如下：</span></span><br><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.c)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#SHARED动态库</span></span><br></pre></td></tr></table></figure><p>​然后 <code>cmake ..</code> ， <code> make</code> ，此时可以在lib 目录得到一个&#x3D;&#x3D;libhello.so&#x3D;&#x3D;，这就是我们期望的共享库。</p><p>​指定 libhello.so 生成的位置，可以通过在&#x3D;&#x3D;主工程文件&#x3D;&#x3D;CMakeLists.txt 中修改 &#x3D;&#x3D;ADD_SUBDIRECTORY(lib)&#x3D;&#x3D;指令来指定一个编译输出位置 或者 在 &#x3D;&#x3D;lib&#x2F;CMakeLists.txt&#x3D;&#x3D; 中添加 &#x3D;&#x3D;SET(LIBRARY_OUTPUT_PATH &lt;路径&gt;)&#x3D;&#x3D;来指定一个新的位置。</p><h3 id="10-SET-TARGET-PROPERTIES"><a href="#10-SET-TARGET-PROPERTIES" class="headerlink" title="10. SET_TARGET_PROPERTIES"></a>10. SET_TARGET_PROPERTIES</h3><blockquote><p>SET_TARGET_PROPERTIES(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)</p></blockquote><p>​设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#STATIC静态库</span></span><br></pre></td></tr></table></figure><blockquote alt="danger"><p>工程中可同时存在静态库和动态库，只不过<strong style="color:red;">动态库后缀.so，静态库后缀.a</strong>。但当存在动态库时，使用上述命令会报错，因为<strong style="color:red;">hello 作为一个target 是不能重名的</strong>，所以，静态库构建指令无效。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.c)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#STATIC静态库</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>) </span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>上述代码执行后即可得到动态库和静态库，如果只有一个，则考虑下述解决方式</p></blockquote><p>​此时查看构建结果，发现&#x3D;&#x3D;hello.so&#x3D;&#x3D;消失，只有&#x3D;&#x3D;hello.a&#x3D;&#x3D;。cmake 在构建一个新的target 时，会尝试&#x3D;&#x3D;清理掉其他使用这个名字的库&#x3D;&#x3D;，因为，在构建libhello.a 时，就会清理掉libhello.so。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向lib/CMakeLists.txt 中添加:</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​这时候，我们再次进行构建，会发现build&#x2F;lib 目录中同时生成了libhello.so 和 libhello.a。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>) </span><br></pre></td></tr></table></figure><p>​VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="11-INCLUDE-DIRECTORIES"><a href="#11-INCLUDE-DIRECTORIES" class="headerlink" title="11. INCLUDE_DIRECTORIES"></a>11. INCLUDE_DIRECTORIES</h3><blockquote><p>INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</p></blockquote><p>​向工程添加多个特定的&#x3D;&#x3D;头文件搜索路径&#x3D;&#x3D;，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，&#x3D;&#x3D;默认&#x3D;&#x3D;的行为是追加到当前的&#x3D;&#x3D;头文件搜索路径的后面&#x3D;&#x3D;。</p><p>​控制将头文件搜索路径放在前面还是后面：</p><ol><li>CMAKE_INCLUDE_DIRECTORIES_BEFORE，通过&#x3D;&#x3D;SET 这个cmake 变量为on&#x3D;&#x3D;，可以将添加的&#x3D;&#x3D;头文件搜索路径&#x3D;&#x3D;放在已有路径的&#x3D;&#x3D;前面&#x3D;&#x3D;。</li><li>通过AFTER 或者BEFORE 参数，也可以控制是追加还是置前。</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/<span class="keyword">include</span>/hello)</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>上述代码执行后找到头文件，但可能会报错</p></blockquote><p>​进入build 目录，重新进行构建，这是找不到 hello.h 的错误已经消失，但是出现了一个新的错误：<code>main.c:(.text+0x12): undefined reference to HelloFunc</code>因为我们并没有&#x3D;&#x3D;link 到共享库libhello&#x3D;&#x3D; 上。</p><h3 id="12-LINK-DIRECTORIES"><a href="#12-LINK-DIRECTORIES" class="headerlink" title="12. LINK_DIRECTORIES"></a>12. LINK_DIRECTORIES</h3><blockquote><p>LINK_DIRECTORIES(directory1 directory2 …)</p></blockquote><p>​&#x3D;&#x3D;添加&#x3D;&#x3D;非标准的&#x3D;&#x3D;共享库搜索路径&#x3D;&#x3D;，比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。</p><h3 id="13-TARGET-LINK-LIBRARIES"><a href="#13-TARGET-LINK-LIBRARIES" class="headerlink" title="13. TARGET_LINK_LIBRARIES"></a>13. TARGET_LINK_LIBRARIES</h3><blockquote><p>TARGET_LINK_LIBRARIES(target library1 &lt;debug | optimized&gt; library2 …)</p></blockquote><p>​为 target  &#x3D;&#x3D;添加需要链接的共享库&#x3D;&#x3D;。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello)</span><br><span class="line"><span class="comment">#或者 链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello.dylib)</span><br><span class="line"><span class="comment">#或者 链接静态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello.a)</span><br></pre></td></tr></table></figure><h3 id="14-install-name-tool"><a href="#14-install-name-tool" class="headerlink" title="14. install_name_tool"></a>14. install_name_tool</h3><blockquote><p>链接动态库时，可能会找不到路径，使用install_name_tool 添加路径即可</p></blockquote><p>​install_name_tool 是 macOS 系统上用来修改 Mach-O 二进制文件（包括可执行文件、动态库(dylib)和捆绑包(bundle)）内部的动态链接信息的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change old_path new_path binary</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change libhello.1.dylib @executable_path/../../lib/libhello.1.dylib ./bin/main</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/112da3b94fbb6c6e98679.png" alt="image-20240217225920116" style="zoom:50%;" /><h3 id="15-FIND"><a href="#15-FIND" class="headerlink" title="15. FIND_"></a>15. FIND_</h3><blockquote><p>FIND_FILE(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表找到的&#x3D;&#x3D;文件全路径&#x3D;&#x3D;，包含文件名。</p><blockquote><p>FIND_LIBRARY(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量表示找到的&#x3D;&#x3D;库全路径&#x3D;&#x3D;，包含库文件名</p><blockquote><p>FIND_PATH(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表&#x3D;&#x3D;包含这个文件的路径&#x3D;&#x3D;。</p><blockquote><p>FIND_PROGRAM(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表&#x3D;&#x3D;包含这个程序的全路径&#x3D;&#x3D;。</p><blockquote><p>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets…]])</p></blockquote><p>​用来调用预定义在CMAKE_MODULE_PATH 下的Find<name>.cmake 模块，你也可以自己定义Find<name>模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用。</p><blockquote alt="info"><p>FIND_指令示例</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_LIBRARY</span>(libX X11 /usr/lib)</span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">NOT</span> libX)</span><br><span class="line"><span class="keyword">MESSAGE</span>(FATAL_ERROR “libX <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> libX)</span><br></pre></td></tr></table></figure><h3 id="16-IF指令"><a href="#16-IF指令" class="headerlink" title="16.IF指令"></a>16.IF指令</h3><blockquote><p>IF 、ELSE 、ELSEIF 、ENDIF </p></blockquote><p>​出现IF 的地方一定要有&#x3D;&#x3D;对应的ENDIF&#x3D;&#x3D;。出现 ELSEIF 的地方，&#x3D;&#x3D;ENDIF 是可选&#x3D;&#x3D;的。ENDIF、ELSE中内容与IF中内容一致。</p><blockquote alt="info"><p>IF ELSE 用法，注意容易产生歧义</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS “This is windows.”)<span class="comment">#作一些Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ELSE</span>(WIN32)<span class="comment">#容易歧义</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS “This is <span class="keyword">not</span> windows”)<span class="comment">#作一些非Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>使用 CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="keyword">ELSE</span>()</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>使用 ELSEIF</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="comment">#do something related to WIN32</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(UNIX)</span><br><span class="line"><span class="comment">#do something related to UNIX</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(APPLE)</span><br><span class="line"><span class="comment">#do something related to APPLE</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure><blockquote><p>常见 IF 表达式</p></blockquote><table><thead><tr><th>IF表达式</th><th>作用</th></tr></thead><tbody><tr><td>IF(var)</td><td>表达式为&#x3D;&#x3D;真&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;NOT&#x3D;&#x3D; var )</td><td>表达式为&#x3D;&#x3D;假&#x3D;&#x3D;</td></tr><tr><td>IF(var1 &#x3D;&#x3D;AND&#x3D;&#x3D; var2)</td><td>两个变量&#x3D;&#x3D;都为真&#x3D;&#x3D;</td></tr><tr><td>IF(var1 &#x3D;&#x3D;OR&#x3D;&#x3D; var2)</td><td>两个变量&#x3D;&#x3D;其中一个为真&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;COMMAND&#x3D;&#x3D; cmd)</td><td>给定的 cmd 确实&#x3D;&#x3D;是命令并可以调用&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;EXISTS&#x3D;&#x3D; dir)、IF(&#x3D;&#x3D;EXISTS&#x3D;&#x3D; file)</td><td>当目录名或者文件名&#x3D;&#x3D;存在&#x3D;&#x3D;</td></tr><tr><td>IF(file1 &#x3D;&#x3D;IS_NEWER_THAN&#x3D;&#x3D; file2)</td><td>当file1 比file2 &#x3D;&#x3D;新&#x3D;&#x3D;，<br />file1&#x2F;file2 其中有&#x3D;&#x3D;一个不存在&#x3D;&#x3D;<br/>文件名请使用完整路径。</td></tr><tr><td>IF(&#x3D;&#x3D;IS_DIRECTORY&#x3D;&#x3D; dirname)</td><td>dirname &#x3D;&#x3D;是目录&#x3D;&#x3D;</td></tr><tr><td>IF(variable &#x3D;&#x3D;MATCHES&#x3D;&#x3D; regex)、IF(string &#x3D;&#x3D;MATCHES&#x3D;&#x3D; regex)</td><td>给定的变量或者字符串&#x3D;&#x3D;能够匹配正则表达式&#x3D;&#x3D; regex</td></tr><tr><td>IF(variable &#x3D;&#x3D;LESS&#x3D;&#x3D; number)<br />IF(variable &#x3D;&#x3D;GREATER&#x3D;&#x3D; number)<br/>IF(string &#x3D;&#x3D;EQUAL&#x3D;&#x3D; number)</td><td>&#x3D;&#x3D;数字比较大小&#x3D;&#x3D;</td></tr><tr><td>IF(variable &#x3D;&#x3D;STRLESS&#x3D;&#x3D; string)<br />IF(string &#x3D;&#x3D;STRGREATER&#x3D;&#x3D; string)<br/>IF(string &#x3D;&#x3D;STREQUAL&#x3D;&#x3D; string)</td><td>&#x3D;&#x3D;字母序比较大小&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;DEFINED&#x3D;&#x3D; variable)</td><td>变量&#x3D;&#x3D;被定义&#x3D;&#x3D;</td></tr></tbody></table><h3 id="17-循环指令"><a href="#17-循环指令" class="headerlink" title="17. 循环指令"></a>17. 循环指令</h3><blockquote><p>WHILE 、ENDWHILE 循环</p></blockquote><p>​WHILE(条件)、其中条件可以参考IF指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHILE</span>(condition)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENDWHILE</span>(condition)</span><br></pre></td></tr></table></figure><blockquote><p>FOREACH 、ENDFOREACH 循环</p></blockquote><blockquote alt="info"><p>遍历</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含字符串的列表</span></span><br><span class="line"><span class="keyword">SET</span>(name_list Alice Bob Charlie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历列表并打印每个元素</span></span><br><span class="line"><span class="keyword">FOREACH</span>(name IN LISTS name_list)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;Name: $&#123;name&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>()</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>范围</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从 0 到 total 以１为步进</span></span><br><span class="line"><span class="keyword">FOREACH</span>(VAR RANGE total)</span><br><span class="line"><span class="keyword">MESSAGE</span>(<span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#使用$&#123;&#125;引用变量</span></span><br><span class="line"><span class="keyword">ENDFOREACH</span>(VAR)</span><br><span class="line"><span class="comment">#语法格式</span></span><br><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE start stop [step])</span><br><span class="line"><span class="comment">#从 start 开始到stop 结束，以step 为步进，</span></span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><h3 id="18-常用变量"><a href="#18-常用变量" class="headerlink" title="18. 常用变量"></a>18. 常用变量</h3><blockquote><p>CMAKE_BINARY_DIR 、PROJECT_BINARY_DIR 、&lt;项目名&gt;_BINARY_DIR</p></blockquote><p>​&#x3D;&#x3D;工程编译&#x3D;&#x3D;的目录。</p><blockquote><p>CMAKE_SOURCE_DIR 、PROJECT_SOURCE_DIR 、 &lt;项目名&gt;_SOURCE_DIR</p></blockquote><p>​&#x3D;&#x3D;工程顶层&#x3D;&#x3D;目录</p><blockquote><p>CMAKE_CURRENT_SOURCE_DIR</p></blockquote><p>​当前处理的&#x3D;&#x3D;CMakeLists.txt&#x3D;&#x3D;所在的路径</p><blockquote><p>CMAKE_BUILD_TYPE</p></blockquote><p>​CMake 中用来指定&#x3D;&#x3D;构建类型&#x3D;&#x3D;的变量，cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ..</p><blockquote><p>CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG</p></blockquote><p>​cmake -DCMAKE_BUILD_TYPE&#x3D;Debug .. 的&#x3D;&#x3D;编译路径&#x3D;&#x3D;</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Debug)</span><br></pre></td></tr></table></figure><blockquote><p>CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE</p></blockquote><p>​cmake -DCMAKE_BUILD_TYPE&#x3D;Release .. 的&#x3D;&#x3D;编译路径&#x3D;&#x3D;</p><blockquote><p>CMAKE_INSTALL_PREFIX</p></blockquote><p>​指定在运行  make install 或类似安装命令时，&#x3D;&#x3D;项目安装的根目录&#x3D;&#x3D;</p><blockquote><p>CMAKE_CURRRENT_BINARY_DIR</p></blockquote><p>​&#x3D;&#x3D;target 编译&#x3D;&#x3D;目录，ADD_SUBDIRECTORY(src bin) 可以更改这个变量的值</p><blockquote><p>EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH</p></blockquote><p>​重新定义&#x3D;&#x3D;最终结果的存放目录&#x3D;&#x3D;。</p><blockquote><p>PROJECT_NAME</p></blockquote><p>​返回通过PROJECT 指令定义的&#x3D;&#x3D;项目名称&#x3D;&#x3D;。</p><blockquote><p>CMAKE_CURRENT_LIST_FILE</p></blockquote><p>​输出&#x3D;&#x3D;调用这个变量&#x3D;&#x3D;的CMakeLists.txt 的完整路径</p><blockquote><p>CMAKE_CURRENT_LIST_LINE</p></blockquote><p>​输出这个&#x3D;&#x3D;变量所在的行&#x3D;&#x3D;</p><blockquote><p>CMAKE_MODULE_PATH</p></blockquote><p>​定义&#x3D;&#x3D;自己的cmake 模块所在的路径&#x3D;&#x3D;，为了让cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过SET 指令，将自己的cmake 模块路径设置一下。</p><p>​SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}&#x2F;cmake) 这时候你就可以通过INCLUDE 指令来调用自己的模块了。</p><h3 id="19-基础语法"><a href="#19-基础语法" class="headerlink" title="19. 基础语法"></a>19. 基础语法</h3><blockquote><p>变量使用&#x3D;&#x3D;${}&#x3D;&#x3D;方式取值，但是在IF 控制语句中是直接使用变量名。</p></blockquote><blockquote><p>指令(参数1 参数 2…)，参数之间使用&#x3D;&#x3D;空格&#x3D;&#x3D;或&#x3D;&#x3D;分号&#x3D;&#x3D;分开。</p></blockquote><p>​<code> ADD_EXECUTABLE(hello main.c func.c)</code> 或者 <code>ADD_EXECUTABLE(hello main.c;func.c)</code></p><blockquote><p>指令是大小写&#x3D;&#x3D;无关&#x3D;&#x3D;的，参数和变量是大小写&#x3D;&#x3D;相关&#x3D;&#x3D;的。&#x3D;&#x3D;推荐全部使用大写指令&#x3D;&#x3D;。</p></blockquote><blockquote><p>源文件的文件名是中间&#x3D;&#x3D;包含了空格&#x3D;&#x3D;，这时候必须使用&#x3D;&#x3D;双引号&#x3D;&#x3D;。</p></blockquote><p>​<code>SET(SRC_LIST fu nc.c</code> 报错找不到fu和nc.c文件，必须写成 <code>SET(SRC_LIST &quot;fu nc.c&quot;)</code>。</p><blockquote><p>可以&#x3D;&#x3D;忽略&#x3D;&#x3D;掉source 列表中的&#x3D;&#x3D;源文件后缀&#x3D;&#x3D;</p></blockquote><p>​<code>ADD_EXECUTABLE(t1 main)</code>，cmake 会自动的在本目录查找main.c 或者main.cpp等，当然，最好不要偷这个懒，以免这个目录确实存在一个 main.c 一个main。</p><blockquote><p>调用环境变量</p></blockquote><p>​$ENV{NAME} 指令可以调用系统的环境变量。<code>MESSAGE(STATUS “HOME dir: $ENV&#123;HOME&#125;”)</code></p><blockquote><p>设置环境变量值</p></blockquote><p>​SET(ENV{变量名} 值) </p><p><a href="https://www.yuque.com/linuxer/xngi03/cs5y85">参考文章：CMake 零声参考资料</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/qh9lve">参考文章：CMake 零声实战</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="1-makefile规则"><a href="#1-makefile规则" class="headerlink" title="1. makefile规则"></a>1. makefile规则</h2><blockquote><p>​Makefile最重要的二个概念一个是目标（target），另一个就是依赖（dependency）。目标就是指要干什么，或说运行 make 后生成什么，而依赖是告诉 make 如何去做以实现目标。</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5318bd66f24eaeab0381a.png" alt="image.png" style="zoom:60%;" /><img src="https://telegraph-image-9wl.pages.dev/file/3b17e9c52415e9e5144d2.png" alt="image.png" style="zoom:70%;" /><blockquote><p>&#x3D;&#x3D;make -v&#x3D;&#x3D; 命令查看环境。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make -v</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">GNU Make <span class="number">3.81</span></span><br><span class="line"><span class="built_in">Copyright</span> (C) <span class="number">2006</span>  Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source <span class="keyword">for</span> copying conditions.</span><br><span class="line">There is NO warranty; <span class="keyword">not</span> even <span class="keyword">for</span> MERCHANTABILITY <span class="keyword">or</span> FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">This program built <span class="keyword">for</span> i386-apple-darwin11<span class="number">.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><blockquote><p>打印 hello world，echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    "echo"时bash shell命令,"echo"前面必须加"tab"。    </p></blockquote><blockquote><p>不打印命令代码，@echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote><p>makefile的&#x3D;&#x3D;目标和依赖&#x3D;&#x3D;，all:test</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:test</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">test:</span><br><span class="line">@echo <span class="string">&quot;Just for test&quot;</span></span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make</span><br><span class="line">Just <span class="keyword">for</span> test</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make test</span><br><span class="line">Just <span class="keyword">for</span> test</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    ":"前的"all"是目标，":"后的"test"是依赖（先决条件），makefile会先按从左到右顺序执行依赖，最后执行目标。    </p></blockquote><blockquote alt="info"><p>    "make"命令后不跟任何目标时，优先执行第一个目标。    </p></blockquote><blockquote alt="warn"><p style="color:red;">一个规则是由目标（targets）、先决条件（prerequisites）以及命令（commands）所组成的。    </p></blockquote><p><a href="https://www.yuque.com/linuxer/xngi03/nfsm1k">参考文章：Makefile 零声参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B+ 树的作用</p></blockquote><ol><li>B+树的内层节点做索引，只有叶子节点存储。</li></ol><blockquote><p>B+ 树的用途</p></blockquote><ol><li>MySQL 的数据存储。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B树的作用</p></blockquote><ol><li>二叉树的层数太高，B树可减少层高</li><li>B树内节点和叶子节点都可存储数据</li></ol><blockquote><p>B树的用途</p></blockquote><ol><li>磁盘数据查找（每个层高查找一次磁盘）</li></ol><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>一颗M阶B树T，满足以下条件</p></blockquote><ol><li>每个结点至多拥有M颗子树</li><li>根结点至少拥有两颗子树</li><li>除了根结点以外，其余每个分支结点至少拥有M&#x2F;2课子树</li><li>所有的叶结点都在同一层上</li><li>有k课子树的分支结点则存在K-1个关键字，关键字按照递增顺序进行排</li><li>关键字数量满足 <code>ceil(M/2) - 1＜ = n ＜ = M - 1</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSTree::Node* &amp;node和BSTree::Node &amp;node 区别</title>
      <link href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/"/>
      <url>/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>写二叉查找树&#x3D;&#x3D;递归插入&#x3D;&#x3D;代码时，参数用&#x3D;&#x3D;Node* &amp;node&#x3D;&#x3D; 和&#x3D;&#x3D;Node &amp;node&#x3D;&#x3D;有着明显的不同。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><blockquote alt="info"> <p>    Node &node这是一个对对象的引用，使用这种方式，函数可以修改通过<strong style="color:red;">引用传递的对象的内容</strong>，但不能改变调用者中<strong style="color:red;">对象的地址</strong>。    </p></blockquote><blockquote alt="info"> <p>    Node* &node这是一个对指针的引用，使用这种方式，函数能够直接修改<strong style="color:red;">传入的指针本身</strong>。    </p></blockquote># 3. 代码<blockquote><p>下面是二叉搜索树实现递归插入节点。</p></blockquote><h2 id="1-Node-node作为参数"><a href="#1-Node-node作为参数" class="headerlink" title="1. Node &amp;node作为参数"></a>1. Node &amp;node作为参数</h2><blockquote><p>Node &amp;node 作为参数，此时节点为空时不能直接 new，必须通过父节点的左右子树new，否则会丢失。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Node-node作为参数"><a href="#2-Node-node作为参数" class="headerlink" title="2. Node* &amp;node作为参数"></a>2. Node* &amp;node作为参数</h2><blockquote><p>Node* &amp;node 作为参数，节点空时可以直接 new，新节点会自动连接到树上。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h2><h3 id="1-main-cpp"><a href="#1-main-cpp" class="headerlink" title="1. main.cpp"></a>1. main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t.<span class="built_in">insertNodeR</span>(<span class="number">10</span>);</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-bstree-h"><a href="#2-bstree-h" class="headerlink" title="2. bstree.h"></a>2. bstree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey,newValue</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> key; <span class="comment">// 释放键资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bstree_node&lt;K_TYPE&gt; Node;</span><br><span class="line">    Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _inOrder(Node* node);<span class="comment">//inOrder() 递归部分</span></span><br><span class="line">    <span class="type">bool</span> _insertR(Node* node,<span class="type">const</span> K_TYPE &amp;key);<span class="comment">//inserNodeR()递归部分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNode</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNodeR</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点----递归</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历节点----递归</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_root == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. 根节点空直接插入</span></span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span> (key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//2. 递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, const K_TYPE &amp;key) &#123;</span></span><br><span class="line"><span class="comment">//    if(node == nullptr)&#123;//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line"><span class="comment">//        node = new Node(key);</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    //2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line"><span class="comment">//    if (node-&gt;key &lt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;right,key);</span></span><br><span class="line"><span class="comment">//    &#125; else if (node-&gt;key &gt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;left,key);</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版template &lt;class T&gt; 和 template &lt;typename T&gt; 区别</title>
      <link href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>学习二叉查找树时，有的使用 template <class T>，有的使用 template <typename T> 。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><h2 id="1-C-标准中"><a href="#1-C-标准中" class="headerlink" title="1. C++标准中"></a>1. C++标准中</h2><blockquote alt="info"> <p>    template &lt;typename T&gt; 用于<strong style="color:red;">基础数据类型</strong>， T可以是int char 等    </p></blockquote><blockquote alt="info"> <p>    template &lt;class T&gt; 用于<strong style="color:red;">复杂数据类型</strong>， T可以是string，类 等    </p></blockquote><h2 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h2><blockquote><p>大部分情况，typename和class等价。</p></blockquote><blockquote><p>在C++早期版本中，没有 typename 这个关键字，所以在模板定义的时候便使用了 class。</p></blockquote><p><a href="https://blog.csdn.net/qq_20853741/article/details/125879893">参考文章：模板 template＜typename T＞ 和 template＜class T＞区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树基础 ----&gt; 二叉查找树</title>
      <link href="/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>用于二分查找</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>按照<font title="red">中序排列</font>的二叉树</p></blockquote><ol><li>其左子树下的每个后代节点的值都小于节点n的值。</li><li>其右子树下的每个后代节点的值都大于节点n的值。</li><li>左右子树也均为二叉查找树。</li></ol><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3. 类型"></a>3. 类型</h2><h3 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h3><img src="https://telegraph-image-9wl.pages.dev/file/02d58a1def424af138470.png" alt="图2" style="zoom:125%;" /><blockquote><p>所有的结点都只有左子树的二叉树叫<font title="red">左斜树</font>。</p></blockquote><blockquote><p>所有结点都是只有右子树的二叉树叫<font title="red">右斜树</font>。</p></blockquote><blockquote alt="info"><p>左斜树和右斜树统称为<font title="red">斜树</font>。</p></blockquote><h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><blockquote><ol><li>所有分支结点都存在左子树和右子树。</li><li>所有叶子节点（即没有子节点的节点）都在同一层上。</li></ol></blockquote><blockquote alt="info">    <p>        1. 叶子节点只能出现在最下一层。出现在其它层就不可能达成平衡。    </p>    <p>    2. 非叶子结点的度（结点拥有的子树数目称为结点的度）一定是2。    </p>    <p>    3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。     </p></blockquote><h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/a6db59cb75a2d03165d5b.png" alt="图4" style="zoom:125%;" /><blockquote><p>​一颗具有n个结点的二叉树按层编号（按从上至下、从左到右的顺序进行编号），编号为i(1&lt;&#x3D;i&lt;&#x3D;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。<font title="red">完全二叉树是满二叉树的子集。</font></p></blockquote><blockquote alt="info">    <p>    1.叶子结点只能出现在最下层和次下层。    </p>    <p>    2.最下层的叶子结点集中在树的左部。    </p>    <p>    3.倒数第二层若存在叶子结点，一定在右部连续位置。     </p>    <p>    4.如果结点度为1，则该结点只有左子节点，没有右子节点     </p>    <p>    5.同样结点数目的二叉树，完全二叉树深度最小。     </p></blockquote><blockquote alt="danger">    <p>     满二叉树一定是完全二叉树，但反过来不一定成立。    </p></blockquote>## 4. 代码实现### 1. 二叉树节点定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树框架"><a href="#2-二叉树框架" class="headerlink" title="2. 二叉树框架"></a>2. 二叉树框架</h3><h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h3><blockquote><p>普通插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4. 中序遍历"></a>4. 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-查找"><a href="#5-查找" class="headerlink" title="5. 查找"></a>5. 查找</h3><blockquote><p>普通查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点为key</span></span><br><span class="line">    <span class="keyword">if</span>(key == _root-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历二叉树，查找</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//此时cur-&gt;key == key</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">return</span> _findR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_findR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//2.递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key &gt; key)&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-删除"><a href="#6-删除" class="headerlink" title="6. 删除"></a>6. 删除</h3><blockquote><p>普通删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待删除节点值</span></span><br><span class="line"><span class="comment">*返回值：true 成功删除，false 未找到节点，删除失败</span></span><br><span class="line"><span class="comment">*功能：删除key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">deleteNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点不为空，遍历找到带删除节点位置</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//3.单独讨论只有根节点情况</span></span><br><span class="line">    <span class="keyword">if</span>(_root-&gt;key == key &amp;&amp; _root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历树</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//4.找到删除节点位置，分情况删除节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">                <span class="comment">//1. 左子树、右子树都为空时，叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;left == cur)&#123;</span><br><span class="line">                    parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//2.左子树为空，右子树不为空</span></span><br><span class="line">                <span class="comment">//或者. 左子树、右子树都不为空时</span></span><br><span class="line">                Node* cur_left = cur-&gt;right;</span><br><span class="line">                Node* parent_left = cur;</span><br><span class="line">                <span class="comment">//遍历找到右子树中最小值</span></span><br><span class="line">                <span class="keyword">while</span> (cur_left &amp;&amp; cur_left-&gt;left) &#123;</span><br><span class="line">                    parent_left = cur_left;</span><br><span class="line">                    cur_left = cur_left-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                    <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;right;</span><br><span class="line">                    <span class="comment">//左子树、右子树都不为空时</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                        _root-&gt;left = cur-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_left-&gt;key;</span><br><span class="line">                    parent_left-&gt;right = cur_left-&gt;right;</span><br><span class="line">                    <span class="keyword">delete</span> cur_left;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//3.右子树为空，左子树不为空</span></span><br><span class="line">                Node* cur_right = cur-&gt;left;</span><br><span class="line">                Node* parent_right = cur;</span><br><span class="line">                <span class="comment">//遍历找到左子树中最大值</span></span><br><span class="line">                <span class="keyword">while</span>(cur_right &amp;&amp; cur_right-&gt;right)&#123;</span><br><span class="line">                    parent_right = cur_right;</span><br><span class="line">                    cur_right = cur_right-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                      <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;left;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_right-&gt;key;</span><br><span class="line">                    parent_right-&gt;left = cur_right-&gt;left;</span><br><span class="line">                    <span class="keyword">delete</span> cur_right;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归删除</p></blockquote><p>​在遍历树找到删除元素时采用递归的方式。</p><h3 id="7-深拷贝"><a href="#7-深拷贝" class="headerlink" title="7. 深拷贝"></a>7. 深拷贝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BSTree</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K_TYPE&gt;&amp; t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_root = <span class="built_in">copyTree</span>(t._root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：复制树的根节点</span></span><br><span class="line"><span class="comment">*返回值：true 成功复制，false 复制失败</span></span><br><span class="line"><span class="comment">*功能：复制另一个树，返回另一个树的头节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line">bstree_node&lt;K_TYPE&gt;* BSTree&lt;K_TYPE&gt;::<span class="built_in">copyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bstree_node&lt;K_TYPE&gt;* copyNode = <span class="keyword">new</span> <span class="built_in">bstree_node</span>&lt;K_TYPE&gt;(node-&gt;key);</span><br><span class="line">    copyNode-&gt;left = <span class="built_in">copyTree</span>(node-&gt;left);</span><br><span class="line">    copyNode-&gt;right = <span class="built_in">copyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-析构"><a href="#8-析构" class="headerlink" title="8. 析构"></a>8. 析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">destroyTree</span><span class="params">(<span class="type">const</span> Node* node)</span></span>;<span class="comment">//销毁树</span></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">BSTree</span>()&#123;</span><br><span class="line">    <span class="built_in">destroyTree</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：true 成功销毁，false 销毁失败</span></span><br><span class="line"><span class="comment">*功能：销毁一棵树</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">destroyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">78</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">    t1._root = t1.<span class="built_in">copyTree</span>(t._root);</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:a)&#123;</span><br><span class="line">        t.<span class="built_in">deleteNode</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/a2076188013/article/details/126515470">参考文章：详解二叉搜索树【C++实现】</a></p><p><a href="https://blog.csdn.net/weixin_43274704/article/details/115793265">参考文章：深度解析红黑树</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题套路</title>
      <link href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/"/>
      <url>/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h2><blockquote><p>动态规划的核心是<font title="red">穷举</font>。</p></blockquote><blockquote><p>递归算法的时间复杂度：<font title="red">子问题个数 X 一个子问题需要时间</font>。</p></blockquote><h3 id="1-总体套路"><a href="#1-总体套路" class="headerlink" title="1. 总体套路"></a>1. 总体套路</h3><blockquote alt="info"><p> 1. 明确 base case ----> 2. 明确 "状态" ----> 3. 明确 "选择" ----> 4. 定义 dp 数组 / 函数的含义</p></blockquote><blockquote alt="warn"><p> 可优化问题：<font title="red">最优子结构 、 重叠子问题</font></p></blockquote><blockquote alt="success"><p> 解决方法：<font title="red">备忘录 、 DP table</font></p></blockquote><h3 id="2-自顶向下递归"><a href="#2-自顶向下递归" class="headerlink" title="2. 自顶向下递归"></a>2. 自顶向下递归</h3><blockquote alt="danger"><p>递归套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(状态<span class="number">1</span>,状态<span class="number">2</span>,...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 选择:所有可能的选择)&#123;</span><br><span class="line"><span class="comment">//此时的状态可能因为做了选择而改变</span></span><br><span class="line">        <span class="keyword">auto</span> result = 求最值(result, <span class="built_in">dp</span>(状态<span class="number">1</span>,状态<span class="number">2</span>,...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自顶向下递归</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">memo</span>(n+<span class="number">1</span>);<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自底向上迭代"><a href="#3-自底向上迭代" class="headerlink" title="3. 自底向上迭代"></a>3. 自底向上迭代</h3><blockquote alt="danger"><p>迭代套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="comment">//初始化 base case</span></span><br><span class="line"><span class="keyword">auto</span> dp[<span class="number">0</span>][<span class="number">0</span>][...] = base_case;</span><br><span class="line"><span class="comment">//进行状态转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">1</span>:状态<span class="number">1</span>的所有取值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">2</span>:状态<span class="number">2</span>的所有取值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...<span class="comment">/*省略所有状态*/</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历所有状态，求最值</span></span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>,选择<span class="number">2.</span>..);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自底向上迭代</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2. 代码优化"></a>2. 代码优化</h2><h3 id="1-重叠子问题"><a href="#1-重叠子问题" class="headerlink" title="1. 重叠子问题"></a>1. 重叠子问题</h3><blockquote><p>递归子树中，存在大量重复分支。</p></blockquote><p>​斐波那契数列，若采用暴力递归，则会产生大量重复分支，该方法时间负责度为$O(2^n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列暴力递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/b8be642671ddeb0b8a004.jpg" style="zoom:50%"><p>​上图为暴力递归的&#x3D;&#x3D;递归树&#x3D;&#x3D;，可以发现，存在&#x3D;&#x3D;大量重复分支&#x3D;&#x3D;，使用&#x3D;&#x3D;备忘录&#x3D;&#x3D;可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> memo[n+<span class="number">1</span>];<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/2.jpg" style="zoom:50%;"><p>​上图为&#x3D;&#x3D;带备忘录递归&#x3D;&#x3D;的递归树，少了许多重复分支的计算，同样使用&#x3D;&#x3D;DP table&#x3D;&#x3D;也能解决这个问题。</p><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/4.jpg" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-优化DP-table-空间"><a href="#2-优化DP-table-空间" class="headerlink" title="2. 优化DP table 空间"></a>2. 优化DP table 空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 空间负责度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​     上述代码空间负责度$O(n)$，实际上很多空间都是冗余的，只需要dp[i-1]和dp[i-2]即可，优化后空间负责度$O(1)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 优化后，空间负责度O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp_i_1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp_i_2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> dp = dp_i_1 + dp_i_2;</span><br><span class="line">        dp_i_1 = dp_i_2;</span><br><span class="line">        dp_i_2 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br></pre></td></tr></table></figure><h2 id="3-应用—-凑硬币"><a href="#3-应用—-凑硬币" class="headerlink" title="3. 应用—-凑硬币"></a>3. 应用—-凑硬币</h2><blockquote><p>​给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p></blockquote><h3 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. 总体思路</h3><ol><li>&#x3D;&#x3D;base case&#x3D;&#x3D;  当总金额 amount &lt; 0 时，返回 -1，amount &#x3D;&#x3D; 0时，返回 0 。</li><li>&#x3D;&#x3D;明确状态&#x3D;&#x3D; amount 大小发生变化。</li><li>&#x3D;&#x3D;明确选择&#x3D;&#x3D; 选择硬币。</li><li>&#x3D;&#x3D;明确 dp 函数&#x2F;数组的定义&#x3D;&#x3D; dp输入金额n和数组coins，返回所需最少的硬币个数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> subres = <span class="built_in">coinChange</span>(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span>(subres == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//subres + 1 表示子树最少硬币数+当前硬币</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, subres+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==INT_MAX?<span class="number">-1</span>:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-备忘录优化-—-递归案例"><a href="#2-备忘录优化-—-递归案例" class="headerlink" title="2. 备忘录优化 —- 递归案例"></a>2. 备忘录优化 —- 递归案例</h3><blockquote><p>使用memo，记录 memo[amount] &#x3D; 硬币数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义memo</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化memo，INT_MAX表示memo中没有记录</span></span><br><span class="line">        memo = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case </span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="comment">//备忘录使用</span></span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> subres = <span class="built_in">dp</span>(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (subres == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">min</span>(result, subres + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = result == INT_MAX ? <span class="number">-1</span> : result;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-DP-table-迭代-—-迭代案例"><a href="#3-DP-table-迭代-—-迭代案例" class="headerlink" title="3. DP table 迭代 —- 迭代案例"></a>3. DP table 迭代 —- 迭代案例</h3><blockquote><p>dp 数组的定义：当目标金额为 i  时，至少需要  dp[i] 枚硬币凑出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins)&#123;</span><br><span class="line">            <span class="comment">//coin &gt; i ，硬币 &gt; 总金额，不能凑</span></span><br><span class="line">            <span class="keyword">if</span>(coin&gt;i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转移</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == (amount+<span class="number">1</span>)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/6.jpg" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> labuladong的算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong的算法笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>红黑树的用途：</p></blockquote><ol><li>Key–Value 查找。</li><li>顺序。</li></ol><blockquote><p>强查找时所用数据结构：</p></blockquote><ul><li><p>rbtree</p></li><li><p>hash</p></li><li><p>b&#x2F;b+ tree</p></li><li><p>跳表</p></li></ul><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的</li><li>对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点</li></ol><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="1-红黑树定义"><a href="#1-红黑树定义" class="headerlink" title="1. 红黑树定义"></a>1. 红黑树定义</h3><blockquote><p>节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    KEY_TYPE *key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *parent;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//红黑树颜色</span></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote><p>头节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *nil;<span class="comment">//红黑树都指向一个黑色的叶子节点</span></span><br><span class="line">&#125;rbtree;</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>节点存在问题--------无法复用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义 红黑树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name, type) \</span></span><br><span class="line"><span class="meta">struct name&#123;\</span></span><br><span class="line"><span class="meta">        struct type *left;\</span></span><br><span class="line"><span class="meta">        struct type *right;\</span></span><br><span class="line"><span class="meta">        struct type *parent;\</span></span><br><span class="line"><span class="meta">    unsigned char color;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) node;<span class="comment">//第一个参数为空，表示未命名数据结构</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote alt="success"><p>线程复用<br>一个线程有多个状态：ready、wait、sleep和exit。这些状态都用红黑树实现，因此一个线程需要定义多棵红黑树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) ready;<span class="comment">//上面宏定义的红黑树结构</span></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) wait;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) sleep;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h3><blockquote><p>红黑树性质被破坏时（插入新值），进行旋转。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/d61ddf9e7566966d5ac0f.png" style="zoom:50%"><blockquote alt="info"><p>当前的结点是右子树，<font title="red">左旋</font></p></blockquote><p>​node 与父节点交换位置，node 的左子树为父节点，右子树不变。原父节点的左子树不变，右子树为node的左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="comment">//参数：头节点、左旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T-&gt;nil)&#123;<span class="comment">//叶子节点不能左旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *y = x-&gt;right;</span><br><span class="line">    <span class="comment">//交换x的右边和y的左边</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != T-&gt;nil)&#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>当前的结点是左子树，<font title="red">右旋</font></p></blockquote><p>​node 与父节点交换位置，node 的右子树为父节点，左子树不变。原父节点的右子树不变，左子树为node的右子树。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="comment">//参数：头节点、右旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T,rbtree_node *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;<span class="comment">//叶子节点不能右旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">    <span class="comment">//交换y的左边和x的右边</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right != T-&gt;nil)&#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;right)&#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-红黑树的插入"><a href="#3-红黑树的插入" class="headerlink" title="3. 红黑树的插入"></a>3. 红黑树的插入</h3><blockquote><p>插入节点始终红色，根据红黑树性质（判断父亲是否为红色）调整。</p></blockquote><blockquote alt="warn"><p>难点：红色树变色</p></blockquote><blockquote alt="info"><p>    父结点是祖父结点的左子树的情况和右子树情况<font title="red">对称</font>。下面只讨论左子树的三种情况    </p></blockquote><blockquote alt="success"><p>    1. 叔结点是红色的</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ed316a0b512e2382f0b88.png" style="zoom:50%;"><blockquote alt="success"><p>2.叔结点是黑色的，而且当前结点是<font title="red">右孩子</font>。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/9bccd3f7205a1603ac0c8.png" style="zoom:50%;"><blockquote alt="success"><p >3.叔结点是黑色的，而且当前结点是<font title="red">左孩子</font>。   </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/37934bf2d30f32e280afe.png" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="comment">//红黑树插入节点</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;<span class="comment">//从根节点遍历</span></span><br><span class="line">    <span class="comment">//遍历到应该插入z的位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != T-&gt;nil)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//z-&gt;key == x-&gt;key情况，根据业务变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将z插入到红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key )&#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="comment">//z节点染红色</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    <span class="comment">//调整红黑树颜色</span></span><br><span class="line">    <span class="built_in">rbtree_insert_fixup</span>(T,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树颜色调整</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;parent-&gt;color != RED)&#123;<span class="comment">//z节点始终为红色</span></span><br><span class="line">        <span class="comment">//z插入在祖父的左子树时</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;right-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_left_rotate</span>(T,p);<span class="comment">//左旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_right_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//z插入在祖父的右子树时</span></span><br><span class="line">             rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;left-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_right_rotate</span>(T,p);<span class="comment">//右旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_left_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 邮件 icon 点击 404</title>
      <link href="/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/"/>
      <url>/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>​在主页面中，点击 icon 的邮件后报错 404 。</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/1a47e264cd5492892b9d5.png" style="zoom:50%;"><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​_config.yml 文件中添加&#x3D;&#x3D;mailto:example:email.com&#x3D;&#x3D;。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/e5eafe32fdf1d570f74cd.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上iCloud下载慢</title>
      <link href="/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>​Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。</p></blockquote><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
