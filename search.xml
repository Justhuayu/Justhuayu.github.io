<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树与红黑树</title>
      <link href="/2024/01/27/C-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2024/01/27/C-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>红黑树的用途：</p></blockquote><ol><li>Key–Value 查找。</li><li>顺序。</li></ol><blockquote><p>强查找时所用数据结构：</p></blockquote><ul><li><p>rbtree</p></li><li><p>hash</p></li><li><p>b&#x2F;b+ tree</p></li><li><p>跳表</p></li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的</li><li>对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h3><blockquote><p>节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *parent;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//红黑树颜色</span></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote><p>头节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *nil;<span class="comment">//红黑树都指向一个黑色的叶子节点</span></span><br><span class="line">&#125;rbtree;</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>节点存在问题--------无法复用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义 红黑树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name, type) \</span></span><br><span class="line"><span class="meta">struct name&#123;\</span></span><br><span class="line"><span class="meta">        struct type *left;\</span></span><br><span class="line"><span class="meta">        struct type *right;\</span></span><br><span class="line"><span class="meta">        struct type *parent;\</span></span><br><span class="line"><span class="meta">    unsigned char color;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) node;<span class="comment">//第一个参数为空，表示未命名数据结构</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote alt="success"><p>线程复用<br>一个线程有多个状态：ready、wait、sleep和exit。这些状态都用红黑树实现，因此一个线程需要定义多棵红黑树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) ready;<span class="comment">//上面宏定义的红黑树结构</span></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) wait;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) sleep;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h3><blockquote><p>红黑树性质被破坏时（插入新值），进行旋转。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/d61ddf9e7566966d5ac0f.png" style="zoom:50%"><blockquote alt="info"><p>当前的结点是右子树，<strong style="color:red;">左旋</strong></p></blockquote><p>​node 与父节点交换位置，node 的左子树为父节点，右子树不变。原父节点的左子树不变，右子树为node的左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="comment">//参数：头节点、左旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T-&gt;nil)&#123;<span class="comment">//叶子节点不能左旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *y = x-&gt;right;</span><br><span class="line">    <span class="comment">//交换x的右边和y的左边</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != T-&gt;nil)&#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>当前的结点是左子树，<strong style="color:red;">右旋</strong></p></blockquote><p>​node 与父节点交换位置，node 的右子树为父节点，左子树不变。原父节点的右子树不变，左子树为node的右子树。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="comment">//参数：头节点、右旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T,rbtree_node *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;<span class="comment">//叶子节点不能右旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">    <span class="comment">//交换y的左边和x的右边</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right != T-&gt;nil)&#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;right)&#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><blockquote><p>插入节点始终红色，根据红黑树性质（判断父亲是否为红色）调整。</p></blockquote><blockquote alt="warn"><p>难点：红色树变色</p></blockquote><blockquote alt="info"><p>    父结点是祖父结点的左子树的情况和右子树情况<strong style="color:red;">对称</strong>。下面只讨论左子树的三种情况    </p></blockquote><blockquote alt="success"><p style="color:red;">    1. 叔结点是红色的</p><p><img src="https://telegraph-image-9wl.pages.dev/file/ed316a0b512e2382f0b88.png" style="zoom:40%;"></p></blockquote><blockquote alt="success"><p>2.叔结点是黑色的，而且当前结点是<strong style="color:red;">右孩子</strong>。    </p><p><img src="https://telegraph-image-9wl.pages.dev/file/9bccd3f7205a1603ac0c8.png" style="zoom:40%;"></p></blockquote><blockquote alt="success"><p >3.叔结点是黑色的，而且当前结点是<strong style="color:red;">左孩子</strong>。   </p><p><img src="https://telegraph-image-9wl.pages.dev/file/37934bf2d30f32e280afe.png" style="zoom:40%;"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="comment">//红黑树插入节点</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;<span class="comment">//从根节点遍历</span></span><br><span class="line">    <span class="comment">//遍历到应该插入z的位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != T-&gt;nil)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//z-&gt;key == x-&gt;key情况，根据业务变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将z插入到红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key )&#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="comment">//z节点染红色</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    <span class="comment">//调整红黑树颜色</span></span><br><span class="line">    <span class="built_in">rbtree_insert_fixup</span>(T,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树颜色调整</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;parent-&gt;color != RED)&#123;<span class="comment">//z节点始终为红色</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)&#123;<span class="comment">//z插入在祖父的左子树时</span></span><br><span class="line">            rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;right-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_left_rotate</span>(T,p);<span class="comment">//左旋</span></span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_right_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//z插入在祖父的右子树时</span></span><br><span class="line">             rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;left-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_right_rotate</span>(T,p);<span class="comment">//右旋</span></span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_left_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 邮件 icon 点击 404</title>
      <link href="/2024/01/26/Bug-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/"/>
      <url>/2024/01/26/Bug-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-主题-icon-点击后404"><a href="#Hexo-主题-icon-点击后404" class="headerlink" title="Hexo 主题 icon 点击后404"></a>Hexo 主题 icon 点击后404</h1><p>​在主页面中，点击 icon 的邮件后报错 404 。</p><p>#@Q#</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>​_config.yml 文件中添加  <code> mailto:example:email.com</code>。</p><img src = "https://telegraph-image-9wl.pages.dev/file/e5eafe32fdf1d570f74cd.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上iCloud下载慢</title>
      <link href="/2024/01/26/Bug-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2024/01/26/Bug-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-上-iCloud-下载慢"><a href="#Mac-上-iCloud-下载慢" class="headerlink" title="Mac 上 iCloud 下载慢"></a>Mac 上 iCloud 下载慢</h1><p>​Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>​设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构</title>
      <link href="/2024/01/21/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/21/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>​数据页大小一般为 16KB。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102144698-9e521ae2-6223-4468-8da7-8b5e3f1f78fe.png#averageHue=%23d19e41&clientId=ue4f6f3bf-827e-4&from=paste&height=313&id=ua85ac9a2&originHeight=783&originWidth=750&originalType=binary&ratio=2&rotation=0&showTitle=false&size=155926&status=done&style=none&taskId=u247d4e71-80b0-4d18-9eb3-0f669c7bd95&title=&width=300" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102221586-ae8ddd99-7c69-422f-8d8b-1086284b4335.png#averageHue=%23e7e1d9&clientId=ue4f6f3bf-827e-4&from=paste&height=300&id=u870f67bf&originHeight=351&originWidth=819&originalType=binary&ratio=2&rotation=0&showTitle=false&size=169389&status=done&style=none&taskId=uafdc73c5-0a02-4efe-9935-ef6e3c922ce&title=&width=700" alt="image.png">w</p><h1 id="单条记录的记录头"><a href="#单条记录的记录头" class="headerlink" title="单条记录的记录头"></a>单条记录的记录头</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102317982-874c714b-7f6f-451b-b915-6fbc5a4d90d2.png#averageHue=%23fbf7f4&clientId=ue4f6f3bf-827e-4&from=paste&height=311&id=u58e923b7&originHeight=466&originWidth=1049&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82907&status=done&style=none&taskId=ucc852ef6-cc44-4fbf-a9aa-5841b577b3b&title=&width=700" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102345795-f9ff820b-0b94-485e-83f5-aaf53484d64a.png#averageHue=%23f9f9f8&clientId=ue4f6f3bf-827e-4&from=paste&height=275&id=u11bfcf24&originHeight=442&originWidth=1126&originalType=binary&ratio=2&rotation=0&showTitle=false&size=101276&status=done&style=none&taskId=u9b29b8f0-bb7a-4c43-815e-291fd67c309&title=&width=700" alt="image.png"></p><h3 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h3><p>标记该记录是否被删除<strong>。</strong>1 &#x3D; 删除。被删除的记录<strong>不是立即从磁盘移除</strong>，因为重新排列新顺序<strong>需要性能消耗。</strong>被删掉的记录会组成<strong>垃圾链表</strong>，这些链表组成空间叫做<strong>可重用空间</strong>，之后<strong>新数据可插入到这</strong>。<br>删除的过程如下：</p><ul><li>delete_mask 值设 0。</li><li>next_record 值设 0。</li><li>被删除记录的<strong>上一条指向下一条</strong>。</li><li><strong>最大记录</strong>的 n_owned 值减 1。</li></ul><h3 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h3><p>B+树的每层<strong>非叶子节点</strong>中的<strong>最小记录</strong>都会添加该标记。</p><h3 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h3><p>该组内有多少条记录，每个组的<strong>最后一条记录</strong>中存在（组内最大）。<br>Page Directory 中的<strong>槽</strong>指向每组中的最后一条记录，这条记录中有 n_owned。</p><h3 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h3><p>当前记录在<strong>本页的位置。</strong><br><strong>heap_no &#x3D;&#x3D; 0 or 1 <strong>分别表示</strong>最小记录和最大记录</strong>（也称为<strong>伪记录或虚拟记录</strong>）（记录比较大小即比较<strong>主键的大小</strong>），固定大小** 5B 记录头+8B 数据。<strong>其中最小记录数据为 <strong>infimum</strong> ，最大记录数据为 <strong>supremum</strong>。<br>最小记录和最大记录</strong>不存放<strong>在 User Records 部分，</strong>单独放在** Infimum+Supremum 部分。<br>infimum 指比本页中任何记录都要小，supremum 指本页中比任何记录都要大。<br>通过** infimum 和 supremum **对应的两个槽（Page Directory 中），找到一页中的最小值和最大值（infimum 位置 + 1 为最小值，supremum 位置 - 1 为最大值）。</p><h3 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h3><p>记录当前记录类型，0 &#x3D; 普通记录，1 &#x3D; B+树非叶节点，2 &#x3D; 最小记录 Infimum，3 &#x3D; 最大记录 Supremum。</p><h3 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h3><p>从当前记录的真实数据到下一条记录真实数据的偏移量。即 <strong>记录 1 + next_record &#x3D; 记录 2</strong>，本质是一个<strong>链表</strong>，next_record 指向下一条记录。<br>下一条记录指<strong>按照主键值从小到大</strong>的顺序，规定** Infimum 指向主键值最小<strong>的用户记录，</strong>主键值最大的用户数据指向 Supremum<strong>。<br>next_record 指向</strong>真实数据开头<strong>，指向</strong>记录头结尾<strong>（记录头按</strong>逆序**存放）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700103768843-fc6c3973-41f4-47f3-ae4b-3d47e60b2621.png#averageHue=%23f3e0cc&clientId=ue4f6f3bf-827e-4&from=paste&height=350&id=u2eaa8a44&originHeight=487&originWidth=975&originalType=binary&ratio=2&rotation=0&showTitle=false&size=253063&status=done&style=none&taskId=ufb774ede-efbe-42fd-a4b0-f8a3a96de9d&title=&width=700" alt="image.png"></p><h1 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h1><p>为<strong>查找更快</strong>，设置页目录，<strong>大小不确定</strong>。</p><h2 id="页目录制作"><a href="#页目录制作" class="headerlink" title="页目录制作"></a>页目录制作</h2><ol><li>将所有正常记录（含 Infimum 和 Supremum，不含被删除的）划分为<strong>组。</strong></li><li>每个组<strong>最后一条记录（组内最大）</strong> n_owned 表示组有多少条记录。</li><li>将<strong>槽</strong>（<strong>组最后一条记录的地址偏移量</strong>）按顺序放到** Page Directory（页目录） **里。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700104471100-86143d88-e072-4282-8c57-6cb57163c2b6.png#averageHue=%23f8f1ea&clientId=ue4f6f3bf-827e-4&from=paste&height=382&id=ud59dea2a&originHeight=870&originWidth=1596&originalType=binary&ratio=2&rotation=0&showTitle=false&size=235355&status=done&style=none&taskId=u7abb2a50-5076-4634-bbb8-311fb60762e&title=&width=700" alt="image.png"></p><h2 id="分组划分"><a href="#分组划分" class="headerlink" title="分组划分"></a>分组划分</h2><p>划分规则：1）<strong>最小记录</strong>所在组只能有** 1 条<strong>记录。2）</strong>最大记录<strong>所在组含</strong> 1～8 条<strong>。3）</strong>剩下**分组含 <strong>4～8</strong> 条。</p><ol><li>初始页里只有 Infimum 和 Supremum，它们<strong>分属两个分组</strong>。</li><li>插入记录，根据主键值找<strong>比本记录大&amp;&amp;差值最小</strong>的槽。</li><li>该<strong>槽 o_wned 值加 1</strong>，将记录添加到组中。</li><li>当组记录数到 8 时，拆分成两个组，<strong>一个组 4 条，一个组 5 条</strong>。</li><li><strong>新增一个槽</strong>，记录新分组中最大记录偏移量。</li></ol><h2 id="分组查找"><a href="#分组查找" class="headerlink" title="分组查找"></a>分组查找</h2><ol><li>通过<strong>二分法</strong>确定该记录所在槽，并<strong>找到该槽中的最小值</strong>。二分法条件为 high - low &gt; 1 ，因此一般找到的槽为<strong>记录所在槽的前一个</strong>，再 +1 即可找到记录所在槽。</li><li>通过 next_record 属性<strong>遍历</strong>整个槽，找到目标值。</li></ol><h1 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header 页面头部"></a>Page Header 页面头部</h1><p>数据页中存储记录的<strong>状态信息</strong>，<strong>固定 56B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116283402-da81e487-71ae-4f2b-bf42-0ec397d0f1ea.png#averageHue=%23f7f6f5&clientId=ue4f6f3bf-827e-4&from=paste&height=456&id=u98789a28&originHeight=830&originWidth=1273&originalType=binary&ratio=2&rotation=0&showTitle=false&size=286873&status=done&style=none&taskId=u5ab341da-c74f-435a-8da0-0e0e65edeb2&title=&width=700" alt="image.png"></p><h1 id="File-Header-文件头"><a href="#File-Header-文件头" class="headerlink" title="File Header 文件头"></a>File Header 文件头</h1><p>针对<strong>各种页都通用</strong>的信息，<strong>固定 38B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116380750-113b6a77-0b8b-4653-8124-337776fc627c.png#averageHue=%23ede9e4&clientId=ue4f6f3bf-827e-4&from=paste&height=303&id=u2f484d54&originHeight=534&originWidth=1234&originalType=binary&ratio=2&rotation=0&showTitle=false&size=272149&status=done&style=none&taskId=ue6837071-eadd-453e-b46c-8a8cad77fba&title=&width=700" alt="image.png"></p><ul><li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT 为指向上一页和下一页的两个链表。（<strong>双向链表</strong>）</li></ul><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><p>用于<strong>校验页是否完整</strong>，防止只同步一半的情况发生，<strong>固定 8B</strong>。</p><ul><li>前 4B 表示页的<strong>校验和</strong>。</li><li>后 4B 表示页面最后修改时对应的日志序列位置（<strong>LSN</strong>）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
