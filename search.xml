<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMake</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="1-makefile规则"><a href="#1-makefile规则" class="headerlink" title="1. makefile规则"></a>1. makefile规则</h2><blockquote><p>​Makefile最重要的二个概念一个是目标（target），另一个就是依赖（dependency）。目标就是指要干什么，或说运行 make 后生成什么，而依赖是告诉 make 如何去做以实现目标。</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5318bd66f24eaeab0381a.png" alt="image.png" style="zoom:60%;" /><img src="https://telegraph-image-9wl.pages.dev/file/3b17e9c52415e9e5144d2.png" alt="image.png" style="zoom:70%;" /><blockquote><p>&#x3D;&#x3D;make -v&#x3D;&#x3D; 命令查看环境。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make -v</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">GNU Make <span class="number">3.81</span></span><br><span class="line"><span class="built_in">Copyright</span> (C) <span class="number">2006</span>  Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source <span class="keyword">for</span> copying conditions.</span><br><span class="line">There is NO warranty; <span class="keyword">not</span> even <span class="keyword">for</span> MERCHANTABILITY <span class="keyword">or</span> FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">This program built <span class="keyword">for</span> i386-apple-darwin11<span class="number">.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><blockquote><p>打印 hello world，echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    "echo"时bash shell命令,"echo"前面必须加"tab"。    </p></blockquote><blockquote><p>不打印命令代码，@echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote><p>makefile的&#x3D;&#x3D;目标和依赖&#x3D;&#x3D;，all:test</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:test</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">test:</span><br><span class="line">@echo <span class="string">&quot;Just for test&quot;</span></span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make</span><br><span class="line">Just <span class="keyword">for</span> test</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make test</span><br><span class="line">Just <span class="keyword">for</span> test</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    ":"前的"all"是目标，":"后的"test"是依赖（先决条件），makefile会先按从左到右顺序执行依赖，最后执行目标。    </p></blockquote><blockquote alt="info"><p>    "make"命令后不跟任何目标时，优先执行第一个目标。    </p></blockquote><blockquote alt="warn"><p style="color:red;">一个规则是由目标（targets）、先决条件（prerequisites）以及命令（commands）所组成的。    </p></blockquote><p><a href="https://www.yuque.com/linuxer/xngi03/nfsm1k">参考文章：Makefile 零声参考资料</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/cs5y85">参考文章：CMake 零声参考资料</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/qh9lve">参考文章：CMake 零声实战</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B+ 树的作用</p></blockquote><ol><li>B+树的内层节点做索引，只有叶子节点存储。</li></ol><blockquote><p>B+ 树的用途</p></blockquote><ol><li>MySQL 的数据存储。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B树的作用</p></blockquote><ol><li>二叉树的层数太高，B树可减少层高</li><li>B树内节点和叶子节点都可存储数据</li></ol><blockquote><p>B树的用途</p></blockquote><ol><li>磁盘数据查找（每个层高查找一次磁盘）</li></ol><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>一颗M阶B树T，满足以下条件</p></blockquote><ol><li>每个结点至多拥有M颗子树</li><li>根结点至少拥有两颗子树</li><li>除了根结点以外，其余每个分支结点至少拥有M&#x2F;2课子树</li><li>所有的叶结点都在同一层上</li><li>有k课子树的分支结点则存在K-1个关键字，关键字按照递增顺序进行排</li><li>关键字数量满足 <code>ceil(M/2) - 1＜ = n ＜ = M - 1</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSTree::Node* &amp;node和BSTree::Node &amp;node 区别</title>
      <link href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/"/>
      <url>/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>写二叉查找树&#x3D;&#x3D;递归插入&#x3D;&#x3D;代码时，参数用&#x3D;&#x3D;Node* &amp;node&#x3D;&#x3D; 和&#x3D;&#x3D;Node &amp;node&#x3D;&#x3D;有着明显的不同。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><blockquote alt="info"> <p>    Node &node这是一个对对象的引用，使用这种方式，函数可以修改通过<strong style="color:red;">引用传递的对象的内容</strong>，但不能改变调用者中<strong style="color:red;">对象的地址</strong>。    </p></blockquote><blockquote alt="info"> <p>    Node* &node这是一个对指针的引用，使用这种方式，函数能够直接修改<strong style="color:red;">传入的指针本身</strong>。    </p></blockquote># 3. 代码<blockquote><p>下面是二叉搜索树实现递归插入节点。</p></blockquote><h2 id="1-Node-node作为参数"><a href="#1-Node-node作为参数" class="headerlink" title="1. Node &amp;node作为参数"></a>1. Node &amp;node作为参数</h2><blockquote><p>Node &amp;node 作为参数，此时节点为空时不能直接 new，必须通过父节点的左右子树new，否则会丢失。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Node-node作为参数"><a href="#2-Node-node作为参数" class="headerlink" title="2. Node* &amp;node作为参数"></a>2. Node* &amp;node作为参数</h2><blockquote><p>Node* &amp;node 作为参数，节点空时可以直接 new，新节点会自动连接到树上。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h2><h3 id="1-main-cpp"><a href="#1-main-cpp" class="headerlink" title="1. main.cpp"></a>1. main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t.<span class="built_in">insertNodeR</span>(<span class="number">10</span>);</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-bstree-h"><a href="#2-bstree-h" class="headerlink" title="2. bstree.h"></a>2. bstree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey,newValue</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> key; <span class="comment">// 释放键资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bstree_node&lt;K_TYPE&gt; Node;</span><br><span class="line">    Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _inOrder(Node* node);<span class="comment">//inOrder() 递归部分</span></span><br><span class="line">    <span class="type">bool</span> _insertR(Node* node,<span class="type">const</span> K_TYPE &amp;key);<span class="comment">//inserNodeR()递归部分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNode</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNodeR</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点----递归</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历节点----递归</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_root == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. 根节点空直接插入</span></span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span> (key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//2. 递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, const K_TYPE &amp;key) &#123;</span></span><br><span class="line"><span class="comment">//    if(node == nullptr)&#123;//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line"><span class="comment">//        node = new Node(key);</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    //2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line"><span class="comment">//    if (node-&gt;key &lt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;right,key);</span></span><br><span class="line"><span class="comment">//    &#125; else if (node-&gt;key &gt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;left,key);</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版template &lt;class T&gt; 和 template &lt;typename T&gt; 区别</title>
      <link href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>学习二叉查找树时，有的使用 template <class T>，有的使用 template <typename T> 。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><h2 id="1-C-标准中"><a href="#1-C-标准中" class="headerlink" title="1. C++标准中"></a>1. C++标准中</h2><blockquote alt="info"> <p>    template &lt;typename T&gt; 用于<strong style="color:red;">基础数据类型</strong>， T可以是int char 等    </p></blockquote><blockquote alt="info"> <p>    template &lt;class T&gt; 用于<strong style="color:red;">复杂数据类型</strong>， T可以是string，类 等    </p></blockquote><h2 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h2><blockquote><p>大部分情况，typename和class等价。</p></blockquote><blockquote><p>在C++早期版本中，没有 typename 这个关键字，所以在模板定义的时候便使用了 class。</p></blockquote><p><a href="https://blog.csdn.net/qq_20853741/article/details/125879893">参考文章：模板 template＜typename T＞ 和 template＜class T＞区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树基础 ----&gt; 二叉查找树</title>
      <link href="/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>用于二分查找</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>按照<font title="red">中序排列</font>的二叉树</p></blockquote><ol><li>其左子树下的每个后代节点的值都小于节点n的值。</li><li>其右子树下的每个后代节点的值都大于节点n的值。</li><li>左右子树也均为二叉查找树。</li></ol><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3. 类型"></a>3. 类型</h2><h3 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h3><img src="https://telegraph-image-9wl.pages.dev/file/02d58a1def424af138470.png" alt="图2" style="zoom:125%;" /><blockquote><p>所有的结点都只有左子树的二叉树叫<font title="red">左斜树</font>。</p></blockquote><blockquote><p>所有结点都是只有右子树的二叉树叫<font title="red">右斜树</font>。</p></blockquote><blockquote alt="info"><p>左斜树和右斜树统称为<font title="red">斜树</font>。</p></blockquote><h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><blockquote><ol><li>所有分支结点都存在左子树和右子树。</li><li>所有叶子节点（即没有子节点的节点）都在同一层上。</li></ol></blockquote><blockquote alt="info">    <p>        1. 叶子节点只能出现在最下一层。出现在其它层就不可能达成平衡。    </p>    <p>    2. 非叶子结点的度（结点拥有的子树数目称为结点的度）一定是2。    </p>    <p>    3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。     </p></blockquote><h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/a6db59cb75a2d03165d5b.png" alt="图4" style="zoom:125%;" /><blockquote><p>​一颗具有n个结点的二叉树按层编号（按从上至下、从左到右的顺序进行编号），编号为i(1&lt;&#x3D;i&lt;&#x3D;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。<font title="red">完全二叉树是满二叉树的子集。</font></p></blockquote><blockquote alt="info">    <p>    1.叶子结点只能出现在最下层和次下层。    </p>    <p>    2.最下层的叶子结点集中在树的左部。    </p>    <p>    3.倒数第二层若存在叶子结点，一定在右部连续位置。     </p>    <p>    4.如果结点度为1，则该结点只有左子节点，没有右子节点     </p>    <p>    5.同样结点数目的二叉树，完全二叉树深度最小。     </p></blockquote><blockquote alt="danger">    <p>     满二叉树一定是完全二叉树，但反过来不一定成立。    </p></blockquote>## 4. 代码实现### 1. 二叉树节点定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树框架"><a href="#2-二叉树框架" class="headerlink" title="2. 二叉树框架"></a>2. 二叉树框架</h3><h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h3><blockquote><p>普通插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4. 中序遍历"></a>4. 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-查找"><a href="#5-查找" class="headerlink" title="5. 查找"></a>5. 查找</h3><blockquote><p>普通查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点为key</span></span><br><span class="line">    <span class="keyword">if</span>(key == _root-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历二叉树，查找</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//此时cur-&gt;key == key</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">return</span> _findR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_findR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//2.递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key &gt; key)&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-删除"><a href="#6-删除" class="headerlink" title="6. 删除"></a>6. 删除</h3><blockquote><p>普通删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待删除节点值</span></span><br><span class="line"><span class="comment">*返回值：true 成功删除，false 未找到节点，删除失败</span></span><br><span class="line"><span class="comment">*功能：删除key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">deleteNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点不为空，遍历找到带删除节点位置</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//3.单独讨论只有根节点情况</span></span><br><span class="line">    <span class="keyword">if</span>(_root-&gt;key == key &amp;&amp; _root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历树</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//4.找到删除节点位置，分情况删除节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">                <span class="comment">//1. 左子树、右子树都为空时，叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;left == cur)&#123;</span><br><span class="line">                    parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//2.左子树为空，右子树不为空</span></span><br><span class="line">                <span class="comment">//或者. 左子树、右子树都不为空时</span></span><br><span class="line">                Node* cur_left = cur-&gt;right;</span><br><span class="line">                Node* parent_left = cur;</span><br><span class="line">                <span class="comment">//遍历找到右子树中最小值</span></span><br><span class="line">                <span class="keyword">while</span> (cur_left &amp;&amp; cur_left-&gt;left) &#123;</span><br><span class="line">                    parent_left = cur_left;</span><br><span class="line">                    cur_left = cur_left-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                    <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;right;</span><br><span class="line">                    <span class="comment">//左子树、右子树都不为空时</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                        _root-&gt;left = cur-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_left-&gt;key;</span><br><span class="line">                    parent_left-&gt;right = cur_left-&gt;right;</span><br><span class="line">                    <span class="keyword">delete</span> cur_left;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//3.右子树为空，左子树不为空</span></span><br><span class="line">                Node* cur_right = cur-&gt;left;</span><br><span class="line">                Node* parent_right = cur;</span><br><span class="line">                <span class="comment">//遍历找到左子树中最大值</span></span><br><span class="line">                <span class="keyword">while</span>(cur_right &amp;&amp; cur_right-&gt;right)&#123;</span><br><span class="line">                    parent_right = cur_right;</span><br><span class="line">                    cur_right = cur_right-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                      <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;left;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_right-&gt;key;</span><br><span class="line">                    parent_right-&gt;left = cur_right-&gt;left;</span><br><span class="line">                    <span class="keyword">delete</span> cur_right;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归删除</p></blockquote><p>​在遍历树找到删除元素时采用递归的方式。</p><h3 id="7-深拷贝"><a href="#7-深拷贝" class="headerlink" title="7. 深拷贝"></a>7. 深拷贝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BSTree</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K_TYPE&gt;&amp; t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_root = <span class="built_in">copyTree</span>(t._root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：复制树的根节点</span></span><br><span class="line"><span class="comment">*返回值：true 成功复制，false 复制失败</span></span><br><span class="line"><span class="comment">*功能：复制另一个树，返回另一个树的头节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line">bstree_node&lt;K_TYPE&gt;* BSTree&lt;K_TYPE&gt;::<span class="built_in">copyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bstree_node&lt;K_TYPE&gt;* copyNode = <span class="keyword">new</span> <span class="built_in">bstree_node</span>&lt;K_TYPE&gt;(node-&gt;key);</span><br><span class="line">    copyNode-&gt;left = <span class="built_in">copyTree</span>(node-&gt;left);</span><br><span class="line">    copyNode-&gt;right = <span class="built_in">copyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-析构"><a href="#8-析构" class="headerlink" title="8. 析构"></a>8. 析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">destroyTree</span><span class="params">(<span class="type">const</span> Node* node)</span></span>;<span class="comment">//销毁树</span></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">BSTree</span>()&#123;</span><br><span class="line">    <span class="built_in">destroyTree</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：true 成功销毁，false 销毁失败</span></span><br><span class="line"><span class="comment">*功能：销毁一棵树</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">destroyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">78</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">    t1._root = t1.<span class="built_in">copyTree</span>(t._root);</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:a)&#123;</span><br><span class="line">        t.<span class="built_in">deleteNode</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/a2076188013/article/details/126515470">参考文章：详解二叉搜索树【C++实现】</a></p><p><a href="https://blog.csdn.net/weixin_43274704/article/details/115793265">参考文章：深度解析红黑树</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题套路</title>
      <link href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/"/>
      <url>/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h2><blockquote><p>动态规划的核心是<font title="red">穷举</font>。</p></blockquote><blockquote><p>递归算法的时间复杂度：<font title="red">子问题个数 X 一个子问题需要时间</font>。</p></blockquote><h3 id="1-总体套路"><a href="#1-总体套路" class="headerlink" title="1. 总体套路"></a>1. 总体套路</h3><blockquote alt="info"><p> 1. 明确 base case ----> 2. 明确 "状态" ----> 3. 明确 "选择" ----> 4. 定义 dp 数组 / 函数的含义</p></blockquote><blockquote alt="warn"><p> 可优化问题：<font title="red">最优子结构 、 重叠子问题</font></p></blockquote><blockquote alt="success"><p> 解决方法：<font title="red">备忘录 、 DP table</font></p></blockquote><h3 id="2-自顶向下递归"><a href="#2-自顶向下递归" class="headerlink" title="2. 自顶向下递归"></a>2. 自顶向下递归</h3><blockquote alt="danger"><p>递归套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(状态<span class="number">1</span>,状态<span class="number">2</span>,...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 选择:所有可能的选择)&#123;</span><br><span class="line"><span class="comment">//此时的状态可能因为做了选择而改变</span></span><br><span class="line">        <span class="keyword">auto</span> result = 求最值(result, <span class="built_in">dp</span>(状态<span class="number">1</span>,状态<span class="number">2</span>,...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自顶向下递归</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">memo</span>(n+<span class="number">1</span>);<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自底向上迭代"><a href="#3-自底向上迭代" class="headerlink" title="3. 自底向上迭代"></a>3. 自底向上迭代</h3><blockquote alt="danger"><p>迭代套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="comment">//初始化 base case</span></span><br><span class="line"><span class="keyword">auto</span> dp[<span class="number">0</span>][<span class="number">0</span>][...] = base_case;</span><br><span class="line"><span class="comment">//进行状态转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">1</span>:状态<span class="number">1</span>的所有取值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">2</span>:状态<span class="number">2</span>的所有取值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...<span class="comment">/*省略所有状态*/</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历所有状态，求最值</span></span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>,选择<span class="number">2.</span>..);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自底向上迭代</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2. 代码优化"></a>2. 代码优化</h2><h3 id="1-重叠子问题"><a href="#1-重叠子问题" class="headerlink" title="1. 重叠子问题"></a>1. 重叠子问题</h3><blockquote><p>递归子树中，存在大量重复分支。</p></blockquote><p>​斐波那契数列，若采用暴力递归，则会产生大量重复分支，该方法时间负责度为$O(2^n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列暴力递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/b8be642671ddeb0b8a004.jpg" style="zoom:50%"><p>​上图为暴力递归的&#x3D;&#x3D;递归树&#x3D;&#x3D;，可以发现，存在&#x3D;&#x3D;大量重复分支&#x3D;&#x3D;，使用&#x3D;&#x3D;备忘录&#x3D;&#x3D;可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> memo[n+<span class="number">1</span>];<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/2.jpg" style="zoom:50%;"><p>​上图为&#x3D;&#x3D;带备忘录递归&#x3D;&#x3D;的递归树，少了许多重复分支的计算，同样使用&#x3D;&#x3D;DP table&#x3D;&#x3D;也能解决这个问题。</p><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/4.jpg" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-优化DP-table-空间"><a href="#2-优化DP-table-空间" class="headerlink" title="2. 优化DP table 空间"></a>2. 优化DP table 空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 空间负责度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​     上述代码空间负责度$O(n)$，实际上很多空间都是冗余的，只需要dp[i-1]和dp[i-2]即可，优化后空间负责度$O(1)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 优化后，空间负责度O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp_i_1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp_i_2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> dp = dp_i_1 + dp_i_2;</span><br><span class="line">        dp_i_1 = dp_i_2;</span><br><span class="line">        dp_i_2 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br></pre></td></tr></table></figure><h2 id="3-应用—-凑硬币"><a href="#3-应用—-凑硬币" class="headerlink" title="3. 应用—-凑硬币"></a>3. 应用—-凑硬币</h2><blockquote><p>​给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p></blockquote><h3 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. 总体思路</h3><ol><li>&#x3D;&#x3D;base case&#x3D;&#x3D;  当总金额 amount &lt; 0 时，返回 -1，amount &#x3D;&#x3D; 0时，返回 0 。</li><li>&#x3D;&#x3D;明确状态&#x3D;&#x3D; amount 大小发生变化。</li><li>&#x3D;&#x3D;明确选择&#x3D;&#x3D; 选择硬币。</li><li>&#x3D;&#x3D;明确 dp 函数&#x2F;数组的定义&#x3D;&#x3D; dp输入金额n和数组coins，返回所需最少的硬币个数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> subres = <span class="built_in">coinChange</span>(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span>(subres == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//subres + 1 表示子树最少硬币数+当前硬币</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, subres+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==INT_MAX?<span class="number">-1</span>:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-备忘录优化-—-递归案例"><a href="#2-备忘录优化-—-递归案例" class="headerlink" title="2. 备忘录优化 —- 递归案例"></a>2. 备忘录优化 —- 递归案例</h3><blockquote><p>使用memo，记录 memo[amount] &#x3D; 硬币数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义memo</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化memo，INT_MAX表示memo中没有记录</span></span><br><span class="line">        memo = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case </span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="comment">//备忘录使用</span></span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> subres = <span class="built_in">dp</span>(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (subres == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">min</span>(result, subres + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = result == INT_MAX ? <span class="number">-1</span> : result;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-DP-table-迭代-—-迭代案例"><a href="#3-DP-table-迭代-—-迭代案例" class="headerlink" title="3. DP table 迭代 —- 迭代案例"></a>3. DP table 迭代 —- 迭代案例</h3><blockquote><p>dp 数组的定义：当目标金额为 i  时，至少需要  dp[i] 枚硬币凑出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins)&#123;</span><br><span class="line">            <span class="comment">//coin &gt; i ，硬币 &gt; 总金额，不能凑</span></span><br><span class="line">            <span class="keyword">if</span>(coin&gt;i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转移</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == (amount+<span class="number">1</span>)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/6.jpg" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> labuladong的算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> labuladong的算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>红黑树的用途：</p></blockquote><ol><li>Key–Value 查找。</li><li>顺序。</li></ol><blockquote><p>强查找时所用数据结构：</p></blockquote><ul><li><p>rbtree</p></li><li><p>hash</p></li><li><p>b&#x2F;b+ tree</p></li><li><p>跳表</p></li></ul><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的</li><li>对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点</li></ol><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="1-红黑树定义"><a href="#1-红黑树定义" class="headerlink" title="1. 红黑树定义"></a>1. 红黑树定义</h3><blockquote><p>节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    KEY_TYPE *key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *parent;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//红黑树颜色</span></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote><p>头节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *nil;<span class="comment">//红黑树都指向一个黑色的叶子节点</span></span><br><span class="line">&#125;rbtree;</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>节点存在问题--------无法复用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义 红黑树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name, type) \</span></span><br><span class="line"><span class="meta">struct name&#123;\</span></span><br><span class="line"><span class="meta">        struct type *left;\</span></span><br><span class="line"><span class="meta">        struct type *right;\</span></span><br><span class="line"><span class="meta">        struct type *parent;\</span></span><br><span class="line"><span class="meta">    unsigned char color;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) node;<span class="comment">//第一个参数为空，表示未命名数据结构</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote alt="success"><p>线程复用<br>一个线程有多个状态：ready、wait、sleep和exit。这些状态都用红黑树实现，因此一个线程需要定义多棵红黑树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) ready;<span class="comment">//上面宏定义的红黑树结构</span></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) wait;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) sleep;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h3><blockquote><p>红黑树性质被破坏时（插入新值），进行旋转。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/d61ddf9e7566966d5ac0f.png" style="zoom:50%"><blockquote alt="info"><p>当前的结点是右子树，<font title="red">左旋</font></p></blockquote><p>​node 与父节点交换位置，node 的左子树为父节点，右子树不变。原父节点的左子树不变，右子树为node的左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="comment">//参数：头节点、左旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T-&gt;nil)&#123;<span class="comment">//叶子节点不能左旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *y = x-&gt;right;</span><br><span class="line">    <span class="comment">//交换x的右边和y的左边</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != T-&gt;nil)&#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>当前的结点是左子树，<font title="red">右旋</font></p></blockquote><p>​node 与父节点交换位置，node 的右子树为父节点，左子树不变。原父节点的右子树不变，左子树为node的右子树。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="comment">//参数：头节点、右旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T,rbtree_node *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;<span class="comment">//叶子节点不能右旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">    <span class="comment">//交换y的左边和x的右边</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right != T-&gt;nil)&#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;right)&#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-红黑树的插入"><a href="#3-红黑树的插入" class="headerlink" title="3. 红黑树的插入"></a>3. 红黑树的插入</h3><blockquote><p>插入节点始终红色，根据红黑树性质（判断父亲是否为红色）调整。</p></blockquote><blockquote alt="warn"><p>难点：红色树变色</p></blockquote><blockquote alt="info"><p>    父结点是祖父结点的左子树的情况和右子树情况<font title="red">对称</font>。下面只讨论左子树的三种情况    </p></blockquote><blockquote alt="success"><p>    1. 叔结点是红色的</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ed316a0b512e2382f0b88.png" style="zoom:50%;"><blockquote alt="success"><p>2.叔结点是黑色的，而且当前结点是<font title="red">右孩子</font>。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/9bccd3f7205a1603ac0c8.png" style="zoom:50%;"><blockquote alt="success"><p >3.叔结点是黑色的，而且当前结点是<font title="red">左孩子</font>。   </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/37934bf2d30f32e280afe.png" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="comment">//红黑树插入节点</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;<span class="comment">//从根节点遍历</span></span><br><span class="line">    <span class="comment">//遍历到应该插入z的位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != T-&gt;nil)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//z-&gt;key == x-&gt;key情况，根据业务变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将z插入到红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key )&#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="comment">//z节点染红色</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    <span class="comment">//调整红黑树颜色</span></span><br><span class="line">    <span class="built_in">rbtree_insert_fixup</span>(T,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树颜色调整</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;parent-&gt;color != RED)&#123;<span class="comment">//z节点始终为红色</span></span><br><span class="line">        <span class="comment">//z插入在祖父的左子树时</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;right-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_left_rotate</span>(T,p);<span class="comment">//左旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_right_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//z插入在祖父的右子树时</span></span><br><span class="line">             rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;left-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_right_rotate</span>(T,p);<span class="comment">//右旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_left_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 邮件 icon 点击 404</title>
      <link href="/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/"/>
      <url>/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-Hexo-主题-icon-点击后404"><a href="#1-Hexo-主题-icon-点击后404" class="headerlink" title="1. Hexo 主题 icon 点击后404"></a>1. Hexo 主题 icon 点击后404</h1><p>​在主页面中，点击 icon 的邮件后报错 404 。</p><img src="https://telegraph-image-9wl.pages.dev/file/1a47e264cd5492892b9d5.png" style="zoom:50%;"><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>​_config.yml 文件中添加&#x3D;&#x3D;mailto:example:email.com&#x3D;&#x3D;。</p><img src = "https://telegraph-image-9wl.pages.dev/file/e5eafe32fdf1d570f74cd.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上iCloud下载慢</title>
      <link href="/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-Mac-上-iCloud-下载慢"><a href="#1-Mac-上-iCloud-下载慢" class="headerlink" title="1. Mac 上 iCloud 下载慢"></a>1. Mac 上 iCloud 下载慢</h1><p>​Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。</p><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><p>​设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构</title>
      <link href="/2024/01/21/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/21/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>​数据页大小一般为 16KB。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102144698-9e521ae2-6223-4468-8da7-8b5e3f1f78fe.png#averageHue=%23d19e41&clientId=ue4f6f3bf-827e-4&from=paste&height=313&id=ua85ac9a2&originHeight=783&originWidth=750&originalType=binary&ratio=2&rotation=0&showTitle=false&size=155926&status=done&style=none&taskId=u247d4e71-80b0-4d18-9eb3-0f669c7bd95&title=&width=300" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102221586-ae8ddd99-7c69-422f-8d8b-1086284b4335.png#averageHue=%23e7e1d9&clientId=ue4f6f3bf-827e-4&from=paste&height=300&id=u870f67bf&originHeight=351&originWidth=819&originalType=binary&ratio=2&rotation=0&showTitle=false&size=169389&status=done&style=none&taskId=uafdc73c5-0a02-4efe-9935-ef6e3c922ce&title=&width=700" alt="image.png">w</p><h1 id="单条记录的记录头"><a href="#单条记录的记录头" class="headerlink" title="单条记录的记录头"></a>单条记录的记录头</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102317982-874c714b-7f6f-451b-b915-6fbc5a4d90d2.png#averageHue=%23fbf7f4&clientId=ue4f6f3bf-827e-4&from=paste&height=311&id=u58e923b7&originHeight=466&originWidth=1049&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82907&status=done&style=none&taskId=ucc852ef6-cc44-4fbf-a9aa-5841b577b3b&title=&width=700" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102345795-f9ff820b-0b94-485e-83f5-aaf53484d64a.png#averageHue=%23f9f9f8&clientId=ue4f6f3bf-827e-4&from=paste&height=275&id=u11bfcf24&originHeight=442&originWidth=1126&originalType=binary&ratio=2&rotation=0&showTitle=false&size=101276&status=done&style=none&taskId=u9b29b8f0-bb7a-4c43-815e-291fd67c309&title=&width=700" alt="image.png"></p><h3 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h3><p>标记该记录是否被删除<strong>。</strong>1 &#x3D; 删除。被删除的记录<strong>不是立即从磁盘移除</strong>，因为重新排列新顺序<strong>需要性能消耗。</strong>被删掉的记录会组成<strong>垃圾链表</strong>，这些链表组成空间叫做<strong>可重用空间</strong>，之后<strong>新数据可插入到这</strong>。<br>删除的过程如下：</p><ul><li>delete_mask 值设 0。</li><li>next_record 值设 0。</li><li>被删除记录的<strong>上一条指向下一条</strong>。</li><li><strong>最大记录</strong>的 n_owned 值减 1。</li></ul><h3 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h3><p>B+树的每层<strong>非叶子节点</strong>中的<strong>最小记录</strong>都会添加该标记。</p><h3 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h3><p>该组内有多少条记录，每个组的<strong>最后一条记录</strong>中存在（组内最大）。<br>Page Directory 中的<strong>槽</strong>指向每组中的最后一条记录，这条记录中有 n_owned。</p><h3 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h3><p>当前记录在<strong>本页的位置。</strong><br><strong>heap_no &#x3D;&#x3D; 0 or 1 <strong>分别表示</strong>最小记录和最大记录</strong>（也称为<strong>伪记录或虚拟记录</strong>）（记录比较大小即比较<strong>主键的大小</strong>），固定大小** 5B 记录头+8B 数据。<strong>其中最小记录数据为 <strong>infimum</strong> ，最大记录数据为 <strong>supremum</strong>。<br>最小记录和最大记录</strong>不存放<strong>在 User Records 部分，</strong>单独放在** Infimum+Supremum 部分。<br>infimum 指比本页中任何记录都要小，supremum 指本页中比任何记录都要大。<br>通过** infimum 和 supremum **对应的两个槽（Page Directory 中），找到一页中的最小值和最大值（infimum 位置 + 1 为最小值，supremum 位置 - 1 为最大值）。</p><h3 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h3><p>记录当前记录类型，0 &#x3D; 普通记录，1 &#x3D; B+树非叶节点，2 &#x3D; 最小记录 Infimum，3 &#x3D; 最大记录 Supremum。</p><h3 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h3><p>从当前记录的真实数据到下一条记录真实数据的偏移量。即 <strong>记录 1 + next_record &#x3D; 记录 2</strong>，本质是一个<strong>链表</strong>，next_record 指向下一条记录。<br>下一条记录指<strong>按照主键值从小到大</strong>的顺序，规定** Infimum 指向主键值最小<strong>的用户记录，</strong>主键值最大的用户数据指向 Supremum<strong>。<br>next_record 指向</strong>真实数据开头<strong>，指向</strong>记录头结尾<strong>（记录头按</strong>逆序**存放）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700103768843-fc6c3973-41f4-47f3-ae4b-3d47e60b2621.png#averageHue=%23f3e0cc&clientId=ue4f6f3bf-827e-4&from=paste&height=350&id=u2eaa8a44&originHeight=487&originWidth=975&originalType=binary&ratio=2&rotation=0&showTitle=false&size=253063&status=done&style=none&taskId=ufb774ede-efbe-42fd-a4b0-f8a3a96de9d&title=&width=700" alt="image.png"></p><h1 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h1><p>为<strong>查找更快</strong>，设置页目录，<strong>大小不确定</strong>。</p><h2 id="页目录制作"><a href="#页目录制作" class="headerlink" title="页目录制作"></a>页目录制作</h2><ol><li>将所有正常记录（含 Infimum 和 Supremum，不含被删除的）划分为<strong>组。</strong></li><li>每个组<strong>最后一条记录（组内最大）</strong> n_owned 表示组有多少条记录。</li><li>将<strong>槽</strong>（<strong>组最后一条记录的地址偏移量</strong>）按顺序放到** Page Directory（页目录） **里。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700104471100-86143d88-e072-4282-8c57-6cb57163c2b6.png#averageHue=%23f8f1ea&clientId=ue4f6f3bf-827e-4&from=paste&height=382&id=ud59dea2a&originHeight=870&originWidth=1596&originalType=binary&ratio=2&rotation=0&showTitle=false&size=235355&status=done&style=none&taskId=u7abb2a50-5076-4634-bbb8-311fb60762e&title=&width=700" alt="image.png"></p><h2 id="分组划分"><a href="#分组划分" class="headerlink" title="分组划分"></a>分组划分</h2><p>划分规则：1）<strong>最小记录</strong>所在组只能有** 1 条<strong>记录。2）</strong>最大记录<strong>所在组含</strong> 1～8 条<strong>。3）</strong>剩下**分组含 <strong>4～8</strong> 条。</p><ol><li>初始页里只有 Infimum 和 Supremum，它们<strong>分属两个分组</strong>。</li><li>插入记录，根据主键值找<strong>比本记录大&amp;&amp;差值最小</strong>的槽。</li><li>该<strong>槽 o_wned 值加 1</strong>，将记录添加到组中。</li><li>当组记录数到 8 时，拆分成两个组，<strong>一个组 4 条，一个组 5 条</strong>。</li><li><strong>新增一个槽</strong>，记录新分组中最大记录偏移量。</li></ol><h2 id="分组查找"><a href="#分组查找" class="headerlink" title="分组查找"></a>分组查找</h2><ol><li>通过<strong>二分法</strong>确定该记录所在槽，并<strong>找到该槽中的最小值</strong>。二分法条件为 high - low &gt; 1 ，因此一般找到的槽为<strong>记录所在槽的前一个</strong>，再 +1 即可找到记录所在槽。</li><li>通过 next_record 属性<strong>遍历</strong>整个槽，找到目标值。</li></ol><h1 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header 页面头部"></a>Page Header 页面头部</h1><p>数据页中存储记录的<strong>状态信息</strong>，<strong>固定 56B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116283402-da81e487-71ae-4f2b-bf42-0ec397d0f1ea.png#averageHue=%23f7f6f5&clientId=ue4f6f3bf-827e-4&from=paste&height=456&id=u98789a28&originHeight=830&originWidth=1273&originalType=binary&ratio=2&rotation=0&showTitle=false&size=286873&status=done&style=none&taskId=u5ab341da-c74f-435a-8da0-0e0e65edeb2&title=&width=700" alt="image.png"></p><h1 id="File-Header-文件头"><a href="#File-Header-文件头" class="headerlink" title="File Header 文件头"></a>File Header 文件头</h1><p>针对<strong>各种页都通用</strong>的信息，<strong>固定 38B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116380750-113b6a77-0b8b-4653-8124-337776fc627c.png#averageHue=%23ede9e4&clientId=ue4f6f3bf-827e-4&from=paste&height=303&id=u2f484d54&originHeight=534&originWidth=1234&originalType=binary&ratio=2&rotation=0&showTitle=false&size=272149&status=done&style=none&taskId=ue6837071-eadd-453e-b46c-8a8cad77fba&title=&width=700" alt="image.png"></p><ul><li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT 为指向上一页和下一页的两个链表。（<strong>双向链表</strong>）</li></ul><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><p>用于<strong>校验页是否完整</strong>，防止只同步一半的情况发生，<strong>固定 8B</strong>。</p><ul><li>前 4B 表示页的<strong>校验和</strong>。</li><li>后 4B 表示页面最后修改时对应的日志序列位置（<strong>LSN</strong>）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
          <category> MySQL 是怎样运行的:从根上理解 MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
