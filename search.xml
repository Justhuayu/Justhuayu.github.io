<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程池</title>
      <link href="/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Text-Guided Variational Image Generation for Industrial Anomaly Detection and Segmentation</title>
      <link href="/2024/03/19/%E7%A7%91%E7%A0%94-14-Text-Guided-Variational-Image-Generation/"/>
      <url>/2024/03/19/%E7%A7%91%E7%A0%94-14-Text-Guided-Variational-Image-Generation/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="论文模型名"><a href="#论文模型名" class="headerlink" title="论文模型名"></a>论文模型名</h1><blockquote><p>CVPR 2024</p></blockquote><blockquote><p>中英大学（韩国首尔），Mingyu Lee，Jongwon Choi</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/590d46d735bef6f03ae35.png" alt="538E3925-331F-4561-BD04-4A42941D3CBB_1_105_c" style="zoom:50%;" /><blockquote><ol><li>一种泛用方法，能加到任意模型提点</li><li>本文主要工作为生成额外丰富数据集，用于下游模型训练</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-数据集问题"><a href="#1-数据集问题" class="headerlink" title="1. 数据集问题"></a>1. 数据集问题</h3><blockquote><p>工业制造中获得清晰数据进行异常检测的挑战。</p></blockquote><p>​异常检测的有效性取决于可用的无缺陷数据的数量和质量，因为这些因素直接影响模型包含目标物体外观不同光谱的能力。最重要的是，很难从视觉上对工业缺陷进行分类，因为错误可以从细微的变化(如薄划痕)到重大的结构缺陷(如缺少组件)不等</p><h3 id="2-不平衡的正常数据问题"><a href="#2-不平衡的正常数据问题" class="headerlink" title="2. 不平衡的正常数据问题"></a>2. 不平衡的正常数据问题</h3><blockquote><p>正常数据本身可以呈现出接近均匀性，只有少数图像显示出可接受缺陷的微小差异</p></blockquote><h3 id="3-数据的敏感性"><a href="#3-数据的敏感性" class="headerlink" title="3. 数据的敏感性"></a>3. 数据的敏感性</h3><blockquote><p>在外观和缺陷程度方面，因为它们可能因所使用的机器类型和捕获条件而有很大差异。最后一个是在过度收集非缺陷数据期间错误地将缺陷数据错误地标记为非缺陷数据的可能性。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-variation-based-image-generator"><a href="#1-variation-based-image-generator" class="headerlink" title="1. variation-based image generator"></a>1. variation-based image generator</h3><blockquote><p>保证泛化和鲁棒性</p></blockquote><h3 id="2-keyword-to-prompt-generator"><a href="#2-keyword-to-prompt-generator" class="headerlink" title="2. keyword-to-prompt generator"></a>2. keyword-to-prompt generator</h3><blockquote><p>解决正常数据缺乏多样性的问题</p></blockquote><h3 id="3-text-guided-knowledge-integrator"><a href="#3-text-guided-knowledge-integrator" class="headerlink" title="3. text-guided knowledge integrator"></a>3. text-guided knowledge integrator</h3><blockquote><p>解决不同模态而产生的语义差距</p></blockquote><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-keyword-to-prompt-generator"><a href="#1-keyword-to-prompt-generator" class="headerlink" title="1.keyword-to-prompt generator"></a>1.keyword-to-prompt generator</h3><h4 id="1-WordNet"><a href="#1-WordNet" class="headerlink" title="1. WordNet"></a>1. WordNet</h4><ol><li>根据类名，和语言百科全书，生成多个不同单词</li><li>将不同单词组合成描述句子</li></ol><h4 id="2-best-prompt"><a href="#2-best-prompt" class="headerlink" title="2. best prompt"></a>2. best prompt</h4><ol><li><p>编码图片$I$和文本$S$为向量，$f(G)、G(S)$</p></li><li><p>计算&#x3D;&#x3D;L2&#x3D;&#x3D;离群集合$S^p$</p><p>$S^p &#x3D; {S_j|d(S_j,I^{origin} &gt; 0.5)},d(S_j,I^{origin})&#x3D; ||f(I^{origin}) - G(S_i)||_2)$</p></li><li><p>$S_p$集合中相似度估计最好Prompt</p><p>$P &#x3D; \text{argmax}_{S_j \in S_p} \cos\left(f(I^{origin}), G(S_j)\right)$</p></li></ol><h3 id="2-variation-based-image-generator"><a href="#2-variation-based-image-generator" class="headerlink" title="2. variation-based image generator **"></a>2. variation-based image generator **</h3><blockquote><p>baseline 选择 VAGAN</p></blockquote><p>​现有的VQGAN统一地利用潜在向量的方差σ乘以1，忽略了目标物体在逐块外观上可能存在的多样性。特别是，对于异常检测模型，必须考虑外观多样性，其中非缺陷图像的训练分布确定缺陷。</p><img src="https://telegraph-image-9wl.pages.dev/file/5086bfc1bd2e57e37edd5.png" alt="image-20240319103407637" style="zoom:50%;" /><h3 id="3-text-guided-knowledge-integrator-1"><a href="#3-text-guided-knowledge-integrator-1" class="headerlink" title="3. text-guided knowledge integrator"></a>3. text-guided knowledge integrator</h3><ol><li>将VQGAN生成的图像经过CLIP Image Encoder提取特征</li><li>将best prompt经过CLIP Text Encoder提取特征</li><li>余弦相似度prompt 和图像，找到最好的图像，加入data pool中</li></ol><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><ol><li>MSE</li><li>VQGAN本身损失函数</li></ol><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p><img src="https://telegraph-image-9wl.pages.dev/file/25e7d2764dda25e3fc554.png" alt="image-20240319104224929"></p><p><a href="https://arxiv.org/abs/2403.06247">论文链接</a></p><p><a href="">代码链接（NON）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队</title>
      <link href="/2024/03/19/%E7%A7%91%E7%A0%94-%E5%9B%A2%E9%98%9F/"/>
      <url>/2024/03/19/%E7%A7%91%E7%A0%94-%E5%9B%A2%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Jiaqi-Liu"><a href="#1-Jiaqi-Liu" class="headerlink" title="1. Jiaqi Liu"></a>1. Jiaqi Liu</h2><blockquote><p>南方科技大学</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/705c8408041740090a42c.png" alt="image-20240319092015198" style="zoom:30%;" /><ol><li>Deep Industrial Image Anomaly Detection：A Survey</li><li>Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt（UCAD）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RealNet：A Feature Selection Network with Realistic Synthetic Anomaly for Anomaly Detection</title>
      <link href="/2024/03/18/%E7%A7%91%E7%A0%94-13-RealNet/"/>
      <url>/2024/03/18/%E7%A7%91%E7%A0%94-13-RealNet/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="论文模型名"><a href="#论文模型名" class="headerlink" title="论文模型名"></a>论文模型名</h1><blockquote><p>CVPR 2024</p></blockquote><blockquote><p>首都师范大学，Ximiao Zhang，Min Xu</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ecfd72be98b05d5714ff2.png" alt="image-20240318094227813" style="zoom:67%;" /><blockquote><ol><li>从基础数据集构建合成数据集</li><li>自监督特征重构，进行异常检测</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-自监督特征重建问题"><a href="#1-自监督特征重建问题" class="headerlink" title="1. 自监督特征重建问题"></a>1. 自监督特征重建问题</h3><blockquote><p>合成真实多样的异常样本、解决特征冗余和预训练特征的预训练偏差等方面仍然面临挑战</p></blockquote><p>​由于缺乏可用的异常图像和异常类别的先验知识，现有方法依赖于精心设计的数据增强策略或外部数据进行异常合成，导致合成异常与真实异常的分布差异较大。从而限制了异常检测模型在实际应用中的泛化能力。</p><blockquote><p>由于特征重建的计算量大，缺乏有效的特征选择策略，现有方法要么使用小规模预训练的cnn[33,44,49]进行异常检测，要么从预训练的网络[8,53]中挑选特定层的特征进行重建。</p></blockquote><blockquote><p>现有的异常检测方法[30,46]对特征选择很敏感。在不同的分类中，用于异常检测的最优预训练特征子集是不同的。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-数据集SIA"><a href="#1-数据集SIA" class="headerlink" title="1. 数据集SIA"></a>1. 数据集SIA</h3><blockquote><p>根据SDAS方法，生成异常数据集SIA</p></blockquote><h3 id="2-强度可控扩散异常合成-SDAS"><a href="#2-强度可控扩散异常合成-SDAS" class="headerlink" title="2. 强度可控扩散异常合成(SDAS )"></a>2. 强度可控扩散异常合成(SDAS )</h3><blockquote><p>一种基于扩散过程的合成策略，能够生成具有不同异常强度的样本，模拟真实异常样本的分布。</p></blockquote><h3 id="3-异常感知特征选择-AFS"><a href="#3-异常感知特征选择-AFS" class="headerlink" title="3. 异常感知特征选择(AFS)"></a>3. 异常感知特征选择(AFS)</h3><blockquote><p>自监督方法，选择具有代表性和判别性的预训练特征子集的方法，以提高异常检测性能，同时控制计算成本</p></blockquote><h3 id="4-重建残差选择-RRS"><a href="#4-重建残差选择-RRS" class="headerlink" title="4. 重建残差选择(RRS)"></a>4. 重建残差选择(RRS)</h3><blockquote><p>一种自适应选择判别残差的策略，用于跨多个粒度级别的异常区域的综合识别。</p></blockquote><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-SDAS（Strength-controllable-Diffusion-Anomaly-Synthesis）"><a href="#1-SDAS（Strength-controllable-Diffusion-Anomaly-Synthesis）" class="headerlink" title="1. SDAS（Strength-controllable Diffusion Anomaly Synthesis）"></a>1. SDAS（Strength-controllable Diffusion Anomaly Synthesis）</h3><p>​基于扩散过程的合成策略，能够生成具有不同异常强度的样本。</p><h4 id="1-扩散模型修改"><a href="#1-扩散模型修改" class="headerlink" title="1. 扩散模型修改"></a>1. 扩散模型修改</h4><p>$$<br>p_{\theta}(x’<em>{t-1}|x_t) &#x3D; \mathcal{N}(x’</em>{t-1}; \mu_{\theta}(x_t, t), (1 + s)\Sigma_{\theta}(x_t, t))<br>$$</p><p>​基于扩散模型，引入参数$s$作为生成图像异常程度参数。</p><h4 id="2-异常图像合成"><a href="#2-异常图像合成" class="headerlink" title="2. 异常图像合成"></a>2. 异常图像合成</h4><p>$$<br>A &#x3D; \overline M \odot I + (1 - \delta)(M \odot I) + \delta(M \odot P)<br>$$</p><p>​$I$表示正常图片，$P$表示扩散模型生成的异常图片。$M$表示柏林噪声发生器捕获各种异常形状并将其二值化成异常掩模。$\overline M &#x3D; 1-M$ ，$\odot$表示元素乘法操作，$\delta$表示图像混合不透明度。</p><h3 id="2-AFS（Anomaly-aware-Features-Selection）"><a href="#2-AFS（Anomaly-aware-Features-Selection）" class="headerlink" title="2. AFS（Anomaly-aware Features Selection）"></a>2. AFS（Anomaly-aware Features Selection）</h3><p>​自监督方法，用于预训练特征选择，降低特征维数并消除预训练偏差，以及管理重建成本。</p><h4 id="1-特征映射"><a href="#1-特征映射" class="headerlink" title="1. 特征映射"></a>1. 特征映射</h4><p>$$<br>L_{AFS}(\phi_{k,i}) &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \left| F\left( [\phi_{k,i}(A_n) - \phi_{k,i}(I_n)]^2 \right) - M_n \right|_2^2<br>$$</p><p>​$k$表示预训练网络的中间层，$K$表示预训练网络总层数，$i$表示第$i$个通道特征映射。$A_n$表示SDAS生成的异常图像，$I_n$表示正常图像，$M_n$表示对应的异常mask。$\phi_k$表示预训练网络。$\phi_k(A_n) \in R^{h_k \times w_k \times c_k}$ ，$\phi_{k,i}(A_n) \in R^{h_k \times w_k}$。</p><p>​这里损失只是理想状态下F与M几乎相等，实际上并没有这个损失，这里只是模型中间层。</p><h4 id="2-特征重构"><a href="#2-特征重构" class="headerlink" title="2. 特征重构"></a>2. 特征重构</h4><p>$$<br>L_{\text{recon}}(A, I) &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \sum_{k&#x3D;1}^{K} \left| G_k(\varphi(A_n)) - \varphi(I_n) \right|_2^2<br>$$</p><p>​$\varphi _k$表示上面的特征映射网络，$\varphi_k(A_n) \in R^{h_k \times w_k \times m_k}$，$m_k$表示从$c_n$个通道中选出$m$个特征映射。$G_k$是重构网络。</p><h3 id="3-RSS-（Reconstruction-Residuals-Selection）"><a href="#3-RSS-（Reconstruction-Residuals-Selection）" class="headerlink" title="3. RSS （Reconstruction Residuals Selection）"></a>3. RSS （Reconstruction Residuals Selection）</h3><ol><li><p>重构残差$E_k(A_n) &#x3D; \left[ \phi_k(A_n) - G_k(\phi_k(A_n)) \right]^2$ ，$k \in K$。$E_k(A_n) \in R^{h’ \times w’ \times m’}$ </p><p>$m’ &#x3D; \sum_{k&#x3D;1}^{K} m_k$，$\quad h’ &#x3D; \max(h_1, \ldots, h_K)$ ，$ \quad w’ &#x3D; \max(w_1, \ldots, w_K)$。</p></li><li><p>&#x3D;&#x3D;GlobalMaxPooling&#x3D;&#x3D; $E_{GMP}(A_n)$，&#x3D;&#x3D;GlobalAveragePooling&#x3D;&#x3D;$E_{GAP}(An)$用于每个通道上的特征获取全局最大池化和全局平均池化结果。 $E_{GMP}(A_n) 、 E_{GAP}(A_n) \in R^{m’}$</p></li><li><p>选取池化前$r$个最大元素，$E_{max}(A_n,r)$和$E_{avg}(A_n,r)$。 $E_{max}(A_n,r)、E_{avg}(A_n,r) \in R^{h’ \times w’ \times r}$。</p></li><li><p>结合$E_{max}$和$E_{acg}$，$E_{RRS}(A_n,r) \in R^{h’\times w’\times r}$ 拼接$E_{max}(A_n,r&#x2F;2)$和$E_{avg}(A_n,r&#x2F;2)$。</p></li><li><p>用交叉熵$L_{seg}(A,M)$作为RSS损失。</p></li></ol><p>$$<br>L_{\text{seg}}(A, M) &#x3D; -\sum_{i&#x3D;1}^{N} \left[ M_i \log(A_i) + (1 - M_i) \log(1 - A_i) \right]<br>$$</p><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><p>$$<br>L(A, I, M) &#x3D; L_{\text{recon}}(A, I) + L_{\text{seg}}(A, M)<br>$$</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/e3a6fbbbfef4631e2a1b9.png" alt="image-20240318133505456" style="zoom:50%;" /><img src="https://telegraph-image-9wl.pages.dev/file/253cb138b4655a572ca1c.png" alt="image-20240318133517205" style="zoom:50%;" /><p><a href="https://arxiv.org/abs/2403.05897">论文链接</a></p><p><a href="https://github.com/cnulab/RealNet">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io_uring</title>
      <link href="/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-20-io-uring/"/>
      <url>/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-20-io-uring/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><h3 id="1-异步的读"><a href="#1-异步的读" class="headerlink" title="1. 异步的读"></a>1. 异步的读</h3><ol><li>内存中设计一个&#x3D;&#x3D;ring，存放读队列&#x3D;&#x3D;</li><li>内核&#x3D;&#x3D;遍历读队列&#x3D;&#x3D;，依次执行读</li><li>内核执行后的读，放入&#x3D;&#x3D;另一个ring&#x3D;&#x3D;中，用于返回</li></ol><p><img src="https://telegraph-image-9wl.pages.dev/file/652277bc8e4a00b2113f2.png" alt="image-20240317210903371"></p><h3 id="2-使用条件"><a href="#2-使用条件" class="headerlink" title="2. 使用条件"></a>2. 使用条件</h3><ol><li><p>内核版本 kernel &gt;&#x3D;5.10 （<code>uname -a</code>）</p></li><li><p>安装库&#x3D;&#x3D;liburing&#x3D;&#x3D;，该库依赖于</p><p> <code>io_uring_setup</code> <code>io_uring_register</code> <code>io_uring_enter</code></p><p>这三个系统调用 （5.10后才有）</p></li></ol><h3 id="3-安装-liburing"><a href="#3-安装-liburing" class="headerlink" title="3. 安装 liburing"></a>3. 安装 liburing</h3><ol><li><p>从github clone 项目</p><p> <code>git clone https://github.com/axboe/liburing.git</code></p></li><li><p><code>./configure</code></p></li><li><p><code>make</code></p></li><li><p><code>sudo make install</code></p></li></ol><h3 id="4-io-uring-的性能"><a href="#4-io-uring-的性能" class="headerlink" title="4. io_uring 的性能"></a>4. io_uring 的性能</h3><blockquote><p>测试网络echo工具：rust_echo_bench</p></blockquote><p>​使用命令：<code>cargo run --release -- --address &quot;127.0.0.1:9999&quot; --number 1000 --duration 20 --length 512</code></p><p><a href="https://github.com/haraldh/rust_echo_bench">github</a></p><ol><li>io_uring性能</li></ol><img src="https://telegraph-image-9wl.pages.dev/file/ff23e0319c9eb45a820ab.png" alt="image-20240318204405512" style="zoom:44%;" /><ol start="2"><li>epoll性能</li></ol><img src="https://telegraph-image-9wl.pages.dev/file/3316db6f8f8e4ffe8f0a1.png" alt="image-20240318204348412" style="zoom:50%;" /><blockquote><p>测试文件io速率iops工具：fio</p></blockquote><p>​使用命令：<code>fio --name=lk --ioengine=psync --iodepth=1 --rw=randread --bs=4k --numjobs=1 --size=10G --runtime=20 --filename=./fiotestfile</code></p><ol><li><p><code>--ioengine</code>参数为 &#x3D;&#x3D;psync&#x3D;&#x3D; 或 &#x3D;&#x3D;io_uring&#x3D;&#x3D;（io_uring的<code>--iodepth</code>要设置为128）</p></li><li><p><code>--rw</code>参数为 &#x3D;&#x3D;randread&#x3D;&#x3D; 或 &#x3D;&#x3D;randwrite&#x3D;&#x3D;</p></li><li><p>读 io_uring &#x3D;&#x3D;&gt;&#x3D;&#x3D; psync，写两者&#x3D;&#x3D;差不多&#x3D;&#x3D;</p></li></ol><table><thead><tr><th align="center">—-</th><th>读–IOPS(BW)</th><th align="center">写–IOPS(BW)</th></tr></thead><tbody><tr><td align="center">psync</td><td>8411(34.5MB&#x2F;s)</td><td align="center">66.3k(272MB&#x2F;s)</td></tr><tr><td align="center">io_uring</td><td>256k(1050MB&#x2F;s)</td><td align="center">57.6k(236MB&#x2F;s)</td></tr></tbody></table><p><a href="https://github.com/axboe/fio">github</a></p><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><h3 id="1-liburing"><a href="#1-liburing" class="headerlink" title="1. liburing"></a>1. liburing</h3><ul><li>初始化一个 io_uring 实例，并根据指定的参数配置队列。</li></ul><h4 id="1-io-uring-queue-init-params"><a href="#1-io-uring-queue-init-params" class="headerlink" title="1.io_uring_queue_init_params"></a>1.io_uring_queue_init_params</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_uring_queue_init_params</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> entries,             <span class="comment">// 队列中的条目数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring *ring,        <span class="comment">// 指向 io_uring 结构体的指针，用于初始化的 io_uring 实例</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring_params *p     <span class="comment">// 指向 io_uring_params 结构体的指针，包含初始化参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-struct-io-uring-params-和-struct-io-uring"><a href="#2-struct-io-uring-params-和-struct-io-uring" class="headerlink" title="2.struct io_uring_params 和 struct io_uring"></a>2.struct io_uring_params 和 struct io_uring</h4><ul><li><p><code>io_uring_params</code> 结构体定义了初始化 io_uring 实例时的参数。</p></li><li><p><code>io_uring</code> 结构体定义了一个 io_uring 实例的属性和状态信息。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 初始化 ring参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_params</span> params;</span><br><span class="line"><span class="built_in">memset</span>(&amp;params,<span class="number">0</span>,<span class="built_in">sizeof</span>(params));</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line"><span class="built_in">io_uring_queue_init_params</span>(ENTRIES_LENGTH,&amp;ring,&amp;params);</span><br></pre></td></tr></table></figure><h4 id="3-io-uring-get-sqe"><a href="#3-io-uring-get-sqe" class="headerlink" title="3. io_uring_get_sqe"></a>3. io_uring_get_sqe</h4><ul><li><code>io_uring_get_sqe</code> 函数用于获取下一个空闲的提交队列项（SQE）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *<span class="built_in">io_uring_get_sqe</span>(<span class="keyword">struct</span> io_uring *ring);</span><br><span class="line"><span class="comment">//成功 空闲的提交队列项的指针，失败 NULL</span></span><br></pre></td></tr></table></figure><h4 id="4-io-uring-prep-accept"><a href="#4-io-uring-prep-accept" class="headerlink" title="4. io_uring_prep_accept"></a>4. io_uring_prep_accept</h4><ul><li>准备一个接收连接的操作，将其添加到 I&#x2F;O 请求队列中</li><li>类似的还有 send、recv等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_uring_prep_accept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring_sqe *sqe, <span class="comment">// 指向 io_uring_sqe 结构体的指针，用于设置相关参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> sockfd,               <span class="comment">// 监听套接字的文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> sockaddr *addr,    <span class="comment">// 客户端地址结构体的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">socklen_t</span> *addrlen,       <span class="comment">// 客户端地址结构体长度的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags                 <span class="comment">// accept 函数的 flags 参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-io-uring-sqe-的-user-data"><a href="#5-io-uring-sqe-的-user-data" class="headerlink" title="5. io_uring_sqe 的 user_data"></a>5. io_uring_sqe 的 user_data</h4><ul><li><code>struct io_uring_sqe *sq-&gt;user_data</code>分配内存为8B，刚好为2个int的大小</li><li>自定义struct，将结构体内容保存到user_data中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_conninfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> event;</span><br><span class="line">&#125;conninfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    EVENT_ACCEPT = <span class="number">0</span>,</span><br><span class="line">    EVENT_READ,</span><br><span class="line">    EVENT_WRITE</span><br><span class="line">&#125;;</span><br><span class="line">conninfo info_accept = &#123;</span><br><span class="line">        .connfd = sockfd,</span><br><span class="line">        .event = EVENT_ACCEPT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;sq-&gt;user_data,&amp;info_accept,<span class="built_in">sizeof</span> (conninfo));</span><br></pre></td></tr></table></figure><h4 id="6-io-uring-submit"><a href="#6-io-uring-submit" class="headerlink" title="6. io_uring_submit"></a>6. io_uring_submit</h4><ul><li>将已经准备好的 I&#x2F;O 请求提交到 I&#x2F;O 处理环。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_uring_submit</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span>;</span><br><span class="line"><span class="comment">//成功 提交的请求数量，失败 负数</span></span><br></pre></td></tr></table></figure><h4 id="7-io-uring-wait-cqe"><a href="#7-io-uring-wait-cqe" class="headerlink" title="7. io_uring_wait_cqe"></a>7. io_uring_wait_cqe</h4><ul><li>等待I&#x2F;O完成事件</li><li>阻塞</li><li>触发的事件会被从环中移除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_uring_wait_cqe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring *ring,   <span class="comment">// 指向 io_uring 结构体的指针，表示要等待的 I/O 环</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring_cqe **cqe_ptr <span class="comment">// 指向指针的指针，用于存储完成事件的 io_uring_cqe 结构体的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-io-uring-peek-batch-cqe"><a href="#8-io-uring-peek-batch-cqe" class="headerlink" title="8. io_uring_peek_batch_cqe"></a>8. io_uring_peek_batch_cqe</h4><ul><li>用于检查 I&#x2F;O 环中的完成事件，但不会将它们从环中移除。</li><li>非阻塞</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_uring_peek_batch_cqe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring *ring,          <span class="comment">// 指向 io_uring 结构体的指针，表示要检查的 I/O 环</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring_cqe **cqes,     <span class="comment">// 指向 io_uring_cqe 结构体数组的指针，用于存储完成事件的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> count                  <span class="comment">// 要检查的完成事件数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回完成事件数</span></span><br></pre></td></tr></table></figure><h4 id="9-io-uring-cq-advance"><a href="#9-io-uring-cq-advance" class="headerlink" title="9. io_uring_cq_advance"></a>9. io_uring_cq_advance</h4><ul><li>从 I&#x2F;O 完成队列中移除指定数量的完成事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">io_uring_cq_advance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> io_uring *ring,  <span class="comment">// 指向 io_uring 结构体的指针，表示要操作的 I/O 环</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> nr             <span class="comment">// 要从完成队列中移除的完成事件数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回移除的完成事件数量</span></span><br></pre></td></tr></table></figure><h3 id="2-readv-和-writev"><a href="#2-readv-和-writev" class="headerlink" title="2. readv 和 writev"></a>2. readv 和 writev</h3><h4 id="1-readv"><a href="#1-readv" class="headerlink" title="1. readv"></a>1. readv</h4><ul><li>从文件描述符 <code>fd</code> 中读取数据到多个缓冲区中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd,                 <span class="comment">// 文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="comment">// 存放读取数据的缓冲区数组指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> iovcnt              <span class="comment">// 缓冲区数组中缓冲区的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 读取字节数，失败 -1</span></span><br></pre></td></tr></table></figure><h4 id="2-writev"><a href="#2-writev" class="headerlink" title="2. writev"></a>2. writev</h4><ul><li>将多个缓冲区中的数据写入到文件描述符 <code>fd</code> 对应的文件中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd,                      <span class="comment">// 文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> iovec *iov,    <span class="comment">// 存放待写入数据的缓冲区数组指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> iovcnt                 <span class="comment">// 缓冲区数组中缓冲区的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-struct-iovec"><a href="#3-struct-iovec" class="headerlink" title="3. struct iovec"></a>3. struct iovec</h4><ul><li><code>iovec</code> 结构体用于描述一个缓冲区的地址和长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">    <span class="type">void</span> *iov_base; <span class="comment">// 缓冲区的起始地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">// 缓冲区的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> io[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//定义三个io，后续分别为他们赋值</span></span><br></pre></td></tr></table></figure><h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><h4 id="1-shm-open"><a href="#1-shm-open" class="headerlink" title="1. shm_open"></a>1. shm_open</h4><ul><li>创建或打开一个共享内存对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *name, <span class="comment">//共享内存名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> oflag, <span class="comment">//打开标志，例如 O_RDWRs</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">mode_t</span> mode<span class="comment">//权限标志，在创建新对象时使用，通常与 O_CREAT 标志一起使用。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 fd，失败 -1</span></span><br></pre></td></tr></table></figure><ul><li><code>O_RDWR</code>：以读写方式打开文件。表示文件可以同时读取和写入。</li><li><code>O_CREAT</code>：如果文件不存在，则创建一个新文件。如果文件已经存在，则不执行任何操作。</li><li><code>S_IRUSR</code>：设置文件的用户读取权限。表示用户（拥有者）具有读取文件的权限。</li><li><code>S_IWUSR</code>：设置文件的用户写入权限。表示用户（拥有者）具有写入文件的权限。</li></ul><h4 id="2-truncate"><a href="#2-truncate" class="headerlink" title="2. truncate"></a>2. truncate</h4><ul><li>改变已打开文件的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">off_t</span> length<span class="comment">//要设置的文件大小，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//改变已打开文件的大小</span></span><br><span class="line"><span class="comment">//成功 0，失败 -1 </span></span><br></pre></td></tr></table></figure><h4 id="3-mmap"><a href="#3-mmap" class="headerlink" title="3. mmap"></a>3. mmap</h4><ul><li>一个文件或者一个共享内存对象映射到进程的地址空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *addr,<span class="comment">// 指定映射的地址，通常为 NULL，表示由系统选择映射的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> length,<span class="comment">// 指定映射的长度，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> prot,<span class="comment">// 指定内存保护方式，表示内存页面的访问权限,例如 PROT_READ</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags, <span class="comment">// 指定映射的标志，表示映射选项，例如 MAP_SHARED</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd,<span class="comment">// 表示要映射的文件的文件描述符，如果是匿名映射，则为 -1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">off_t</span> offset<span class="comment">// 表示要映射的文件中的偏移量，通常为 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 映射区起始地址(void *)，失败 MAP_FAILED（-1）</span></span><br></pre></td></tr></table></figure><ul><li><code>PROT_READ</code>：可读</li><li><code>PROT_WRITE</code>（可写）</li><li><code>PROT_EXEC</code>（可执行）</li><li><code>MAP_SHARED</code>（与其他进程共享映射）</li><li><code>MAP_PRIVATE</code>（私有映射）</li><li><code>MAP_ANONYMOUS</code>（匿名映射）</li></ul><h4 id="4-struct-sockaddr-un"><a href="#4-struct-sockaddr-un" class="headerlink" title="4. struct sockaddr_un"></a>4. struct sockaddr_un</h4><ul><li>unix域套节字结构体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr = &#123;</span><br><span class="line">    .sun_family = AF_UNIX,<span class="comment">//套接字的地址族</span></span><br><span class="line">    .sun_path = <span class="string">&quot;/tmp/my_socket&quot;</span><span class="comment">//套接字的路径名，用于标识套接字在文件系统中的位置</span></span><br><span class="line">    <span class="comment">//一般用strncpy赋值</span></span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path,<span class="string">&quot;/tmp/0voice.sock&quot;</span>,<span class="built_in">sizeof</span>(addr.sun_path)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//unix域套节字</span></span><br></pre></td></tr></table></figure><h4 id="5-CMSG-SPACE"><a href="#5-CMSG-SPACE" class="headerlink" title="5. CMSG_SPACE"></a>5. CMSG_SPACE</h4><ul><li><p><code>CMSG_SPACE()</code> 宏用于计算给定长度的控制消息所需的空间大小，包括消息头部以及消息</p><p>所需的对齐空间。它的参数是消息所需的长度，单位是字节。</p></li></ul><h4 id="6-CMSG-LEN"><a href="#6-CMSG-LEN" class="headerlink" title="6. CMSG_LEN"></a>6. CMSG_LEN</h4><ul><li><code>CMSG_LEN()</code>宏，用于计算控制消息（Control Message）的实际长度。</li><li>通常用于在使用 <code>struct cmsghdr</code> 结构体创建控制消息时，确保控制消息的长度正确，以便系统能够正确解析控制消息。</li></ul><h4 id="7-struct-msghdr"><a href="#7-struct-msghdr" class="headerlink" title="7. struct msghdr"></a>7. struct msghdr</h4><ul><li>表示消息的数据结构，在套接字编程中经常用于 <code>sendmsg()</code> 和 <code>recvmsg()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> &#123;</span><br><span class="line">    <span class="type">void</span> *msg_name;<span class="comment">// 指向目标地址的指针，用于发送数据时指定目标地址，接收数据时返回源地址</span></span><br><span class="line">    <span class="type">socklen_t</span> msg_namelen;<span class="comment">// 目标地址的长度</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;<span class="comment">// 指向数据缓冲区的指针数组，用于指定发送或接收的数据</span></span><br><span class="line">    <span class="type">size_t</span> msg_iovlen;<span class="comment">// 数据缓冲区的数量</span></span><br><span class="line">    <span class="type">void</span> *msg_control;<span class="comment">// 指向控制消息的指针，用于发送或接收辅助数据</span></span><br><span class="line">    <span class="type">size_t</span> msg_controllen;<span class="comment">// 控制消息的长度</span></span><br><span class="line">    <span class="type">int</span> msg_flags;<span class="comment">// 用于传递和接收标志信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-struct-cmsghdr"><a href="#8-struct-cmsghdr" class="headerlink" title="8. struct cmsghdr"></a>8. struct cmsghdr</h4><ul><li>表示控制消息（Control Message）头部的数据结构，在套接字编程中经常与 <code>CMSG_*</code> 系列宏一起使用。</li><li><code>struct cmsghdr</code> 通常用于在发送或接收套接字数据时，传递额外的控制信息。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmsghdr</span> &#123;</span><br><span class="line">    <span class="type">socklen_t</span> cmsg_len; <span class="comment">// 控制消息的总长度</span></span><br><span class="line">    <span class="type">int</span>       cmsg_level; <span class="comment">// 控制消息的协议层级，例如SOL_SOCKETs</span></span><br><span class="line">    <span class="type">int</span>       cmsg_type;  <span class="comment">// 控制消息的类型，例如SCM_RIGHTS</span></span><br><span class="line">    <span class="comment">// 控制消息数据部分跟在头部后面</span></span><br><span class="line">    <span class="comment">// unsigned char cmsg_data[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>msghdr 与 cmsghdr</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/73c045d69a851e0704d6b.png" alt="这里写图片描述" style="zoom:73%;" /><h4 id="9-CMSG-FIRSTHDR"><a href="#9-CMSG-FIRSTHDR" class="headerlink" title="9. CMSG_FIRSTHDR"></a>9. CMSG_FIRSTHDR</h4><ul><li><code>CMSG_FIRSTHDR()</code> 宏用于获取消息头部中第一个控制消息头部的指针。</li></ul><h4 id="10-CMSG-DATA"><a href="#10-CMSG-DATA" class="headerlink" title="10. CMSG_DATA"></a>10. CMSG_DATA</h4><ul><li><code>CMSG_DATA()</code> 宏用于获取控制消息中数据部分的指针。</li></ul><h4 id="11-munmap"><a href="#11-munmap" class="headerlink" title="11. munmap"></a>11. munmap</h4><ul><li>取消映射一个先前由 <code>mmap()</code> 创建的内存映射区域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *addr,<span class="comment">//要取消映射的内存区域的起始地址。 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> length<span class="comment">//要取消映射的内存区域的长度。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败 -1</span></span><br></pre></td></tr></table></figure><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3. 源码"></a>3. 源码</h2><h3 id="1-liburing进行网络io"><a href="#1-liburing进行网络io" class="headerlink" title="1. liburing进行网络io"></a>1. liburing进行网络io</h3><ol><li><p>初始化server。</p></li><li><p>定义结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_conninfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> event;</span><br><span class="line">&#125;conninfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    EVENT_ACCEPT = <span class="number">0</span>,</span><br><span class="line">    EVENT_READ,</span><br><span class="line">    EVENT_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化ring</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_params</span> params;</span><br><span class="line"><span class="built_in">memset</span>(&amp;params,<span class="number">0</span>,<span class="built_in">sizeof</span>(params));</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line"><span class="built_in">io_uring_queue_init_params</span>(ENTRIES_LENGTH,&amp;ring,&amp;params);</span><br></pre></td></tr></table></figure></li><li><p>向sqe中设置accept事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_uring_accept</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">int</span> sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> sockaddr *clientAddr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> *clientLen)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 从ring获取sqe</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sqe = <span class="built_in">io_uring_get_sqe</span>(ring);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;clientAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (clientAddr));</span><br><span class="line">    <span class="comment">//2. 设置accept请假，到sqe提交队列中</span></span><br><span class="line">    <span class="built_in">io_uring_prep_accept</span>(sq,sockfd,clientAddr,clientLen,<span class="number">0</span>);</span><br><span class="line">    conninfo info_accept = &#123;</span><br><span class="line">            .connfd = sockfd,</span><br><span class="line">            .event = EVENT_ACCEPT,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sqe-&gt;user_data,&amp;info_accept,<span class="built_in">sizeof</span> (conninfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line"><span class="type">ssize_t</span> clientLen = <span class="built_in">sizeof</span> (clientAddr);</span><br><span class="line"><span class="built_in">set_uring_accept</span>(&amp;ring,sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span> *)&amp;clientLen);</span><br></pre></td></tr></table></figure></li><li><p>循环</p><ol><li><p>将ring中sqe队列提交到内核中处理</p><p><code>io_uring_submit(&amp;ring);</code></p></li><li><p>等待ring中响应</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line"><span class="comment">//这里cqe表示cq中头，即响应的第一个节点</span></span><br><span class="line"><span class="comment">//阻塞在这里，知道cqe中有数据</span></span><br><span class="line"><span class="built_in">io_uring_wait_cqe</span>(&amp;ring,&amp;cqe);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>获取响应事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqes[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> cqecount = <span class="built_in">io_uring_peek_batch_cqe</span>(&amp;ring,cqes,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>遍历响应的事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cqecount;i++)&#123;</span><br><span class="line">    cqe = cqes[i];</span><br><span class="line">    conninfo ci;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;ci,&amp;cqe-&gt;user_data,<span class="built_in">sizeof</span> (ci));</span><br><span class="line">    <span class="keyword">if</span>(ci.event == EVENT_ACCEPT)&#123;</span><br><span class="line">        <span class="type">int</span> connfd = cqe-&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept: %d\n&quot;</span>,ci.connfd);</span><br><span class="line">        <span class="built_in">set_uring_accept</span>(&amp;ring,sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span> *)&amp;clientLen);</span><br><span class="line">        <span class="built_in">set_uring_recv</span>(&amp;ring,connfd,buffer,<span class="number">1024</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ci.event == EVENT_READ)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cqe-&gt;res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">close</span>(ci.connfd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cqe-&gt;res &lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv:%s ,%d\n&quot;</span>,buffer,ci.connfd);</span><br><span class="line">            <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">            <span class="built_in">set_uring_recv</span>(&amp;ring,ci.connfd,</span><br><span class="line">                          buffer,<span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清空当前事件</p><p><code>io_uring_cq_advance(&amp;ring,cqecount);</code></p></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by lkh on 24-3-17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENTRIES_LENGTH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serAddr));</span><br><span class="line">    serAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serAddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    serAddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">bind</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;serAddr,<span class="built_in">sizeof</span> (serAddr));</span><br><span class="line">    <span class="built_in">listen</span>(sockfd,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_conninfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> event;</span><br><span class="line">&#125;conninfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span>&#123;</span><br><span class="line">    EVENT_ACCEPT = <span class="number">0</span>,</span><br><span class="line">    EVENT_READ,</span><br><span class="line">    EVENT_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_uring_accept</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">int</span> sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> sockaddr *clientAddr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> *clientLen)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 从ring获取sq</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sq = <span class="built_in">io_uring_get_sqe</span>(ring);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;clientAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (clientAddr));</span><br><span class="line">    <span class="comment">//2. 设置accept请假，到sq提交队列中</span></span><br><span class="line">    <span class="built_in">io_uring_prep_accept</span>(sq,sockfd,clientAddr,clientLen,<span class="number">0</span>);</span><br><span class="line">    conninfo info_accept = &#123;</span><br><span class="line">            .connfd = sockfd,</span><br><span class="line">            .event = EVENT_ACCEPT,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sq-&gt;user_data,&amp;info_accept,<span class="built_in">sizeof</span> (conninfo));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_uring_recv</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">int</span> sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sq = <span class="built_in">io_uring_get_sqe</span>(ring);</span><br><span class="line">    <span class="built_in">io_uring_prep_recv</span>(sq,sockfd,buf,len,<span class="number">0</span>);</span><br><span class="line">    conninfo info_recv = &#123;</span><br><span class="line">            .connfd = sockfd,</span><br><span class="line">            .event = EVENT_READ,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sq-&gt;user_data,&amp;info_recv,<span class="built_in">sizeof</span> (conninfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_uring_send</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">int</span> sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sq = <span class="built_in">io_uring_get_sqe</span>(ring);</span><br><span class="line">    <span class="built_in">io_uring_prep_write</span>(sq,sockfd,buf,len,<span class="number">0</span>);</span><br><span class="line">    conninfo info_write = &#123;</span><br><span class="line">            .connfd = sockfd,</span><br><span class="line">            .event = EVENT_WRITE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sq-&gt;user_data,&amp;info_write,<span class="built_in">sizeof</span> (conninfo));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">init_server</span>();</span><br><span class="line"><span class="comment">// liburing</span></span><br><span class="line">    <span class="comment">//1. 初始化 ring参数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_params</span> params;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;params,<span class="number">0</span>,<span class="built_in">sizeof</span>(params));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line">    <span class="built_in">io_uring_queue_init_params</span>(ENTRIES_LENGTH,&amp;ring,&amp;params);</span><br><span class="line">    <span class="comment">//2. accept</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line">    <span class="type">ssize_t</span> clientLen = <span class="built_in">sizeof</span> (clientAddr);</span><br><span class="line">    <span class="built_in">set_uring_accept</span>(&amp;ring,sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span> *)&amp;clientLen);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//将ring中sq队列提交到内核中处理</span></span><br><span class="line">        <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">        <span class="keyword">struct</span>  <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line">        <span class="comment">//等待ring中响应</span></span><br><span class="line">        <span class="built_in">io_uring_wait_cqe</span>(&amp;ring,&amp;cqe);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqes[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//检测sq中10条队列，将内核处理完的部分返回cq</span></span><br><span class="line">        <span class="type">int</span> cqecount = <span class="built_in">io_uring_peek_batch_cqe</span>(&amp;ring,cqes,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cqecount;i++)&#123;</span><br><span class="line">            cqe = cqes[i];</span><br><span class="line">            conninfo ci;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;ci,&amp;cqe-&gt;user_data,<span class="built_in">sizeof</span> (ci));</span><br><span class="line">            <span class="keyword">if</span>(ci.event == EVENT_ACCEPT)&#123;</span><br><span class="line">                <span class="type">int</span> connfd = cqe-&gt;res;</span><br><span class="line">                <span class="keyword">if</span>(connfd &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accept: %d\n&quot;</span>,ci.connfd);</span><br><span class="line">                <span class="built_in">set_uring_accept</span>(&amp;ring,sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;clientAddr,(<span class="type">socklen_t</span> *)&amp;clientLen);</span><br><span class="line">                <span class="built_in">set_uring_recv</span>(&amp;ring,connfd,buffer,<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ci.event == EVENT_READ)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cqe-&gt;res == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">close</span>(ci.connfd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cqe-&gt;res &lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                  buffer[cqe-&gt;res] = &#x27;\0&#x27;;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv:%s ,%d\n&quot;</span>,buffer,ci.connfd);</span><br><span class="line">                    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">                    <span class="built_in">set_uring_send</span>(&amp;ring,ci.connfd,buffer,cqe-&gt;res);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ci.event == EVENT_WRITE)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;write:%s ,%d\n&quot;</span>,buffer,ci.connfd);</span><br><span class="line">                    <span class="built_in">set_uring_recv</span>(&amp;ring,ci.connfd,buffer,<span class="number">1024</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">io_uring_cq_advance</span>(&amp;ring,cqecount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-readv-和-writev-1"><a href="#2-readv-和-writev-1" class="headerlink" title="2. readv 和 writev"></a>2. readv 和 writev</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><ol><li>读（写）多块不连续的内存</li><li>一块大内存，无法一次读完</li><li>tcp头的多次读写</li></ol><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 标准输入输出库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>      <span class="comment">// 文件控制库，包含文件打开函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// POSIX 系统服务库，包含 readv 函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>    <span class="comment">// I/O 向量库，包含 struct iovec 结构体的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./z5_io_uring/5_2_readv.cpp&quot;</span>,O_RDONLY); <span class="comment">// 打开文件，只读模式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">3</span>];   <span class="comment">// 定义一个 iovec 结构体数组，用于指定多个缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">33</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 定义第一个缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">65</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 定义第二个缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf3[<span class="number">129</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 定义第三个缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区地址和长度分别指定给 iov 数组的各个元素</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf1;         <span class="comment">// 第一个缓冲区的地址</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">sizeof</span> (buf1) - <span class="number">1</span>; <span class="comment">// 第一个缓冲区的长度</span></span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buf2;         <span class="comment">// 第二个缓冲区的地址</span></span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span> (buf2) - <span class="number">1</span>; <span class="comment">// 第二个缓冲区的长度</span></span><br><span class="line"></span><br><span class="line">    iov[<span class="number">2</span>].iov_base = buf3;         <span class="comment">// 第三个缓冲区的地址</span></span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="built_in">sizeof</span> (buf3) - <span class="number">1</span>; <span class="comment">// 第三个缓冲区的长度</span></span><br><span class="line"><span class="comment">//  ssize_t nread = writev(fd,iov,3);   // 使用 writev 函数向文件中写入多个缓冲区数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> nread = <span class="built_in">readv</span>(fd,iov,<span class="number">3</span>);   <span class="comment">// 使用 readv 函数从文件中读取数据到多个缓冲区中</span></span><br><span class="line">    <span class="keyword">if</span>(nread == <span class="number">-1</span>)&#123;                    <span class="comment">// 检查读取是否成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                      <span class="comment">// 如果读取失败，返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read %ld bytes : \n&quot;</span>,nread);  <span class="comment">// 输出读取的字节数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf1: %s \n&quot;</span>,buf1);            <span class="comment">// 输出第一个缓冲区的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2: %s \n&quot;</span>,buf2);            <span class="comment">// 输出第二个缓冲区的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf3: %s \n&quot;</span>,buf3);            <span class="comment">// 输出第三个缓冲区的内容</span></span><br><span class="line">    <span class="built_in">close</span>(fd);                              <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">// 返回程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-共享内存-1"><a href="#3-共享内存-1" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><h4 id="1-sendmsg"><a href="#1-sendmsg" class="headerlink" title="1. sendmsg"></a>1. sendmsg</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by lkh on 24-3-19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 开辟共享内存</span></span><br><span class="line">    <span class="type">int</span> shmemfd = <span class="built_in">shm_open</span>(<span class="string">&quot;0Ovice&quot;</span>,O_RDWR|O_CREAT|S_IRUSR|S_IWUSR,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == shmemfd)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shmemfd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 设置共享内存大小</span></span><br><span class="line">    <span class="built_in">ftruncate</span>(shmemfd,<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//3. 映射共享内存</span></span><br><span class="line">    <span class="type">void</span> *shmem_ptr;</span><br><span class="line">    shmem_ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>,<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED,shmemfd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(MAP_FAILED == shmem_ptr)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 向共享内存中写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;0Voice\n&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(shmem_ptr,str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="comment">//5. 初始化本地套节字</span></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_UNIX,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unix域套节字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path,<span class="string">&quot;/tmp/0voice.sock&quot;</span>,<span class="built_in">sizeof</span> (addr.sun_path) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//存储控制消息数组</span></span><br><span class="line">    <span class="type">char</span> cmsg_buffer[<span class="built_in">CMSG_SPACE</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>))] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//6. 设置消息 struct msghdr</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    msg.msg_name = &amp;addr;</span><br><span class="line">    msg.msg_namelen = <span class="built_in">sizeof</span> (addr);</span><br><span class="line">    msg.msg_control = cmsg_buffer;</span><br><span class="line">    msg.msg_controllen = <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//7. 设置控制 struct cmsghdr</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmsghdr</span> *cmsg = <span class="literal">NULL</span>;</span><br><span class="line">    cmsg = <span class="built_in">CMSG_FIRSTHDR</span>(&amp;msg);</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    cmsg-&gt;cmsg_len = <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    *(<span class="type">int</span>*) <span class="built_in">CMSG_DATA</span>(cmsg) = shmemfd;</span><br><span class="line">    <span class="comment">//8. 设置发送消息 iovec</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> io = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    io.iov_base = (<span class="type">void</span> *)str;</span><br><span class="line">    io.iov_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    msg.msg_iov = &amp;io;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//9. 发送消息到socket</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">sendmsg</span>(sockfd,&amp;msg,<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;sendmsg&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(shmemfd);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-recvmsg"><a href="#2-recvmsg" class="headerlink" title="2. recvmsg"></a>2. recvmsg</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span>         <span class="comment">// 包含 UNIX 套接字相关的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>     <span class="comment">// 包含套接字相关的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>          <span class="comment">// 包含标准 I/O 函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>       <span class="comment">// 包含内存映射相关的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>         <span class="comment">// 包含 POSIX 系统调用的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 创建用于存储消息的缓冲区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> io=&#123;<span class="number">0</span>&#125;; <span class="comment">// 创建一个 iovec 结构体，用于接收消息</span></span><br><span class="line">    io.iov_base = buffer; <span class="comment">// 设置消息缓冲区</span></span><br><span class="line">    io.iov_len = <span class="built_in">sizeof</span> (buffer); <span class="comment">// 设置消息缓冲区的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// 创建一个 UNIX 数据报套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr; <span class="comment">// 创建一个 sockaddr_un 结构体，用于绑定套接字地址</span></span><br><span class="line">    addr.sun_family = AF_UNIX; <span class="comment">// 设置地址族为 AF_UNIX</span></span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, <span class="string">&quot;/tmp/0voice.sock&quot;</span>, <span class="built_in">sizeof</span>(addr.sun_path)); <span class="comment">// 设置套接字路径</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)); <span class="comment">// 将套接字绑定到指定地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg = &#123;<span class="number">0</span>&#125;; <span class="comment">// 创建一个 msghdr 结构体，用于存储消息头部信息</span></span><br><span class="line">    <span class="type">char</span> cmsg_buffer[<span class="built_in">CMSG_SPACE</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>))]; <span class="comment">// 创建一个用于存储控制消息的缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(cmsg_buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(cmsg_buffer)); <span class="comment">// 初始化控制消息缓冲区</span></span><br><span class="line">    msg.msg_control = cmsg_buffer; <span class="comment">// 设置消息头部控制信息的缓冲区</span></span><br><span class="line">    msg.msg_controllen = <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 设置消息头部控制信息的长度</span></span><br><span class="line">    msg.msg_iov = &amp;io; <span class="comment">// 设置消息的数据部分</span></span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>; <span class="comment">// 设置消息的数据部分长度为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">recvmsg</span>(sockfd, &amp;msg, <span class="number">0</span>); <span class="comment">// 接收消息，并存储在 msg 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, buffer); <span class="comment">// 打印接收到的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmsghdr</span> *cmsg = <span class="literal">NULL</span>; <span class="comment">// 声明一个指向控制消息头部的指针，并初始化为空</span></span><br><span class="line">    cmsg = <span class="built_in">CMSG_FIRSTHDR</span>(&amp;msg); <span class="comment">// 获取第一个控制消息头部</span></span><br><span class="line">    <span class="keyword">if</span>(cmsg == <span class="literal">NULL</span> || cmsg-&gt;cmsg_len != <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;cmsg&quot;</span>); <span class="comment">// 如果控制消息为空或长度不正确，则打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回错误状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cmsg-&gt;cmsg_level != SOL_SOCKET || cmsg-&gt;cmsg_type != SCM_RIGHTS)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;cmsg-&gt;level , cmsg-&gt;type&quot;</span>); <span class="comment">// 如果控制消息的级别或类型不正确，则打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回错误状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shmem_fd; <span class="comment">// 声明一个文件描述符，用于接收控制消息中的文件描述符</span></span><br><span class="line">    shmem_fd = *(<span class="type">int</span> *) <span class="built_in">CMSG_DATA</span>(cmsg); <span class="comment">// 从控制消息中获取文件描述符</span></span><br><span class="line">    <span class="type">void</span> *shmem_ptr; <span class="comment">// 声明一个指针，用于指向内存映射区域的起始地址</span></span><br><span class="line">    shmem_ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_SHARED, shmem_fd, <span class="number">0</span>); <span class="comment">// 映射文件描述符指向的内存区域</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shared: %s\n&quot;</span>, (<span class="type">char</span>*)shmem_ptr); <span class="comment">// 打印映射的内存区域内容</span></span><br><span class="line">    <span class="built_in">munmap</span>(shmem_ptr, <span class="number">1024</span>); <span class="comment">// 取消映射内存区域</span></span><br><span class="line">    <span class="built_in">close</span>(shmem_fd); <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd); <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/Tattoo-Welkin/p/10335261.html">sendmsg 和 recvmsg</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Focus the Discrepancy：Intra-and Inter-Correlation Learning for Image Anomaly Detection</title>
      <link href="/2024/03/17/%E7%A7%91%E7%A0%94-8-FOD/"/>
      <url>/2024/03/17/%E7%A7%91%E7%A0%94-8-FOD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="FOD"><a href="#FOD" class="headerlink" title="FOD"></a>FOD</h1><blockquote><p>ICCV 2023</p></blockquote><blockquote><p>上海交通大学，Xincheng Yao，Ruoqi Li，,Chongyang Zhang（通讯）</p></blockquote><p><img src="https://telegraph-image-9wl.pages.dev/file/cfd73730f5420dccf8477.png" alt="image-20240317150522923"></p><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-现有AD方法没有结合patch间互补性"><a href="#1-现有AD方法没有结合patch间互补性" class="headerlink" title="1. 现有AD方法没有结合patch间互补性"></a>1. 现有AD方法没有结合patch间互补性</h3><p>​人类通过两个方面来识别异常:larger patch-wise representation discrepancies和weaker patch-to-normal-patch correlations。然而，以往的AD方法并没有充分结合这两个互补的方面来设计AD模型。</p><h3 id="2-现有AD未充分利用Transformer"><a href="#2-现有AD未充分利用Transformer" class="headerlink" title="2. 现有AD未充分利用Transformer"></a>2. 现有AD未充分利用Transformer</h3><blockquote><p>现有AD只用Transformer提取特征，未充分利用Transformer的长范围对齐能力</p></blockquote><p>​与这些作品不同的是，本文明确地利用Transformer的自注意力来建立图像内和图像间的相关性。每个patch的相关分布可以提供更多的空间上下文信息描述，从而揭示更复杂的语义异常模式。</p><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-FOD框架"><a href="#1-FOD框架" class="headerlink" title="1. FOD框架"></a>1. FOD框架</h3><blockquote><p>FOD 可以通过同时发现patch-wise、inter和intra的差异来有效地检测异常。</p></blockquote><h3 id="2-I2Correlation自注意机制"><a href="#2-I2Correlation自注意机制" class="headerlink" title="2. I2Correlation自注意机制"></a>2. I2Correlation自注意机制</h3><blockquote><p>I2Correlation是一种自我监督的方式与目标相关性明确地建立内部相关性和相互相关性。</p></blockquote><h3 id="3-熵约束"><a href="#3-熵约束" class="headerlink" title="3.熵约束"></a>3.熵约束</h3><blockquote><p>熵约束策略来进一步增强正常与异常的可分辨性。</p></blockquote><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-Patch-Wise-重构差异"><a href="#1-Patch-Wise-重构差异" class="headerlink" title="1. Patch-Wise 重构差异"></a>1. Patch-Wise 重构差异</h3><p>​我们构造一个Transformer网络来重建输入特征。结合域内intra和域间inter差异，重构目标特征。<br>$$<br>L_l &#x3D; |\hat{X} - X|_2 + \left(1 - \frac{\hat{X} \cdot X}{|\hat{X}|_2 |X|_2}\right)<br>$$<br>​$\hat{X}$ 表示重构特征，$X$ 表示输入原始特征。使用$L_2$距离和余弦相似度作为重构损失函数。</p><h3 id="2-Intra-和-Inter-差异"><a href="#2-Intra-和-Inter-差异" class="headerlink" title="2. Intra 和 Inter 差异"></a>2. Intra 和 Inter 差异</h3><h4 id="1-Target-Correlation"><a href="#1-Target-Correlation" class="headerlink" title="1. Target Correlation"></a>1. Target Correlation</h4><img src="https://telegraph-image-9wl.pages.dev/file/faf29c5cdac9f37b9135f.png" alt="image-20240317204119182" style="zoom:63%;" /><img src="https://telegraph-image-9wl.pages.dev/file/88c322c1fa7777be22d2c.png" alt="image-20240317204136081" style="zoom:67%;" /><h4 id="2-熵约束"><a href="#2-熵约束" class="headerlink" title="2. 熵约束"></a>2. 熵约束</h4><img src="https://telegraph-image-9wl.pages.dev/file/d371265e5b2978dc114ae.png" alt="image-20240317204259324" style="zoom:67%;" /><h4 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3. 损失函数"></a>3. 损失函数</h4><blockquote><p>inter</p></blockquote><p>$$<br>L_e &#x3D; -\lambda_1 \text{Div}(T^e, S^e) + \lambda_2 \text{Ent}(S^e)<br>$$</p><blockquote><p>intra</p></blockquote><p>$$<br>L_g &#x3D; -L_e &#x3D; \lambda_1 \text{Div}(T_g, S_g) - \lambda_2 \text{Ent}(S_g)<br>$$</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/590fc7fe70d6701755ab0.png" alt="image-20240317203918709" style="zoom:70%;" /><p>​MVTecAD数据集结果</p><p><a href="">论文链接</a></p><p><a href="">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment Any Anomaly without Training via Hybrid Prompt Regularization</title>
      <link href="/2024/03/17/%E7%A7%91%E7%A0%94-7-SAA/"/>
      <url>/2024/03/17/%E7%A7%91%E7%A0%94-7-SAA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="SAA"><a href="#SAA" class="headerlink" title="SAA+"></a>SAA+</h1><blockquote><p>arxiv2023</p></blockquote><blockquote><p>华中科技大学，Yunkang Cao、 Xiaohao Xu、Weiming Shen（通讯）</p></blockquote><p><img src="https://telegraph-image-9wl.pages.dev/file/4bed9cb9449e3204e1c13.png" alt="image-20240317143644706"></p><blockquote><ol><li>不需要训练</li><li>典型的提示工程</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-ZSAS（zero-shot-anomaly-segmentation-）方向大问题"><a href="#1-ZSAS（zero-shot-anomaly-segmentation-）方向大问题" class="headerlink" title="1. ZSAS（zero-shot anomaly segmentation,）方向大问题"></a>1. ZSAS（zero-shot anomaly segmentation,）方向大问题</h3><blockquote><p>现有的异常分割模型通常依赖于特定领域的微调，限制了它们在无数异常模式中的泛化。</p></blockquote><h3 id="2-预训练数据与测试数据域转移问题"><a href="#2-预训练数据与测试数据域转移问题" class="headerlink" title="2. 预训练数据与测试数据域转移问题"></a>2. 预训练数据与测试数据域转移问题</h3><blockquote><p>面对基础模型预训练数据分布与下游异常分割数据集之间的域转移，传统的语言提示可能会失效。</p></blockquote><p>​某些语言提示，如“异常”，可能无法检测到所需的异常区域。例如，如图2所示，所有“灯芯”都被SAA错误地识别为带有“异常”提示的异常。</p><h3 id="3-粗粒度上下文分割不准确"><a href="#3-粗粒度上下文分割不准确" class="headerlink" title="3. 粗粒度上下文分割不准确"></a>3. 粗粒度上下文分割不准确</h3><blockquote><p>目标的“异常”程度取决于对象上下文，这对于粗糙的粗粒度语言提示(例如“异常区域”)很难准确表达。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-引入专家知识"><a href="#1-引入专家知识" class="headerlink" title="1. 引入专家知识"></a>1. 引入专家知识</h3><blockquote><p>专家知识提供了与开放世界场景中目标相关的异常的详细描述。</p></blockquote><ol><li>引入详细的语言提示，解决预训练模型“歧义”问题。</li><li>引入属性提示，解决预训练模型对“count”、“area”等认识不足问题，即具有特定属性描述(如大小或位置)的对象时存在局限性。</li></ol><h3 id="2-利用图像上下文"><a href="#2-利用图像上下文" class="headerlink" title="2. 利用图像上下文"></a>2. 利用图像上下文</h3><blockquote><p>利用目标图像上下文可靠地识别和自适应校准异常分割预测[26,27]。通过利用目标图像中存在的丰富上下文信息，我们可以准确地将对象上下文与最终的异常预测联系起来</p></blockquote><h3 id="3-SAA-不需要训练"><a href="#3-SAA-不需要训练" class="headerlink" title="3. SAA+ 不需要训练"></a>3. SAA+ 不需要训练</h3><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-baseline"><a href="#1-baseline" class="headerlink" title="1. baseline"></a>1. baseline</h3><img src="https://telegraph-image-9wl.pages.dev/file/e6c6dd481ee95527a2d24.png" alt="image-20240317135510006" style="zoom:70%;" /><blockquote><p>GroundingDINO异常区域生成器</p></blockquote><p>​本文采用在大规模语言视觉数据集上进行预训练的GroundingDINO架构。该网络首先通过文本编码器和视觉编码器分别提取语言提示符和查询图像的特征。然后使用跨模态解码器以边界框的形式生成粗糙目标区域。</p><blockquote><p>SAM 异常区域分割</p></blockquote><p>​为了生成逐像素的异常分割结果，我们提出了异常区域细化器，将边界盒级异常候选区域细化为异常分割掩码集。</p><p>​使用了一个复杂的开放世界视觉分割基础模型，即SAM。该模型主要包括一个基于vit的主干网和一个提示条件掩码解码器。具体而言，该模型是在具有10亿个细粒度掩码的大规模图像分割数据集上进行训练的，在开集分割下实现了高质量的掩码生成能力。</p><h3 id="2-专家知识"><a href="#2-专家知识" class="headerlink" title="2. 专家知识"></a>2. 专家知识</h3><p>​尽管专家可能不会为新产品提供一个全面的潜在开放世界异常列表，但他们可以根据过去使用类似产品的经验确定一些候选产品。领域专家知识使我们能够将简单的“异常”提示细化为更详细地描述异常状态的更具体的提示。</p><blockquote><p>除了语言提示外，我们还引入了属性提示，以弥补现有基础模型[28]中对“count”和“area”[28]等特定属性缺乏认识的不足。</p></blockquote><h4 id="1-语言提示"><a href="#1-语言提示" class="headerlink" title="1. 语言提示"></a>1. 语言提示</h4><p>​为了描述潜在的开放世界异常，我们建议设计更精确的语言提示。这些提示分为两种类型:与类无关的和特定于类的提示。</p><blockquote><p>类通用的提示</p></blockquote><p>​“anomaly”、“defect”等适用于所有类的提示。</p><blockquote><p>特定类提示</p></blockquote><p>​用于补充具体的异常细节。使用预先训练的视觉语言数据集中已经使用的提示，例如“黑洞”和“白泡”，来查询所需的区域。</p><p>​这种方法将寻找异常区域的任务重新表述为定位具有特定异常状态表达式的对象，这比在对象上下文中识别“异常”更直接地利用基础模型。</p><h4 id="2-属性提示"><a href="#2-属性提示" class="headerlink" title="2. 属性提示"></a>2. 属性提示</h4><p>​当前的基础模型在查询具有特定属性描述(如大小或位置)的对象时存在局限性，这些属性描述对于描述异常非常重要，例如“电缆左侧的小黑洞”。</p><blockquote><p>异常位置</p></blockquote><p>​在推理过程中，期望异常位于感兴趣的对象内。然而，由于背景环境的影响，异常可能偶尔会出现在被检查对象之外。</p><p>​利用基础模型的开放世界检测能力来确定被检查对象的位置。随后，我们计算了潜在异常区域与被检测对象之间的交集。通过应用专家导出的IoU阈值，我们过滤掉IoU值低于该阈值的异常候选对象。</p><blockquote><p>异常区域</p></blockquote><p>​一般来说，异常应小于被检物体的尺寸。专家可以为所考虑的特定类型的异常提供一个合适的阈值area。区域与area不匹配的候选区域可以被过滤掉。</p><h3 id="3-图像上下文"><a href="#3-图像上下文" class="headerlink" title="3. 图像上下文"></a>3. 图像上下文</h3><h4 id="1-图像显著性提示"><a href="#1-图像显著性提示" class="headerlink" title="1. 图像显著性提示"></a>1. 图像显著性提示</h4><p>​人类可以通过异常区域与周围区域的差异来识别异常区域，即视觉显著性包含了指示异常程度的有价值的信息。因此，我们通过计算相应像素特征(f)与其N个最近邻之间的平均距离来计算输入图像的显著性映射(s)。<br>$$<br>s_{ij} &#x3D; \frac{1}{N} \sum_{f \in N_p(f_{ij})}(1 - \langle f_{ij}, f \rangle)<br>$$<br>​式中$(i, j)$为像素位置，$N_p(f_{ij})$为对应像素最近的N个邻居，$\langle f_{ij}, f \rangle$为余弦相似度。</p><h4 id="2-图像置信度提示"><a href="#2-图像置信度提示" class="headerlink" title="2. 图像置信度提示"></a>2. 图像置信度提示</h4><p>​提出异常置信度提示根据图像内容识别置信度得分最高的K个候选图像，并使用它们的平均值进行最终的异常区域检测。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p><img src="https://telegraph-image-9wl.pages.dev/file/92797c6fe5583f64f2e9a.png" alt="image-20240317144843342"></p><p><a href="https://arxiv.org/abs/2305.10724">论文链接</a></p><p><a href="https://github.com/caoyunkang/Segment-Any-Anomaly">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版</title>
      <link href="/2024/03/17/%E7%A7%91%E7%A0%94-%E6%A8%A1%E7%89%88/"/>
      <url>/2024/03/17/%E7%A7%91%E7%A0%94-%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="论文模型名"><a href="#论文模型名" class="headerlink" title="论文模型名"></a>论文模型名</h1><blockquote><p>论文期刊</p></blockquote><blockquote><p>研究团队</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/a37eea9b3846997e38fe5.jpg" alt="538E3925-331F-4561-BD04-4A42941D3CBB_1_105_c" style="zoom:80%;" /><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p><a href="">论文链接</a></p><p><a href="">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Industrial Image Anomaly Detection：A Survey</title>
      <link href="/2024/03/16/%E7%A7%91%E7%A0%94-12-Survey2024/"/>
      <url>/2024/03/16/%E7%A7%91%E7%A0%94-12-Survey2024/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="作者总结"><a href="#作者总结" class="headerlink" title="作者总结"></a>作者总结</h1><blockquote><p>MIR 2024</p></blockquote><blockquote><p>南方科技大学，Jiaqi Liu，Guoyang Xie</p></blockquote><h2 id="1-方法总结"><a href="#1-方法总结" class="headerlink" title="1. 方法总结"></a>1. 方法总结</h2><ol><li>对于图像级异常检测任务的识别，基于记忆库的方法是最有效的神经网络设计。然而，它们在检测像素级异常方面是不够的。</li><li>集成学习可以显著提高最先进的异常检测方法的性能。</li><li>SSPCAB[96]可以无缝集成到前沿方法中，显著提高基于重建的方法的性能。</li><li>few-shot IAD和普通IAD之间的差距正在缩小。换句话说，我们可以利用数据蒸馏算法来减少用于异常检测的数据集的数量。</li><li>MemSeg和DRAEM的有效性证明了分割模块在异常检测中的优越性。人工监督往往不如真实监督，用人工监督训练的分割模型往往表现较差。</li><li>AU-PR在分割任务中比AU-ROC更有价值</li></ol><h2 id="2-未来方向"><a href="#2-未来方向" class="headerlink" title="2. 未来方向"></a>2. 未来方向</h2><ol><li>多模态IAD数据集。</li><li>解决IAD的推理速度问题。</li><li>大多数IAD方法使用ImageNet预训练模型从工业图像中提取特征，这不可避免地导致特征漂移问题。因此，迫切需要为工业图像构建预训练模型。</li><li>无监督方法和有监督方法应该相辅相成，近年来有监督方法发展缓慢的主要原因是缺乏大量的标记数据集。因此，未来有必要提出具有像素级注释的全监督异常检测数据集。</li><li>在工业制造中，由于大多数生产线都是无故障的，因此很难收集到大量的异常样品。因此，未来应更多地关注异常合成方法。</li><li>有必要设计轻量级而高效的异常检测模型。</li><li>建立一个统一的工业和医学形象评价框架具有重要意义。图像异常检测算法主要分为工业图像异常检测和医学图像异常检测两大类。很少有研究探讨如何将这两项任务统一起来。造成这种情况的一个原因是医疗和工业图像数据集之间的领域差异，另一个原因是缺乏一个良好的基线和基准进行比较。</li></ol><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><img src="https://telegraph-image-9wl.pages.dev/file/017edd72f0a5a9500da0d.png" alt="image-20240316092632558" style="zoom:37%;" /><h2 id="1-特征嵌入-—-无监督"><a href="#1-特征嵌入-—-无监督" class="headerlink" title="1. 特征嵌入 —- 无监督"></a>1. 特征嵌入 —- 无监督</h2><h3 id="1-Teacher-student-architecture"><a href="#1-Teacher-student-architecture" class="headerlink" title="1. Teacher-student architecture"></a>1. Teacher-student architecture</h3><img src="https://telegraph-image-9wl.pages.dev/file/3a84e154cb29c151692eb.png" alt="image-20240316092850264" style="zoom:47%;" /><p>​这些方法的性能都很突出，但它们依赖于预训练模型。</p><p>​在训练过程中，教师模型向学生模型传授提取正态样本特征的知识。在推理过程中，教师网络和学生网络从测试集中提取的正常图像的特征具有可比性，而从测试集中提取的异常图像的特征则非常不同。通过比较两种网络生成的特征图，可以生成大小相同的异常评分图。然后，将异常分数图放大到与输入图像相同的比例，就可以得到输入图像各个位置的异常分数。</p><img src="https://telegraph-image-9wl.pages.dev/file/bec0b1a74a18c2580bc81.png" alt="image-20240316092922708" style="zoom:37%;" /><p>​多尺度蒸馏[STPM]；学生网络简单，教师网络复杂[MKD]；多对师生网络[RSTPM]；不对称师生网络[AST]；</p><h3 id="2-One-class-classification"><a href="#2-One-class-classification" class="headerlink" title="2. One-class classification"></a>2. One-class classification</h3><img src="https://telegraph-image-9wl.pages.dev/file/8a58cd93535c6e6d5f34f.png" alt="image-20240316093633430" style="zoom:47%;" /><p>​单类分类技术更多地依赖于异常样本。如果生成的异常样本质量较差，将严重影响该方法的性能。</p><p>​该方法在训练过程中找到一个超球来区分正常样本特征和异常样本特征。在推理过程中，该方法根据测试样本的特征与超球的相对位置来判断样本是否异常。由于训练集不包含异常样本，有些方法人为地生成异常样本以提高超球的精度。</p><p><img src="https://telegraph-image-9wl.pages.dev/file/bd25eef1fa21724e9542a.png" alt="image-20240316093706015"></p><p>​除了MemSeg，其他方法训练都依赖于SVDD 和 cross-entropy loss。</p><p>​图像分割成小块[PatchSVDD]；最小化超球体积[DSPSVDD]；提取多层次特征来提高异常语义信息[SESVDD]；更具解释性的全卷积网络[FCDD]；正常样本中&#x3D;&#x3D;生成负图像对&#x3D;&#x3D;[Yoa et al.]；傅立叶变换检测显著区域[Bai et al.]；前景背景分离[Qiu et al.]；获取目标轮廓辅助检测[Niu et al.]；剪切粘贴正常图像部分来生成异常图像[CutPaste]；正常图像特征存储在Memory中[MemSeg]</p><h3 id="3-Distribution-map"><a href="#3-Distribution-map" class="headerlink" title="3. Distribution map"></a>3. Distribution map</h3><img src="https://telegraph-image-9wl.pages.dev/file/a86d3ff1fdebd0f5e7ec2.png" alt="image-20240316094952235" style="zoom:47%;" /><p>​基于分布映射的方法需要一个合适的映射目标进行训练，而映射方法的选择会影响模型的性能。</p><p>​基于分布映射的方法与基于occ的方法非常相似，不同之处在于，基于occ的方法专注于寻找特征边界，而基于映射的方法则试图将特征映射到所需的分布中。</p><p>​首先使用一个强预训练的网络来提取正态图像的特征，然后使用映射模块将提取的特征映射到高斯分布。这种分布将偏离评估过程中出现的异常图像的特征。根据偏差程度，可以计算出异常概率。</p><p>​归一化流(NF)是一种通过一系列可逆映射变换概率密度来构造复杂分布的技术，NF方法从预训练模型(如ResNet或Swin Transformer)的正态图像中提取特征，并在训练阶段将特征分布转换为高斯分布。在测试阶段，异常图像经过NF处理后的特征会偏离训练阶段的高斯分布，这是异常分类最重要的原则。</p><img src="https://telegraph-image-9wl.pages.dev/file/7d35964f3319ed64b6858.png" alt="image-20240316094940569" style="zoom:37%;" /><p>​生成多变量高斯分布，减轻灾难性遗忘[Rippel et al.]；双向和多层双向预训练特征映射[PFM]；位置编码增强特征映射[Wan et al.]；从粗到精的对齐[FYD]；</p><h3 id="4-Memory-bank"><a href="#4-Memory-bank" class="headerlink" title="4. Memory bank"></a>4. Memory bank</h3><img src="https://telegraph-image-9wl.pages.dev/file/71a98832747b6e1b18c49.png" alt="image-20240316095937141" style="zoom:47%;" /><p>​基于记忆的方法通常不需要损失函数进行训练，并且模型构建速度很快。它们的性能由强大的预训练网络和额外的内存空间保证，这种方法目前在IAD任务中是最有效的。</p><p>​基于内存库的方法和基于occ的方法之间的主要区别是，基于内存的方法(如SVDD)需要额外的内存空间来存储图像特征。</p><p>​这些方法需要最少的网络训练，只需要对收集到的法线图像特征进行采样或映射进行推理。在推理过程中，测试图像的特征与记忆库中的特征进行比较。测试图像的异常概率等于与存储库中正常特征的空间距离。</p><p>​PatchCore是工业图像AD的一个重大进步，它显著提高了MVTec AD的性能。Patchcore包含两个特殊点。首先，对patchcore的存储库进行核重集下采样，以确保在实现性能最大化的同时降低推理成本。然后，Patchcore根据测试样本在其内存库中的最近邻居特征与其他特征之间的距离来确定测试样本是否异常。这个重新加权的过程使patchcore更加健壮。</p><img src="https://telegraph-image-9wl.pages.dev/file/7c33067a6984b8bb9160b.png" alt="image-20240316100022108" style="zoom:37%;" /><p>​多分辨率特征的对应关系获得像素分割[SPADE]；多元高斯分布构建正常类概率表[PaDiM]</p><h2 id="2-重构-—-无监督"><a href="#2-重构-—-无监督" class="headerlink" title="2. 重构 —- 无监督"></a>2. 重构 —- 无监督</h2><img src="https://telegraph-image-9wl.pages.dev/file/bfc70572b9b90636ff6f4.png" alt="image-20240316100854478" style="zoom:47%;" /><p>​基于重建的方法主要是自训练编码器和解码器来重建图像以进行异常检测，这使得它们对预训练模型的依赖程度降低，并提高了检测异常的能力。然而，由于无法提取高级语义特征，其图像分类能力较差。</p><p>​在训练过程中，将正常或异常的图像发送到重构网络，利用重构损失函数指导重构网络的训练。最后，重建网络能够以类似于原始正常图像的方式恢复重建图像。在推理阶段，比较模型将原始图像与重建图像进行比较，从而产生预测。</p><p>​与特征嵌入方法的多样性相比，大多数基于重构的方法只是在重构网络的构建上有所不同。基于重建的方法在像素级上优于特征嵌入方法，因为它们能够通过像素级比较识别异常。</p><p>​大多数基于重建的方法都是从头开始训练，没有使用鲁棒预训练模型，这导致与图像级特征嵌入相比性能较差。</p><h3 id="1-Autoencoder"><a href="#1-Autoencoder" class="headerlink" title="1. Autoencoder"></a>1. Autoencoder</h3><p>​AutoEncoder 是AD最普遍的重建网络。许多其他重建网络也包括编码器和解码器组件。</p><p>​重建图像与原始图像在风格上存在规律性差异，导致过度检测。</p><img src="https://telegraph-image-9wl.pages.dev/file/9f12e3e1c3fabdd218b55.png" alt="image-20240316101050798" style="zoom:87%;" /><h3 id="2-Generative-adversarial-networks"><a href="#2-Generative-adversarial-networks" class="headerlink" title="2. Generative adversarial networks"></a>2. Generative adversarial networks</h3><p>​基于生成式对抗网络(generative adversarial networks, GANs)的重建模型的稳定性不如AE的重建模型，但在以下描述的一些场景中，判别网络的效果更好。</p><img src="https://telegraph-image-9wl.pages.dev/file/4b9412cee4136ebff8336.png" alt="image-20240316101515075" style="zoom:50%;" /><h3 id="3-Transformer"><a href="#3-Transformer" class="headerlink" title="3. Transformer"></a>3. Transformer</h3><p>​Transformer具有更高的全局信息表示能力，这使得它有可能超越AE，</p><p><img src="https://telegraph-image-9wl.pages.dev/file/050dfcac3f570092762ff.png" alt="image-20240316101558600"></p><p><img src="https://telegraph-image-9wl.pages.dev/file/8dfb906b20d60108fa355.png" alt="image-20240316101608951"></p><h3 id="4-Diffusion-model"><a href="#4-Diffusion-model" class="headerlink" title="4. Diffusion model"></a>4. Diffusion model</h3><img src="https://telegraph-image-9wl.pages.dev/file/66593444aef480fe0cc7f.png" alt="image-20240316101648184" style="zoom:50%;" /><h2 id="2-有监督"><a href="#2-有监督" class="headerlink" title="2. 有监督"></a>2. 有监督</h2><p>​尽管异常数据种类繁多，采集难度大，但在现实场景中仍然有可能采集到异常样本。因此，如何利用少量的异常样本和大量的正常样本训练异常检测模型成为一些研究的重点。</p><h1 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h1><h2 id="1-Few-shot-anomaly-detection"><a href="#1-Few-shot-anomaly-detection" class="headerlink" title="1. Few-shot anomaly detection"></a>1. Few-shot anomaly detection</h2><p>​few-shot 对于数据收集和数据标注具有重要意义，对实际应用有很大影响。一方面，通过研究少量学习，可以降低工业产品的数据采集和数据标注成本。另一方面，我们可以从数据的角度来解决问题，研究什么样的数据对工业图像异常检测最有价值。</p><p>​第一种是元学习。换句话说，这种设置需要大量的图像作为元训练数据集。第二种设置依赖于普通的少量图像学习。</p><p>​ZSAD（zero-shot anomaly detection）的目标是利用大型模型的泛化能力，在不进行任何训练的情况下解决异常检测问题，从而完全消除数据收集和标注的成本。</p><h2 id="2-Noisy-anomaly-detection"><a href="#2-Noisy-anomaly-detection" class="headerlink" title="2. Noisy anomaly detection"></a>2. Noisy anomaly detection</h2><p>​噪声学习是异常检测中的一个经典问题。通过研究噪声学习下的异常检测，可以避免标记错误造成的性能损失，减少异常检测中的误检。</p><p>​上述大多数方法尚未在实际工业图像数据集上得到验证。换句话说，现有的异常检测方法的有效性可能不适合工业制造。</p><h2 id="3-3D-anomaly-detection"><a href="#3-3D-anomaly-detection" class="headerlink" title="3. 3D anomaly detection"></a>3. 3D anomaly detection</h2><p>​3D异常检测可以利用更多的空间信息，从而检测到一些RGB图像无法包含的信息。在一些特殊的光照环境下，或者对于一些对颜色信息不敏感的异常，3D异常检测可以显示出明显的优势。</p><p>​业制造中的3D数据集由点云组成，这意味着当前的3D IAD方法无法直接部署在工业制造中。</p><h2 id="4-Anomaly-synthesis"><a href="#4-Anomaly-synthesis" class="headerlink" title="4. Anomaly synthesis"></a>4. Anomaly synthesis</h2><p>​通过人工合成异常，可以提高有限数据下模型的性能。本研究是对少数镜头研究的补充。</p><p>​few-shot学习研究的是在数据固定的情况下如何改进模型，本研究研究的是在模型固定的情况下如何人为增加可信数据来提高模型的性能。两者都可以减少数据收集和标签的成本。</p><h1 id="数据集和指标"><a href="#数据集和指标" class="headerlink" title="数据集和指标"></a>数据集和指标</h1><h2 id="1-数据集"><a href="#1-数据集" class="headerlink" title="1. 数据集"></a>1. 数据集</h2><p>​IAD数据集的数量和大小都在逐渐增加，但大多数数据集并不是在真实的生产线上生成的。有希望的替代方法是充分利用工业模拟器生成异常图像，可能减少学术研究与工业制造需求之间的差距。</p><img src="https://telegraph-image-9wl.pages.dev/file/d1753e2147fe378558ca5.png" alt="image-20240316102911439" style="zoom:50%;" /><h2 id="2-指标"><a href="#2-指标" class="headerlink" title="2. 指标"></a>2. 指标</h2><img src="https://telegraph-image-9wl.pages.dev/file/1cbc6ff7372106d6a11ca.png" alt="image-20240316102955013" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户态TCP IP协议栈设计实现</title>
      <link href="/2024/03/13/C-%E9%9B%B6%E5%A3%B0linux-18-%E7%94%A8%E6%88%B7%E6%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/03/13/C-%E9%9B%B6%E5%A3%B0linux-18-%E7%94%A8%E6%88%B7%E6%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>#用户态TCP IP协议栈设计实现</p><h2 id="1-dpdk简介"><a href="#1-dpdk简介" class="headerlink" title="1. dpdk简介"></a>1. dpdk简介</h2><h3 id="1-tcp-ip协议栈如何设计？"><a href="#1-tcp-ip协议栈如何设计？" class="headerlink" title="1. tcp&#x2F;ip协议栈如何设计？"></a>1. tcp&#x2F;ip协议栈如何设计？</h3><blockquote><p>如何拿到网络数据?（网卡的原生数据包）</p></blockquote><ol><li>原生socket </li><li>netmap（长年未更新）</li><li>dpdk</li></ol><img src="https://telegraph-image-9wl.pages.dev/file/a555144d75e28b0bc034a.png" alt="image-20240313161739179" style="zoom:45%;" /><ul><li>&#x3D;&#x3D;sk_buff&#x3D;&#x3D;缓存NIC接受到数据包。</li></ul><blockquote><p>dpdk作用</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/a5a3d45fa0661ddd88bb0.png" alt="image-20240313161923833" style="zoom:45%;" /><ul><li>接管物理网卡的 数据，方便协议栈的设计实现</li></ul><blockquote><p>dpdk的性能提升</p></blockquote><ul><li><p>dpdk对&#x3D;&#x3D;提高网络并发量无关&#x3D;&#x3D;。</p></li><li><p>dpdk&#x3D;&#x3D;不能解决低延迟问题&#x3D;&#x3D;。</p></li><li><p>设置&#x3D;&#x3D;hugepage提高数据吞吐量&#x3D;&#x3D;，2M或1G（正常页是4K）</p></li><li><p>多队列网卡的TX、RX是分开处理的。</p></li><li><p>多核处理多队列。</p></li></ul><h2 id="2-dpdk编程"><a href="#2-dpdk编程" class="headerlink" title="2. dpdk编程"></a>2. dpdk编程</h2><h3 id="1-rte-eal-init"><a href="#1-rte-eal-init" class="headerlink" title="1. rte_eal_init"></a>1. rte_eal_init</h3><blockquote><p>初始化</p></blockquote><ul><li>函数初始化EAL（环境抽象层）。</li><li>EAL是DPDK的基础部分，负责管理CPU核、内存、设备驱动和其他系统资源的低层次细节。</li><li><code>rte_eal_init</code>必须是应用程序调用的第一个DPDK函数，用于准备执行环境。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rte_eal_init</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> argc, <span class="comment">//命令行参数的数量。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span> **argv<span class="comment">//命令行参数的字符串数组。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功0，失败负值错误码</span></span><br></pre></td></tr></table></figure><h3 id="2-rte-pktmbuf-pool-create"><a href="#2-rte-pktmbuf-pool-create" class="headerlink" title="2. rte_pktmbuf_pool_create"></a>2. rte_pktmbuf_pool_create</h3><blockquote><p>内存池 mbuff（类似于sk_buff）</p></blockquote><ul><li>创建一个mbuf（消息缓冲）内存池。</li><li>mbuf是DPDK中用于存储和传输数据包的基本结构。这个内存池用于快速分配和回收mbuf，以支持高性能的数据包处理。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mempool</span>* <span class="built_in">rte_pktmbuf_pool_create</span>(</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name,<span class="comment">//内存池名称</span></span><br><span class="line">    <span class="type">unsigned</span> n,<span class="comment">//内存池mbuff数量</span></span><br><span class="line">    <span class="type">unsigned</span> cache_size,<span class="comment">//每个核心缓存大小</span></span><br><span class="line">    <span class="type">uint16_t</span> priv_size,<span class="comment">//每个mbuff私有数据区大小</span></span><br><span class="line">    <span class="type">uint16_t</span> data_room_size,<span class="comment">//每个mbuff的数据区大小</span></span><br><span class="line">    <span class="type">int</span> socket_id<span class="comment">//内存吃分配在那个NUMA节点的标识符</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//成功返回内存池指针，失败NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mempool</span> *mbufpool = <span class="built_in">rte_pktmbuf_pool_create</span>(<span class="string">&quot;mbuf&quot;</span>,</span><br><span class="line">                        <span class="number">4096</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                        RTE_MBUF_DEFAULT_BUF_SIZE,</span><br><span class="line">                        <span class="built_in">rte_socket_id</span>());</span><br></pre></td></tr></table></figure><h3 id="3-rte-eth-dev-configure"><a href="#3-rte-eth-dev-configure" class="headerlink" title="3. rte_eth_dev_configure"></a>3. rte_eth_dev_configure</h3><blockquote><p>配置以太网设备</p></blockquote><ul><li>指定的以太网设备配置接收和发送队列</li><li>设置特定的网络参数，例如RSS（接收端分散）、过滤规则等</li><li>初始化指定的端口，准备它们以进行数据包的接收和发送操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rte_eth_dev_configure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id, <span class="comment">// 网络设备端口标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> nb_rx_queue, <span class="comment">// 接收队列的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> nb_tx_queue, <span class="comment">// 发送队列的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> rte_eth_conf *eth_conf <span class="comment">// 指向配置结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功0，失败负值错误码</span></span><br></pre></td></tr></table></figure><h3 id="4-struct-rte-eth-conf"><a href="#4-struct-rte-eth-conf" class="headerlink" title="4. struct rte_eth_conf"></a>4. struct rte_eth_conf</h3><blockquote><p>定义以太网设备配置默认结构体</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">rte_eth_conf</span> port_conf_default = &#123;</span><br><span class="line">    <span class="comment">//.rxmode是一个rte_eth_rxmode结构体，用于配置接收模式的参数。</span></span><br><span class="line">    .rxmode = &#123;</span><br><span class="line">        .max_rx_pkt_len = RTE_ETHER_MAX_LEN, <span class="comment">// 设置最大接收包长度为定义的RTE_ETHER_MAX_LEN值</span></span><br><span class="line">        .offloads = <span class="number">0</span>, <span class="comment">// 默认情况下不启用任何特定的接收模式硬件卸载功能</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//设置发送模式</span></span><br><span class="line">     .txmode = &#123;</span><br><span class="line">        .offloads = <span class="number">0</span>, <span class="comment">// 默认不启用任何发送模式硬件卸载功能</span></span><br><span class="line">        <span class="comment">// 根据需要，可以在这里设置其他发送模式参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他配置项可以根据需要添加</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_eth_conf</span> port_conf = port_conf_default</span><br><span class="line"><span class="built_in">rte_eth_dev_configure</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,&amp;port_conf);</span><br></pre></td></tr></table></figure><h3 id="5-rte-eth-tx-queue-setup"><a href="#5-rte-eth-tx-queue-setup" class="headerlink" title="5. rte_eth_tx_queue_setup"></a>5. rte_eth_tx_queue_setup</h3><blockquote><p>设置DPDK中的以太网设备的发送队列</p></blockquote><ul><li>为指定的网络设备端口配置一个发送队列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rte_eth_tx_queue_setup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id,            <span class="comment">// 网络设备端口标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> tx_queue_id,        <span class="comment">// 要配置的发送队列的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> nb_tx_desc,         <span class="comment">// 发送描述符的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">int</span> socket_id,      <span class="comment">// NUMA节点的socket ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> rte_eth_txconf *tx_conf <span class="comment">// 发送队列配置</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功0，失败负值错误码 </span></span><br></pre></td></tr></table></figure><h3 id="6-rte-eth-tx-queue-setup"><a href="#6-rte-eth-tx-queue-setup" class="headerlink" title="6. rte_eth_tx_queue_setup"></a>6. rte_eth_tx_queue_setup</h3><blockquote><p>设置DPDK中的以太网设备的接收队列</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rte_eth_rx_queue_setup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id,            <span class="comment">// 网络设备端口标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> rx_queue_id,        <span class="comment">// 要配置的接收队列的ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> nb_rx_desc,         <span class="comment">// 接收描述符的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">int</span> socket_id,      <span class="comment">// NUMA节点的socket ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> rte_eth_rxconf *rx_conf, <span class="comment">// 接收队列配置</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> rte_mempool *mbuf_pool         <span class="comment">// Mbuf池</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="built_in">rte_eth_rx_queue_setup</span>(</span><br><span class="line">    <span class="number">0</span>,    <span class="comment">// 端口ID，之前定义的全局变量</span></span><br><span class="line">    <span class="number">0</span>,            <span class="comment">// 队列索引，这里配置第一个接收队列</span></span><br><span class="line">    <span class="number">128</span>,          <span class="comment">// 队列深度，即这个队列中有多少个描述符</span></span><br><span class="line">    <span class="built_in">rte_socket_id</span>(),  <span class="comment">// 使用当前执行环境的NUMA节点</span></span><br><span class="line">    <span class="literal">NULL</span>,         <span class="comment">// 使用默认的接收队列配置</span></span><br><span class="line">    mbuf_pool     <span class="comment">// 之前创建的mbuf池的指针</span></span><br><span class="line">);   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-rte-eth-dev-start"><a href="#7-rte-eth-dev-start" class="headerlink" title="7. rte_eth_dev_start"></a>7. rte_eth_dev_start</h3><blockquote><p>启动一个指定的以太网设备</p></blockquote><ul><li>在调用这个函数之前，应该完成<code>rte_eth_dev_configure</code>配置设备参数、通过<code>rte_eth_rx_queue_setup</code>和<code>rte_eth_tx_queue_setup</code>设置接收和发送队列以及分配足够的内存缓冲池（mbuf pools）。</li><li>初始化网络设备的硬件队列。</li><li>启动RX和TX数据处理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rte_eth_dev_start</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id<span class="comment">//要启动的以太网设备id</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功0，失败负值错误码 </span></span><br></pre></td></tr></table></figure><h3 id="8-rte-eth-rx-burst"><a href="#8-rte-eth-rx-burst" class="headerlink" title="8. rte_eth_rx_burst"></a>8. rte_eth_rx_burst</h3><ul><li>从指定端口的指定接收队列中批量接收数据包。</li><li>接收到的数据包以<code>struct rte_mbuf</code>结构的形式存储，每个结构代表一个接收到的数据包。</li><li>此函数为非阻塞调用，如果接收队列中没有数据包可用，它将立即返回。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">rte_eth_rx_burst</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id,             <span class="comment">// 网络设备端口标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> queue_id,            <span class="comment">// 从中接收数据包的队列ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> rte_mbuf **rx_pkts,    <span class="comment">// 存储接收到的数据包的指针数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint16_t</span> nb_pkts        <span class="comment">// 尝试从接收队列中获取的最大数据包数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功接收数据包数量（0~nb_pkts），没有数据包则0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *mbufs[<span class="number">32</span>];<span class="comment">//用于接收数据包的指针数组</span></span><br><span class="line"><span class="type">unsigned</span> num_recv = <span class="built_in">rte_eth_rx_burst</span>(<span class="number">0</span>,<span class="number">0</span>,mbufs,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//rte_free();mbufs不用释放，后续会一直接收发送数据。</span></span><br></pre></td></tr></table></figure><h3 id="9-rte-eth-tx-burst"><a href="#9-rte-eth-tx-burst" class="headerlink" title="9. rte_eth_tx_burst"></a>9. rte_eth_tx_burst</h3><ul><li>将<code>nb_pkts</code>个数据包发送到指定的网络设备的发送队列中。</li><li>数据包以<code>struct rte_mbuf</code>的形式提供，每个<code>struct rte_mbuf</code>代表一个待发送的数据包。</li><li>此函数执行非阻塞操作，如果发送队列没有足够的空间容纳所有待发送的数据包，它将只发送部分数据包。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">rte_eth_tx_burst</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> port_id,              <span class="comment">// 网络设备端口标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> tx_queue_id,          <span class="comment">// 要发送到的队列ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> rte_mbuf **tx_pkts,     <span class="comment">// 指向待发送数据包的指针数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint16_t</span> nb_pkts               <span class="comment">// 待发送数据包的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功发送数据包数量（0~nb_pkts），没有数据包则0</span></span><br></pre></td></tr></table></figure><h3 id="10-rte-free"><a href="#10-rte-free" class="headerlink" title="10. rte_free"></a>10. rte_free</h3><ul><li>释放由<code>rte_malloc</code>、<code>rte_zmalloc</code>、<code>rte_malloc_socket</code>等函数分配的内存。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rte_free</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *ptr<span class="comment">//ptr: 指向之前分配的内存的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="11-struct-rte-eth-hdr"><a href="#11-struct-rte-eth-hdr" class="headerlink" title="11. struct rte_eth_hdr"></a>11. struct rte_eth_hdr</h3><ul><li>来表示以太网头部的结构体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_ether_hdr</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rte_ether_addr</span> d_addr; <span class="comment">// 目标MAC地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rte_ether_addr</span> s_addr; <span class="comment">// 源MAC地址</span></span><br><span class="line">    <span class="type">uint16_t</span> ether_type;          <span class="comment">// 以太网类型（比如IPv4、IPv6、ARP等）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="12-rte-pktmbuf-mtod"><a href="#12-rte-pktmbuf-mtod" class="headerlink" title="12. rte_pktmbuf_mtod"></a>12. rte_pktmbuf_mtod</h3><ul><li>用于将指向<code>struct rte_mbuf</code>的指针转换为指向数据包内容的指针的&#x3D;&#x3D;宏&#x3D;&#x3D;</li><li>直接访问和修改数据包的内容，如读取或设置以太网头部、IP头部等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rte_pktmbuf_mtod(m, t) </span></span><br><span class="line">((t)((<span class="type">char</span> *)(m)-&gt;buf_addr + (m)-&gt;data_off))</span><br><span class="line"><span class="comment">//m: 是指向struct rte_mbuf的指针，代表一个数据包。</span></span><br><span class="line"><span class="comment">//t: 是你想要转换到的数据类型的指针，例如，如果你想要获取指向以太网头部的指针，t应该是struct rte_ether_hdr *。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rte_eth_hdr</span> *ehdr = </span><br><span class="line">    <span class="built_in">rte_pktmbuf_mtod</span>(mbufs[i],<span class="keyword">struct</span> rte_eth_hdr *);</span><br></pre></td></tr></table></figure><h3 id="13-rte-pktmbuf-mtod-offset"><a href="#13-rte-pktmbuf-mtod-offset" class="headerlink" title="13. rte_pktmbuf_mtod_offset"></a>13. rte_pktmbuf_mtod_offset</h3><ul><li>用于将一个数据包缓冲区（mbuf）中的数据指针加上指定的偏移量，然后将结果转换为给定类型的指针的&#x3D;&#x3D;宏&#x3D;&#x3D;。</li><li>从mbuf的数据段中的任意位置开始访问数据，而不仅仅是从头部开始。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rte_pktmbuf_mtod_offset(m, t, o) </span></span><br><span class="line">((t)((<span class="type">char</span> *)<span class="built_in">rte_pktmbuf_mtod</span>((m), <span class="type">void</span> *) + (o)))</span><br><span class="line"><span class="comment">//m：指向rte_mbuf结构的指针，表示要访问的数据包缓冲区。</span></span><br><span class="line"><span class="comment">//t：要转换成的目标类型的指针。通常是网络头部结构体，如struct rte_ether_hdr *。</span></span><br><span class="line"><span class="comment">//o：从mbuf数据开始的偏移量（以字节为单位），指示从哪里开始转换数据</span></span><br></pre></td></tr></table></figure><h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3. 源码"></a>3. 源码</h2><p>###1. UDP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_mbuf.h&gt;</span> <span class="comment">// 包含处理mbuf的功能，mbuf是DPDK中用于存储数据包的结构。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_eal.h&gt;</span> <span class="comment">// 包含初始化EAL（环境抽象层）的功能，EAL是DPDK应用程序与硬件交互的基础。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rte_ethdev.h&gt;</span> <span class="comment">// 包含配置和操作以太网设备的功能。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含网络字节序转换函数等网络相关功能的标准C库头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BURST_SIZE 32 <span class="comment">// 定义一次批量处理的最大数据包数量。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MBUF_COUNT 4096 <span class="comment">// 定义mbuf池中mbuf的数量。</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gDpdkPortId = <span class="number">0</span>; <span class="comment">// 全局变量，定义要使用的DPDK端口ID。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义端口的默认配置。</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">rte_eth_conf</span> port_conf_default = &#123;</span><br><span class="line">        .rxmode = &#123;.max_rx_pkt_len  = RTE_ETHER_MAX_LEN&#125; <span class="comment">// 设置接收模式的最大接收包长。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化EAL。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rte_eal_init</span>(argc,argv)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">rte_exit</span>(EXIT_FAILURE,<span class="string">&quot;failed&quot;</span>); <span class="comment">// EAL初始化失败则退出程序。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个mbuf池用于存储接收到的数据包。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rte_mempool</span> *mbuf_pool = <span class="built_in">rte_pktmbuf_pool_create</span>(<span class="string">&quot;mbuf&quot;</span>,</span><br><span class="line">                            MBUF_COUNT,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                            RTE_MBUF_DEFAULT_BUF_SIZE,</span><br><span class="line">                            <span class="built_in">rte_socket_id</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rte_eth_conf</span> port_conf = port_conf_default; <span class="comment">// 使用默认端口配置。</span></span><br><span class="line">    <span class="type">int</span> num_rx_queues = <span class="number">1</span>; <span class="comment">// 接收队列数量设置为1。</span></span><br><span class="line">    <span class="type">int</span> num_tx_queues = <span class="number">0</span>; <span class="comment">// 发送队列数量设置为0（此示例不发送数据包）。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置DPDK端口。</span></span><br><span class="line">    <span class="built_in">rte_eth_dev_configure</span>(gDpdkPortId,num_rx_queues,num_tx_queues,&amp;port_conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接收队列。</span></span><br><span class="line">    <span class="built_in">rte_eth_rx_queue_setup</span>(gDpdkPortId,<span class="number">0</span>,<span class="number">128</span>,<span class="built_in">rte_eth_dev_socket_id</span>(gDpdkPortId),</span><br><span class="line">                           <span class="literal">NULL</span>,mbuf_pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动DPDK端口。</span></span><br><span class="line">    <span class="built_in">rte_eth_dev_start</span>(gDpdkPortId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">rte_mbuf</span> *mbufs[BURST_SIZE]; <span class="comment">// 创建一个数组用于存储接收到的数据包mbuf。</span></span><br><span class="line">        <span class="type">unsigned</span> num_recv = <span class="built_in">rte_eth_rx_burst</span>(<span class="number">0</span>,<span class="number">0</span>,mbufs,BURST_SIZE); <span class="comment">// 批量接收数据包。</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num_recv &gt; BURST_SIZE)&#123;</span><br><span class="line">            <span class="built_in">rte_exit</span>(EXIT_FAILURE,<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_recv;i++)&#123; <span class="comment">// 遍历所有接收到的数据包。</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">rte_eth_hdr</span> *ehdr = <span class="built_in">rte_pktmbuf_mtod</span>(mbufs[i],<span class="keyword">struct</span> rte_eth_hdr *);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里应该使用 rte_cpu_to_be_16 而不是 htos，并且是 ether_type 而不是 ehter_type。</span></span><br><span class="line">            <span class="keyword">if</span>(ehdr-&gt;ether_type == <span class="built_in">rte_cpu_to_be_16</span>(RTE_ETHER_TYPE_IPV4))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算IP头部的正确位置。</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">rte_ipv4_hdr</span> *iphdr = <span class="built_in">rte_pktmbuf_mtod_offset</span>(mbufs[i], <span class="keyword">struct</span> rte_ipv4_hdr *, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> rte_eth_hdr));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查协议类型是否为UDP。</span></span><br><span class="line">                <span class="keyword">if</span>(iphdr-&gt;next_proto_id == IPPROTO_UDP)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取到UDP头部。</span></span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">rte_udp_hdr</span> *udphdr = (<span class="keyword">struct</span> rte_udp_hdr *)(iphdr + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取UDP数据段长度。</span></span><br><span class="line">                    <span class="type">uint16_t</span> length = <span class="built_in">ntohs</span>(udphdr-&gt;dgram_len);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 确保字符串以NULL结尾（这对于非字符串数据可能是不安全的）。</span></span><br><span class="line">                    *((<span class="type">char</span> *)udphdr + length) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印UDP数据内容。</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;data: %s\n&quot;</span>,(<span class="type">char</span>*)(udphdr+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_51011672/article/details/130087497">dpdk环境配置</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toward Generalist Anomaly Detection via In-context Residual Learning with Few-shot Sample Prompts</title>
      <link href="/2024/03/13/%E7%A7%91%E7%A0%94-6-InCTRL/"/>
      <url>/2024/03/13/%E7%A7%91%E7%A0%94-6-InCTRL/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="InCTRL"><a href="#InCTRL" class="headerlink" title="InCTRL"></a>InCTRL</h1><blockquote><p>CVPR2024</p></blockquote><blockquote><p>新加坡管理大学，Jiawen Zhu 、Guansong Pang</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/d4614dfd2ab10e0213929.png" alt="image-20240313100048752" style="zoom:50%;" /><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-工业异常检测泛化问题"><a href="#1-工业异常检测泛化问题" class="headerlink" title="1. 工业异常检测泛化问题"></a>1. 工业异常检测泛化问题</h3><blockquote><p>当前的AD范式侧重于在训练数据上单独构建一个模型</p></blockquote><p>​它们在应用场景中变得不可行，其中由于数据隐私问题（例如，由于机器遗忘而在训练模型时使用这些数据）或在部署新应用程序时大规模训练数据不可用，不允许在目标数据集上进行训练。</p><h3 id="2-CLIP用于工业检测问题"><a href="#2-CLIP用于工业检测问题" class="headerlink" title="2. CLIP用于工业检测问题"></a>2. CLIP用于工业检测问题</h3><blockquote><p>模型的一个显著限制是它们依赖于一组专门针对缺陷的手动提示</p></blockquote><p>​这种依赖限制了它们的适用性，使其难以扩展到检测其他数据域中的异常，例如，医学图像异常或一类或多类设置中的语义异常。</p><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-few-shot"><a href="#1-few-shot" class="headerlink" title="1. few-shot"></a>1. few-shot</h3><blockquote><p>现实世界的应用中，通常很容易获得少镜头正常图像</p></blockquote><p>​这几个镜头样本不用于模型训练&#x2F;调整；它们只是用作样本提示，用于在推理过程中对测试图像进行异常评分。</p><p>​本文方法与当前的少镜头AD方法有根本不同，后者使用这些目标样本及其广泛的增强版本来训练检测模型，这可能导致目标数据集的过拟合，并且无法推广到其他数据集。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p><a href="https://arxiv.org/abs/2403.06495">论文链接</a></p><p><a href="https://github.com/mala-lab/InCTRL">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git push 没有访问权限</title>
      <link href="/2024/03/11/C-%E9%97%AE%E9%A2%98-5-git-push-%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/"/>
      <url>/2024/03/11/C-%E9%97%AE%E9%A2%98-5-git-push-%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><blockquote><p>在服务器push代码到github上时，报错git push 没有访问权限</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/01b33e676ca322a0d6518.png" alt="image-20240311125402665" style="zoom:67%;" /><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><h3 id="1-生成ssh密钥"><a href="#1-生成ssh密钥" class="headerlink" title="1. 生成ssh密钥"></a>1. 生成ssh密钥</h3><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p><h3 id="2-将ssh公钥添加到github"><a href="#2-将ssh公钥添加到github" class="headerlink" title="2. 将ssh公钥添加到github"></a>2. 将ssh公钥添加到github</h3><p><code>cat ~/.ssh/id_rsa.pub </code>查看公钥，复制所有内容到github中</p><h3 id="3-开启ssh代理"><a href="#3-开启ssh代理" class="headerlink" title="3. 开启ssh代理"></a>3. 开启ssh代理</h3><p><code>eval &quot;$(ssh-agent -s) </code> </p><p><code>ssh-add ~/.ssh/id_rsa</code></p><h3 id="4-测试连接"><a href="#4-测试连接" class="headerlink" title="4. 测试连接"></a>4. 测试连接</h3><p><code>ssh -T git@github.com</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NtyCo</title>
      <link href="/2024/03/07/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-1-NtyCo/"/>
      <url>/2024/03/07/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-1-NtyCo/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="NtyCo"><a href="#NtyCo" class="headerlink" title="NtyCo"></a>NtyCo</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>​纯c版本的协程实现，汇编切换，调度器实现，包含服务器端案例，客户端并发测试案例。</p><p><a href="https://github.com/wangbojing/NtyCo">github:NtyCo</a></p><p><a href="https://github.com/wangbojing/NtyCo/wiki/NtyCo%E7%9A%84%E5%AE%9E%E7%8E%B0">NtyCo的实现</a></p><p><a href="https://blog.csdn.net/qq_20553613/article/details/106140651">POSIX线程基本操作</a></p><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><h3 id="1-语法相关"><a href="#1-语法相关" class="headerlink" title="1. 语法相关"></a>1. 语法相关</h3><h4 id="1-ifndef"><a href="#1-ifndef" class="headerlink" title="1. ifndef"></a>1. ifndef</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _USE_UCONTEXT ... #<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p>判断是否定义过 <code>#define _USE_UCONTEXT</code></p></li><li><p>多用于跨平台兼容性</p></li></ul><h4 id="2-static-和-extern"><a href="#2-static-和-extern" class="headerlink" title="2. static 和 extern"></a>2. static 和 extern</h4><ul><li>static 定义&#x3D;&#x3D;该文件下&#x3D;&#x3D;的全局变量</li><li>没有static定义的全局变量，其他文件可以用&#x3D;&#x3D;extern&#x3D;&#x3D;访问</li></ul><h4 id="3-二重指针和一重指针"><a href="#3-二重指针和一重指针" class="headerlink" title="3. 二重指针和一重指针"></a>3. 二重指针和一重指针</h4><ul><li><p>二重指针可以&#x3D;&#x3D;修改地址&#x3D;&#x3D;，例如函数内calloc一段地址给参数指针。<code>**new_co; *co = calloc; *new_co = co;</code></p></li><li><p>一重指针用于修改地址对应的值，&#x3D;&#x3D;地址不能变，值能变&#x3D;&#x3D;。</p></li></ul><h4 id="4-PRIu64-和-PRId32"><a href="#4-PRIu64-和-PRId32" class="headerlink" title="4. PRIu64 和 PRId32"></a>4. PRIu64 和 PRId32</h4><ul><li>用于格式化输出无符号64位整数和有符号32位整数的格式控制符</li><li>这两个宏通常定义在 <code>&lt;inttypes.h&gt;</code> 头文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Unexpected event. lt id %&quot;</span>PRIu64<span class="string">&quot; fd %&quot;</span>PRId32<span class="string">&quot; already in %&quot;</span>PRId32<span class="string">&quot; state\n&quot;</span>,</span><br><span class="line">            co-&gt;id, co-&gt;fd, co-&gt;status);</span><br></pre></td></tr></table></figure><h4 id="5-300u-300微秒"><a href="#5-300u-300微秒" class="headerlink" title="5. 300u 300微秒"></a>5. 300u 300微秒</h4><ul><li>在C语言中，后缀<code>u</code>表示一个常量是无符号的。在这种情况下，<code>300u</code>表示一个无符号整数常量，其值为300，单位为微秒。</li></ul><h3 id="2-Posix线程"><a href="#2-Posix线程" class="headerlink" title="2. Posix线程"></a>2. Posix线程</h3><p><a href="https://blog.csdn.net/qq_20553613/article/details/106140651">POSIX线程基本操作</a></p><h4 id="1-pthread-create"><a href="#1-pthread-create" class="headerlink" title="1. pthread_create"></a>1. pthread_create</h4><ul><li>创建一个新线程，新线程将执行 start_routine 指向的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> *thread, <span class="comment">//接收新创建的线程的标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="comment">//指向线程属性对象的指针，用来设置线程的特定属性（如堆栈大小、调度策略等）。传递 NULL 表示使用默认线程属性。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="comment">//新线程启动后将要执行的代码。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg<span class="comment">//传递给 start_routine 函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><h4 id="2-pthead-detach"><a href="#2-pthead-detach" class="headerlink" title="2. pthead_detach"></a>2. pthead_detach</h4><ul><li>使调用线程与当前进程脱离，脱离状态（detached）的线程，退出时会自动释放资源</li><li><code>pthread_detach(pthread_self());</code>分离自己</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> thread<span class="comment">//线程描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><h4 id="3-pthread-join"><a href="#3-pthread-join" class="headerlink" title="3. pthread_join"></a>3. pthread_join</h4><ul><li>让调用进程（通常是主进程）等待指定的线程结束</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> thread, <span class="comment">//要等待的线程标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> **retval<span class="comment">//接收线程的返回值,NULL表示不接收</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><blockquote alt="info">    <p>         pthread_join是阻塞函数，直至线程结束。但一些场景下，主线程不能或者不希望被阻塞，此时可以在主线程或者子线程调用pthread_detach函数，使子线程成为脱离状态（detached），这样该线程结束后会自动释放所有资源，而且pthread_detach函数是非阻塞函数，主线程也不会被阻塞。<h4 id="4-pthread-exit"><a href="#4-pthread-exit" class="headerlink" title="4. pthread_exit"></a>4. pthread_exit</h4><ul><li>使线程退出调度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *value_ptr <span class="comment">//定义的指针，用来存储线程退出状态的返回值地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="5-pthread-self"><a href="#5-pthread-self" class="headerlink" title="5. pthread_self"></a>5. pthread_self</h4><ul><li>获取线程自身的序号（在线程内调用）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//线程号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-pthread-equal"><a href="#6-pthread-equal" class="headerlink" title="6. pthread_equal"></a>6. pthread_equal</h4><ul><li>比较两个线程号是否相等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t0, <span class="type">pthread_t</span> t1)</span></span>;</span><br><span class="line"><span class="comment">//返回，线程号相等返回1，否则返回0</span></span><br></pre></td></tr></table></figure><h4 id="7-pthread-setaffinity"><a href="#7-pthread-setaffinity" class="headerlink" title="7. pthread_setaffinity"></a>7. pthread_setaffinity</h4><ul><li>指定一个线程应当在哪些 CPU 上运行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> thread, <span class="comment">//粘合的线程的标识符id</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> cpusetsize, <span class="comment">//通常是 sizeof(cpu_set_t)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset<span class="comment">//该结构表示线程允许运行的 CPU 集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><h4 id="8-pthread-once"><a href="#8-pthread-once" class="headerlink" title="8. pthread_once"></a>8. pthread_once</h4><ul><li>确保某个函数在程序运行过程中只被执行一次的一种机制</li><li><code>once_control</code>是一个指向 <code>pthread_once_t</code> 类型的指针，这个变量用于控制 <code>init_routine</code> 是否已经被调用.</li><li><code>init_routine</code> 是一个指向要执行的初始化函数的指针。这个函数不接受参数，也不返回值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_once</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_once_t</span> *once_control, <span class="comment">//控制init_routine函数是否已经被调用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*init_routine)(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//当pthread_once第一次被调用时，init_routine将被执行；随后的调用将不会执行init_routine，即使是在不同的线程中也是如此。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-pthread-key-create"><a href="#9-pthread-key-create" class="headerlink" title="9. pthread_key_create"></a>9. pthread_key_create</h4><ul><li>创建一个线程局部存储键，每个线程可以将不同的数据与此键关联。当线程结束时，如果关联的数据不为<code>NULL</code>，则会调用析构函数来清理这些数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_key_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_key_t</span> *key, <span class="comment">//键</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> (*destructor)(<span class="type">void</span>*)<span class="comment">//析构函数 eg des(void *data)&#123;free(data);&#125;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回0；失败时返回错误码。</span></span><br></pre></td></tr></table></figure><h4 id="10-pthread-setspecific"><a href="#10-pthread-setspecific" class="headerlink" title="10. pthread_setspecific"></a>10. pthread_setspecific</h4><ul><li>将线程局部存储键与线程特定的数据关联起来。每个线程都可以调用这个函数，用同一个键关联不同的数据。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setspecific</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">pthread_key_t</span> key, <span class="comment">//键</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">void</span> *value<span class="comment">//键关联的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 成功时返回0；失败时返回错误码。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="11-pthread-getspecific"><a href="#11-pthread-getspecific" class="headerlink" title="11. pthread_getspecific"></a>11. pthread_getspecific</h4><ul><li>获取当前线程与指定键关联的数据。这允许线程访问其线程局部存储中存储的数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="comment">//返回与键关联的当前线程的数据，没有则返回NULL。</span></span><br></pre></td></tr></table></figure><h3 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h3><h4 id="1-eventfd"><a href="#1-eventfd" class="headerlink" title="1. eventfd"></a>1. eventfd</h4><ul><li>创建一个新的事件文件描述符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventfd</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">int</span> initval, <span class="comment">//初始的计数值，即事件发生的初始次数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags<span class="comment">//是 0 或者 EFD_NONBLOCK。EFD_NONBLOCK 表示创建的事件文件描述符是非阻塞的，</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功，返回新创建的事件文件描述符；失败 -1 </span></span><br></pre></td></tr></table></figure><h4 id="2-epoll-create"><a href="#2-epoll-create" class="headerlink" title="2. epoll_create"></a>2. epoll_create</h4><ul><li>创建一个 epoll 实例的系统调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;<span class="comment">//表示 epoll 实例的大小，但是在 Linux 2.6.8 以后的内核版本中，这个参数已经被忽略，可以传入任何大于 0 的值。</span></span><br><span class="line"><span class="comment">//成功，返回一个新的 epoll 文件描述符; 失败 -1</span></span><br></pre></td></tr></table></figure><h4 id="3-epoll-ctl"><a href="#3-epoll-ctl" class="headerlink" title="3. epoll_ctl"></a>3. epoll_ctl</h4><ul><li>用于添加、修改或删除文件描述符上的事件监听。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> epfd, <span class="comment">//epoll 实例的文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> op, <span class="comment">//EPOLL_CTL_ADD：添加一个文件描述符到 epoll 实例中，使其被监听。</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//EPOLL_CTL_MOD：修改一个文件描述符在 epoll 实例中的监听事件。</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//EPOLL_CTL_DEL：从 epoll 实例中删除一个文件描述符，不再监听其事件。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fd, <span class="comment">//要添加、修改或删除的文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> epoll_event *event<span class="comment">//描述待监听事件的数据结构，类型为 struct epoll_event。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0 ，失败 -1 </span></span><br></pre></td></tr></table></figure><h4 id="4-struct-epoll-event"><a href="#4-struct-epoll-event" class="headerlink" title="4. struct epoll_event"></a>4. struct epoll_event</h4><ul><li>描述 epoll 事件的数据结构</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般用法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN;<span class="comment">//待监听的事件类型</span></span><br><span class="line">ev.data.fd = sched-&gt;eventfd;<span class="comment">//要添加、修改或删除的文件描述符</span></span><br></pre></td></tr></table></figure><h4 id="5-epoll-wait"><a href="#5-epoll-wait" class="headerlink" title="5. epoll_wait"></a>5. epoll_wait</h4><ul><li>等待指定的 epoll 文件描述符 <code>epfd</code> 上的 I&#x2F;O 事件发生，并将发生的事件信息填充到 <code>events</code> 数组中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> epfd, <span class="comment">//epoll 文件描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> epoll_event *events, <span class="comment">//存储发生事件信息的结构体数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxevents, <span class="comment">//events 数组的最大大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> timeout<span class="comment">//等待事件发生的超时时间，单位是毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="comment">//负数，则函数一直阻塞直到有事件发生</span></span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="comment">//0，立即返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 就绪的文件描述符的数量，失败 -1</span></span><br></pre></td></tr></table></figure><h3 id="4-linux相关"><a href="#4-linux相关" class="headerlink" title="4. linux相关"></a>4. linux相关</h3><h4 id="1-getpagesize"><a href="#1-getpagesize" class="headerlink" title="1. getpagesize"></a>1. getpagesize</h4><ul><li>获取当前系统的页面大小。</li><li>系统的内存是以页面（page）为单位进行管理的，每个页面的大小是固定的，一般为 4KB 或者 8KB。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpagesize</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//成功，系统的页面大小；失败 -1</span></span><br></pre></td></tr></table></figure><h4 id="2-posix-memalign"><a href="#2-posix-memalign" class="headerlink" title="2. posix_memalign"></a>2. posix_memalign</h4><ul><li>指定的内存地址上分配一块指定大小的内存空间，同时确保所分配的内存空间的地址满足特定的对齐要求。</li><li>使用 <code>posix_memalign</code> 函数分配的内存空间需要使用 <code>free</code> 函数来释放。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">posix_memalign</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> **memptr,<span class="comment">//存放分配内存的起始地址的指针的地址，即指向指针的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">//调用成功后，该指针指向所分配的内存空间的起始地址。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> alignment, <span class="comment">//所分配内存空间的地址的对齐要求</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">//必须是 2 的幂，并且是 size_t 类型的整数。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size <span class="comment">//需要分配的内存空间的大小，单位为字节（bytes）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，memptr指针 指向的指针 指向获取分配的内存空间的起始地址；失败返回错误码</span></span><br></pre></td></tr></table></figure><h3 id="5-time"><a href="#5-time" class="headerlink" title="5. time"></a>5. time</h3><h4 id="1-struct-timeval"><a href="#1-struct-timeval" class="headerlink" title="1. struct timeval"></a>1. struct timeval</h4><ul><li>描述秒数和微秒数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;  <span class="comment">// 表示自 Epoch 起经过的秒数</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;  <span class="comment">// 表示额外的微秒数，取值范围为[0, 999999]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-gettimeofday"><a href="#2-gettimeofday" class="headerlink" title="2. gettimeofday"></a>2. gettimeofday</h4><ul><li>获取当前的时间信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> timeval *tv,<span class="comment">//存储当前时间的结构体指针，包含了秒数和微秒数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> timezone *tz<span class="comment">//存储时区信息的结构体指针，通常传入NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//成功 0，失败 -1 </span></span><br></pre></td></tr></table></figure><h4 id="3-struct-timespec"><a href="#3-struct-timespec" class="headerlink" title="3. struct timespec"></a>3. struct timespec</h4><ul><li>描述秒数和纳秒数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;  <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">// 纳秒数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 源码 </tag>
            
            <tag> NtyCo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程设计原理</title>
      <link href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-17-%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-17-%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>#协程设计原理</p><h2 id="1-协程相关问题"><a href="#1-协程相关问题" class="headerlink" title="1.协程相关问题"></a>1.协程相关问题</h2><img src="https://telegraph-image-9wl.pages.dev/file/79c0b1f774b984c5db1ec.png" alt="54ce4b827d3168b21535dbf39a5b8245" style="zoom:60%;" /><h3 id="1-为什么要有协程"><a href="#1-为什么要有协程" class="headerlink" title="1. 为什么要有协程"></a>1. 为什么要有协程</h3><ol><li>业务处理时间远小于 IO 耗时，线程切换非常频繁，那么使用协程是不错的选择；</li><li>协程的引入简化了异步编程</li><li>协程为一些异步编程提供了无锁的解决方案：同步的编程方式，异步的性能。</li></ol><h3 id="2-协程的原语操作"><a href="#2-协程的原语操作" class="headerlink" title="2. 协程的原语操作"></a>2. 协程的原语操作</h3><ol><li><code>yield</code> 让出</li><li><code>resume</code> 恢复</li><li>都是通过<code>switch</code>切换实现</li></ol><h3 id="3-协程的切换"><a href="#3-协程的切换" class="headerlink" title="3. 协程的切换"></a>3. 协程的切换</h3><ol><li><code>setjmp/longjmp</code></li><li><code>ucontext</code></li><li><code>asm code</code></li></ol><img src="https://telegraph-image-9wl.pages.dev/file/3d28dc5c5bc956895165a.png" alt="image-20240305203328911" style="zoom:63%;" /><p>​根据cpu的结构，会有一组寄存器reg，切换就是将这组寄存器reg保存起来，然后加载其他的寄存器组。</p><h3 id="4-协程的coroutine如何定义"><a href="#4-协程的coroutine如何定义" class="headerlink" title="4. 协程的coroutine如何定义"></a>4. 协程的coroutine如何定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">coroutine</span>()&#123;</span><br><span class="line">    <span class="type">int</span> coid;<span class="comment">//创建、删除、加入协程时的id</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> ctx;<span class="comment">//cpu上下文</span></span><br><span class="line">    <span class="type">void</span>* (*entry)(<span class="type">void</span>* );<span class="comment">//入口函数</span></span><br><span class="line">    <span class="type">void</span>  *args;<span class="comment">//入口函数参数</span></span><br><span class="line">    <span class="type">void</span>  *stack;<span class="comment">//独立栈 or 共享栈</span></span><br><span class="line">    <span class="type">size_t</span> size;<span class="comment">//栈大小</span></span><br><span class="line">    <span class="keyword">enum</span>&#123;</span><br><span class="line">        CO_NEW,</span><br><span class="line">        CO_READY,</span><br><span class="line">        CO_WAIT,</span><br><span class="line">CO_SLEEP.</span><br><span class="line">        CO_EXIT,</span><br><span class="line">    &#125; status;<span class="comment">//协程状态，互斥</span></span><br><span class="line">    <span class="comment">//以下数据结构都存储一份协程节点，通过切换 状态来激活，退出时删除对应节点</span></span><br><span class="line">    <span class="comment">//queue(coroutine) 是宏定义</span></span><br><span class="line">    <span class="built_in">queue_node</span>(coroutine) readyq; <span class="comment">//就绪</span></span><br><span class="line">    <span class="built_in">rbtree_node</span>(coroutine) sleepq;<span class="comment">//休眠</span></span><br><span class="line">    <span class="built_in">rbtree_node</span>(coroutine) waitq; <span class="comment">//等待</span></span><br><span class="line">    <span class="built_in">queue_node</span>(coroutine) exitq;  <span class="comment">//退出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一棵树对应多个数据结构</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/65a2516c0c66910f73321.png" alt="image-20240311100545731" style="zoom:45%;" /><h3 id="5-协程的scheduler如何定义"><a href="#5-协程的scheduler如何定义" class="headerlink" title="5. 协程的scheduler如何定义"></a>5. 协程的scheduler如何定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">scheduler</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">coroutine</span> *cur_co;</span><br><span class="line">    <span class="built_in">queue_head</span>(coroutine) readh;  <span class="comment">//就绪</span></span><br><span class="line">    <span class="built_in">rbtree_head</span>(coroutine) sleeph;<span class="comment">//休眠</span></span><br><span class="line">    <span class="built_in">rbtree_head</span>(coroutine) waith; <span class="comment">//等待</span></span><br><span class="line">    <span class="built_in">queue_head</span>(coroutine) exith;  <span class="comment">//退出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-调度策略如何实现"><a href="#6-调度策略如何实现" class="headerlink" title="6. 调度策略如何实现"></a>6. 调度策略如何实现</h3><blockquote><p>scheduler调度时间线</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/48f110e783abb197314f9.jpg" alt="274e35e136fae57b4cea07a8c2cdc0ea" style="zoom:43%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">schedule</span>(<span class="keyword">struct</span> schedule *sched)&#123;</span><br><span class="line">    coroutine *co = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1. sleep</span></span><br><span class="line"><span class="keyword">while</span>((co = <span class="built_in">get_expired_node</span>(sched-&gt;sleepq)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="built_in">resume</span>(co); </span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">push_ready_queue</span>(co);<span class="comment">//函数实现就是 co-&gt;status = CO_READY;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2. wait</span></span><br><span class="line">    <span class="keyword">while</span>(co = <span class="built_in">get_wait_node</span>(sched-&gt;wait q)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">push_ready_queue</span>(co);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3. ready</span></span><br><span class="line">    <span class="keyword">while</span>(co = <span class="built_in">get_next_node</span>(sched-&gt;readyq) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//4. exit</span></span><br><span class="line">    <span class="keyword">while</span>(co = <span class="built_in">get_next_node</span>(sched-&lt;exitq)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(co);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调度策略</p></blockquote><ol><li>&#x3D;&#x3D;io密集&#x3D;&#x3D;，存在大量io等待，例如即使通信，存在大量请求。&#x3D;&#x3D;wait放在最前面&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;计算密集&#x3D;&#x3D;，存在大量计算，例如chatGPT。&#x3D;&#x3D;ready放在最前面&#x3D;&#x3D;。</li></ol><h3 id="7-如何与posix-api兼容"><a href="#7-如何与posix-api兼容" class="headerlink" title="7. 如何与posix api兼容"></a>7. 如何与posix api兼容</h3><blockquote><p>hook代理posix api库</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *restrict handle, <span class="comment">//表示已经加载的共享库。该句柄用于指定 dlsym 在哪个库中搜索指定的符号。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *restrict symbol<span class="comment">//这是一个以 null 结尾的字符串，指定要查找的符号名称。符号可以是函数名或变量名。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//允许程序在运行时查找共享库（如 Linux 下的 .so 文件或 macOS 下的 .dylib 文件）中的符号（通常是函数或变量的地址）。</span></span><br><span class="line"><span class="comment">//成功，dlsym 返回一个指向符号的指针，该指针可以转换为适当的函数指针或变量指针以供使用。</span></span><br><span class="line"><span class="comment">//失败返回NULL</span></span><br><span class="line"></span><br><span class="line">connect_f = (<span class="type">connect_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT,<span class="string">&quot;connect&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>案例：对mysql使用hook拦截connect、recv和send</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含必要的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型重定义：为了简化函数指针的使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="type">connect_t</span>)</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ssize_t</span> <span class="params">(*<span class="type">recv_t</span>)</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ssize_t</span> <span class="params">(*<span class="type">send_t</span>)</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量：指向原始网络函数的函数指针</span></span><br><span class="line"><span class="type">connect_t</span> connect_f = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">recv_t</span> recv_f = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">send_t</span> send_f = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 connect 函数，用于拦截网络连接请求</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect\n&quot;</span>); <span class="comment">// 打印拦截信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">connect_f</span>(sockfd, addr, addrlen); <span class="comment">// 调用原始 connect 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 recv 函数，用于拦截网络接收操作</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv\n&quot;</span>); <span class="comment">// 打印拦截信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recv_f</span>(sockfd, buf, len, flags); <span class="comment">// 调用原始 recv 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 send 函数，用于拦截网络发送操作</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send\n&quot;</span>); <span class="comment">// 打印拦截信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">send_f</span>(sockfd, buf, len, flags); <span class="comment">// 调用原始 send 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化拦截函数：将全局函数指针指向真正的网络函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_hook</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 dlsym 和 RTLD_NEXT 查找并保存原始函数的地址</span></span><br><span class="line">    <span class="comment">//RTLD_NEXT 用于指定 dlsym 应在当前库之后的链接库中搜索指定的符号。这意味着它会跳过当前库（或者更具体地说，是调用 dlsym 的代码所在的库），寻找后续库中符号的下一个定义。</span></span><br><span class="line">    <span class="keyword">if</span>(!connect_f)&#123;</span><br><span class="line">        connect_f = (<span class="type">connect_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!recv_f)&#123;</span><br><span class="line">        recv_f = (<span class="type">recv_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;recv&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!send_f)&#123;</span><br><span class="line">        send_f = (<span class="type">send_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功初始化返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化拦截函数</span></span><br><span class="line">    <span class="built_in">init_hook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 MySQL 连接</span></span><br><span class="line">    MYSQL *mysql = <span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!mysql)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mysql init failed\n&quot;</span>); <span class="comment">// 如果初始化失败，打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接到 MySQL 数据库</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">mysql_real_connect</span>(mysql, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;qwer&quot;</span>, <span class="string">&quot;0Voice&quot;</span>, <span class="number">3306</span>, <span class="literal">NULL</span>, CLIENT_FOUND_ROWS))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mysql_real_connect error\n&quot;</span>); <span class="comment">// 如果连接失败，打印错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果连接成功，打印成功信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysql_real_connect success\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-协程多核模式"><a href="#8-协程多核模式" class="headerlink" title="8. 协程多核模式"></a>8. 协程多核模式</h3><blockquote><p>与cpu粘合</p></blockquote><ol><li>多用于&#x3D;&#x3D;计算密集类&#x3D;&#x3D;，一个cpu用于一个计算。</li></ol><blockquote><p>每个线程&#x2F;进程一个调度器</p></blockquote><ol><li>简单。</li><li>避免访问共享资源时&#x3D;&#x3D;加锁&#x3D;&#x3D;难题。</li></ol><blockquote><p>CPU绑定进程&#x2F;线程 PID&#x2F;TID</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cpu_set_t</span> mask;<span class="comment">//定义cpu集合</span></span><br><span class="line"><span class="built_in">CPU_ZERO</span>(&amp;mask);<span class="comment">//初始化cpu集合</span></span><br><span class="line"><span class="built_in">CPU_SET</span>(cpu_id, &amp;mask);<span class="comment">//cpu放入集合中</span></span><br><span class="line"><span class="comment">//进程绑定CPU</span></span><br><span class="line"><span class="built_in">sched_setaffinity</span>(pid, <span class="built_in">sizeof</span>(mask), &amp;mask); </span><br><span class="line"><span class="comment">//线程绑定CPU</span></span><br><span class="line"><span class="built_in">pthread_setaffinity_np</span>(pthread_id, <span class="built_in">sizeof</span>(mask), &amp;mask); </span><br></pre></td></tr></table></figure><blockquote><p>CPU相关函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_getcpu</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回值：cpu核心编号，从0开始</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//运行时查询系统级配置信息和限制</span></span><br><span class="line"><span class="comment">//获取关于操作系统和硬件特性的动态信息，如 CPU 核心数、每个进程可打开的最大文件数等</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">sysconf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> name<span class="comment">//指定要查询的系统信息或限制</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF);<span class="comment">//查询CPU核心数</span></span><br><span class="line"><span class="comment">//返回值：成功查询的配置信息，失败-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span> <span class="comment">// For SYS_xxx definitions</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">syscall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">long</span> number,<span class="comment">//系统调用的编号，如 __NR_read、__NR_write </span></span></span></span><br><span class="line"><span class="params"><span class="function">    ...<span class="comment">//对应于要执行的系统调用所需的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功系统调用的正值或0，失败-1</span></span><br></pre></td></tr></table></figure><blockquote><p>多线程相关函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新线程，新线程将执行 start_routine 指向的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> *thread, <span class="comment">//接收新创建的线程的标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="comment">//指向线程属性对象的指针，用来设置线程的特定属性（如堆栈大小、调度策略等）。传递 NULL 表示使用默认线程属性。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="comment">//新线程启动后将要执行的代码。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg<span class="comment">//传递给 start_routine 函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定一个线程应当在哪些 CPU 上运行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> thread, <span class="comment">//粘合的线程的标识符id</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> cpusetsize, <span class="comment">//通常是 sizeof(cpu_set_t)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset<span class="comment">//该结构表示线程允许运行的 CPU 集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让调用进程（通常是主进程）等待指定的线程结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> thread, <span class="comment">//要等待的线程标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> **retval<span class="comment">//接收线程的返回值,NULL表示不接收</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败错误代码</span></span><br></pre></td></tr></table></figure><blockquote><p>多进程相关函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//进程创建，子进程几乎是父进程的完整副本</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回值：父进程中返回子进程PID，子进程返回0</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_setaffinity</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pid_t</span> pid, <span class="comment">//进程的进程ID（PID）,0为当前进程</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> cpusetsize, <span class="comment">//通常是 sizeof(cpu_set_t)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">cpu_set_t</span> *mask<span class="comment">///该结构表示线程允许运行的 CPU 集合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败-1</span></span><br></pre></td></tr></table></figure><blockquote><p>案例1：&#x3D;&#x3D;多线程&#x3D;&#x3D;与cpu粘合</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义线程数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，打印线程ID和它所运行的CPU</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">thread_func</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span> *)args; <span class="comment">// 从参数中获取线程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %d running on cpu %d\n&quot;</span>, thread_id, <span class="built_in">sched_getcpu</span>()); <span class="comment">// 打印线程ID和CPU编号</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 让线程持续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[THREAD_COUNT]; <span class="comment">// 线程标识符数组</span></span><br><span class="line">    <span class="type">int</span> threads_id[THREAD_COUNT]; <span class="comment">// 存储线程ID的数组</span></span><br><span class="line">    <span class="type">cpu_set_t</span> cpus; <span class="comment">// CPU集合，用于设置亲和性</span></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpus); <span class="comment">// 初始化CPU集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;THREAD_COUNT;i++)&#123;</span><br><span class="line">        <span class="built_in">CPU_SET</span>(i, &amp;cpus); <span class="comment">// 将CPU加入集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;THREAD_COUNT;i++)&#123;</span><br><span class="line">        threads_id[i] = i; <span class="comment">// 初始化线程ID</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, thread_func, &amp;threads_id[i]); <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="built_in">pthread_setaffinity_np</span>(threads[i], <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpus); <span class="comment">// 设置线程CPU亲和性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;THREAD_COUNT;i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">NULL</span>); <span class="comment">// 等待线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>案例2：&#x3D;&#x3D;多进程&#x3D;&#x3D;与cpu粘合</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process_bind 函数设置调用它的进程的CPU亲和性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process_bind</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sysconf</span>(_SC_NPROCESSORS_CONF); <span class="comment">// 获取系统CPU数量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> self_id = <span class="built_in">syscall</span>(__NR_gettid); <span class="comment">// 获取当前线程/进程的ID</span></span><br><span class="line"></span><br><span class="line">    <span class="type">cpu_set_t</span> mask; <span class="comment">// 定义CPU集合</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;mask); <span class="comment">// 初始化CPU集合</span></span><br><span class="line">    <span class="built_in">CPU_SET</span>(self_id % num, &amp;mask); <span class="comment">// 根据进程ID设置CPU亲和性，简单分配到不同CPU</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sched_setaffinity</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(mask), &amp;mask); <span class="comment">// 应用CPU亲和性设置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process %d running on cpu %d\n&quot;</span>, self_id, <span class="built_in">sched_getcpu</span>()); <span class="comment">// 打印进程ID和它所运行的CPU</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 让进程持续运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fork(); <span class="comment">// 创建一个新进程</span></span><br><span class="line">    fork(); <span class="comment">// 再次创建，总共会有4个进程（包括原始进程）</span></span><br><span class="line">    <span class="built_in">process_bind</span>(); <span class="comment">// 设置进程的CPU亲和性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-协程函数"><a href="#2-协程函数" class="headerlink" title="2. 协程函数"></a>2. 协程函数</h2><h3 id="1-setjmp-longjmp"><a href="#1-setjmp-longjmp" class="headerlink" title="1. setjmp &#x2F; longjmp"></a>1. setjmp &#x2F; longjmp</h3><p>​<code>setjmp()</code>和<code>longjmp() </code>可以实现非局部控制转移即从一个函数到另外一个函数的跳转。</p><p>​<code>goto</code>只能在一个文件中使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf j)</span></span>;</span><br><span class="line"><span class="comment">//setjmp调用返回值：0，从longjmp则返回longjmp的第二个参数值</span></span><br></pre></td></tr></table></figure><ul><li>设置返回点，保存调用函数的栈环境与j中（相当于&#x3D;&#x3D;保护现场&#x3D;&#x3D;）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    jmp_buf j, <span class="comment">//setjmp保存的环境</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> i<span class="comment">//指定setjmp的返回值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>使用setjmp保存在j中的栈环境信息返回到setjmp的位置，也就是当执行longjmp时程序又回到setjmp处（相当于&#x3D;&#x3D;恢复现场&#x3D;&#x3D;）。</li></ul><blockquote><p>打印 ping-pong</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> jmp_buf master;</span><br><span class="line"><span class="type">static</span> jmp_buf pingbuf;</span><br><span class="line"><span class="type">static</span> jmp_buf pongbuf;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iter=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setjmp</span>(pingbuf)==<span class="number">0</span>) <span class="built_in">longjmp</span>(master,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ping-&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">setjmp</span>(pingbuf)==<span class="number">0</span>) <span class="built_in">longjmp</span>(pongbuf,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pong</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setjmp</span>(pongbuf)==<span class="number">0</span>) <span class="built_in">longjmp</span>(master,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;pong&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(iter++&gt;<span class="number">10</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">setjmp</span>(pongbuf)==<span class="number">0</span>) <span class="built_in">longjmp</span>(pingbuf,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setjmp</span>(master)==<span class="number">0</span>) <span class="built_in">ping</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">setjmp</span>(master)==<span class="number">0</span>) <span class="built_in">pong</span>();</span><br><span class="line">    <span class="built_in">longjmp</span>(pingbuf,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ucontext"><a href="#2-ucontext" class="headerlink" title="2. ucontext"></a>2. ucontext</h3><p>​<code>ucontext</code> 直接提供了设置函数运行时栈的方式<code>makecontext</code>，避免不同函数栈空间的重叠。</p><blockquote><p>结构体 <code>mcontext_t</code> <code>ucontext_t</code></p></blockquote><ul><li><code>mcontext_t</code>类型与机器相关，并且不透明.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ucontext</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ucontext</span> *uc_link;<span class="comment">//指向另一个 ucontext 结构体的指针，用于在当前上下文结束时恢复到指定的上下文。</span></span><br><span class="line">    <span class="type">sigset_t</span>         uc_sigmask;<span class="comment">//保存当前上下文中阻塞信号集合。</span></span><br><span class="line">    <span class="type">stack_t</span>          uc_stack;<span class="comment">//保存当前上下文中的堆栈信息的结构体，包括堆栈的起始地址和大小。</span></span><br><span class="line">    <span class="type">mcontext_t</span>       uc_mcontext;<span class="comment">//保存机器上下文的结构体，包括寄存器的值等。</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="type">ucontext_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>函数<code>getcontext()</code> <code>setcontext()</code> <code>makecontext()</code> <code>swapcontext()</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//初始化ucp结构体，将当前的上下文保存到ucp中</span></span><br><span class="line"><span class="comment">//成功0，失败-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//设置当前的上下文为ucp，</span></span><br><span class="line"><span class="comment">//如果上下文是通过调用getcontext()取得,程序会继续执行这个调用。</span></span><br><span class="line"><span class="comment">//如果上下文是通过调用makecontext取得,程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回,则恢复makecontext第一个参数指向的上下文第一个参数指向的上下文context_t中指向的uc_link.如果uc_link为NULL,则线程退出。</span></span><br><span class="line"><span class="comment">//成功不返回，失败-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(), <span class="type">int</span> argc, ...)</span></span>;</span><br><span class="line"><span class="comment">//第二个参数通常要强转 (void(*)(void))</span></span><br><span class="line"><span class="comment">//makecontext修改通过getcontext取得的上下文ucp(这意味着调用makecontext前必须先调用getcontext)。然后给该上下文指定一个栈空间ucp-&gt;stack，设置后继的上下文ucp-&gt;uc_link.</span></span><br><span class="line"><span class="comment">//当上下文通过setcontext或者swapcontext激活后，执行func函数，argc为func的参数个数，后面是func的参数序列。当func执行返回后，继承的上下文被激活，如果继承上下文为NULL时，线程退出。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *oucp, <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//保存当前上下文到oucp结构体中，然后激活upc上下文。</span></span><br><span class="line"><span class="comment">//如果执行成功，getcontext返回0，setcontext和swapcontext不返回；如果执行失败，getcontext,setcontext,swapcontext返回-1，并设置对于的errno.</span></span><br><span class="line"><span class="comment">//成功不返回，失败-1</span></span><br></pre></td></tr></table></figure><blockquote><p>案例1：打印1，2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">ucontext_t</span> master,chain;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMaster</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> stack[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;master);</span><br><span class="line">    master.uc_stack.ss_sp = stack;</span><br><span class="line">    master.uc_stack.ss_size = <span class="built_in">sizeof</span> (stack);</span><br><span class="line">    master.uc_link = &amp;chain;</span><br><span class="line">    <span class="built_in">makecontext</span>(&amp;master,(<span class="built_in">void</span>(*)(<span class="type">void</span>))printMaster, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">swapcontext</span>(&amp;chain,&amp;master);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>案例2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ucontext_t</span> context;</span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编**"></a>3. 汇编**</h3><p><a href="https://github.com/wangbojing/NtyCo/wiki/NtyCo%E7%9A%84%E5%AE%9E%E7%8E%B0">NtyCo的实现</a></p><p><a href="https://blog.csdn.net/Carey_Lu/article/details/129103028">ucontext实践</a></p><p><a href="https://blog.csdn.net/weixin_52183917/article/details/127703800?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-9-127703800-blog-116176936.235%5Ev43%5Epc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.6&utm_relevant_index=12">一文搞懂协程</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP、KCP与QUIC</title>
      <link href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-16-UDP%E3%80%81KCP%E4%B8%8EQUIC/"/>
      <url>/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-16-UDP%E3%80%81KCP%E4%B8%8EQUIC/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP、KCP与QUIC"><a href="#UDP、KCP与QUIC" class="headerlink" title="UDP、KCP与QUIC"></a>UDP、KCP与QUIC</h1><h2 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1. 网络基础"></a>1. 网络基础</h2><h3 id="1-如何做到可靠性传输"><a href="#1-如何做到可靠性传输" class="headerlink" title="1. 如何做到可靠性传输"></a>1. 如何做到可靠性传输</h3><ol><li>ACK确认</li><li>重传机制</li><li>序号机制</li><li>重排机制</li><li>窗口机制，流量控制</li></ol><h3 id="2-TCP与UDP"><a href="#2-TCP与UDP" class="headerlink" title="2. TCP与UDP"></a>2. TCP与UDP</h3><blockquote><p>TCP与UDP特点</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/a793e407e2f6800f7d0fe.png" alt="image-20240305101502045" style="zoom:40%;" /><blockquote><p>TCP与UDP报文格式</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ba762e574ef80775f6c98.png" alt="image-20240305101625009" style="zoom:50%;" /><h3 id="3-自动重传协议ARQ（Automatic-Repeat-reQuest）"><a href="#3-自动重传协议ARQ（Automatic-Repeat-reQuest）" class="headerlink" title="3. 自动重传协议ARQ（Automatic Repeat-reQuest）"></a>3. 自动重传协议ARQ（Automatic Repeat-reQuest）</h3><ol><li>停止等待</li><li>回退n帧</li><li>选择重传</li></ol><blockquote><p>停止等待</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ccd9a60835c9bf3974294.png" alt="image-20240305102202083" style="zoom:33%;" /><blockquote><p>回退n帧</p></blockquote><p>​为了克服停等协议长时间等待ACK的缺陷，连续ARQ协议会连续发送一组数据包，然后再等待这些数据包的ACK。</p><img src="https://telegraph-image-9wl.pages.dev/file/1b89ad3a5fbf5387586e1.png" alt="image-20240305102252303" style="zoom:40%;" /><img src="https://telegraph-image-9wl.pages.dev/file/ab4086dd648ba8b22d3a0.png" alt="image-20240305102330403" style="zoom:33%;" /><blockquote><p>选择重传</p></blockquote><p>​虽然GBN改善了停等协议中时间等待较长的缺陷，但它依旧存在着性能问题。特别是当窗口长度很大的时候，会使效率大大降低。而SR协议通过让发送方仅重传在接收方丢失或损坏了的分组，从而避免了不必要的重传，提高了效率。</p><img src="https://telegraph-image-9wl.pages.dev/file/4041ae15540984c89a80e.png" alt="image-20240305102452387" style="zoom:43%;" /><img src="https://telegraph-image-9wl.pages.dev/file/cbf7759019f9cad7e754d.png" alt="image-20240305102509250" style="zoom:33%;" /><h3 id="4-RTT-和-RTO"><a href="#4-RTT-和-RTO" class="headerlink" title="4. RTT 和 RTO"></a>4. RTT 和 RTO</h3><blockquote><p>RTO（RetransmissionTimeOut）即重传超时时间。</p></blockquote><blockquote><p>RTT(Round-TripTime)：往返时延。</p></blockquote><p>​表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p><ol><li>链路的传播时间（propagationdelay）</li><li>末端系统的处理时间</li><li>路由器缓存中的排队和处理时间（queuingdelay）</li></ol><p>​前两个部分的值对于一个TCP连接相对固定，路由器缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以&#x3D;&#x3D;RTT的变化&#x3D;&#x3D;在一定程度上反应网络的拥塞程度。</p><h3 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h3><img src="https://telegraph-image-9wl.pages.dev/file/4b28d3c5f304b53d69a78.png" alt="image-20240305103001651" style="zoom:33%;" /><blockquote><p>如何控制？</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/b02ef0b4b4cdb2af62cb0.png" alt="image-20240305103436157" style="zoom:33%;" /><blockquote><p>发送方何时发送数据？</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/b29684182c41769a98be2.png" alt="image-20240305103517527" style="zoom:40%;" /><blockquote><p>总结</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ce5bd7711834b72d98ec9.png" alt="image-20240305103537832" style="zoom:40%;" /><h3 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h3><img src="https://telegraph-image-9wl.pages.dev/file/9f18e1393e9423e6775c2.png" alt="image-20240305103632185" style="zoom:33%;" /><h3 id="7-UDP-网络编程"><a href="#7-UDP-网络编程" class="headerlink" title="7. UDP 网络编程"></a>7. UDP 网络编程</h3><img src="https://telegraph-image-9wl.pages.dev/file/ff8b288aebfb15a58758c.png" alt="image-20240305104253540" style="zoom:83%;" /><h2 id="2-KCP快速可靠传输协议"><a href="#2-KCP快速可靠传输协议" class="headerlink" title="2. KCP快速可靠传输协议"></a>2. KCP快速可靠传输协议</h2><blockquote><p>kcp 可以看做应用层协议，底层采用 udp 传输</p></blockquote><h3 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h3><img src="https://telegraph-image-9wl.pages.dev/file/54464194b08a58f128335.png" alt="image-20240305111737678" style="zoom:33%;" /><img src="https://telegraph-image-9wl.pages.dev/file/0e75886926458164f152e.png" alt="image-20240305111754986" style="zoom:33%;" /><h3 id="2-kcp协议头"><a href="#2-kcp协议头" class="headerlink" title="2. kcp协议头"></a>2. kcp协议头</h3><img src="https://telegraph-image-9wl.pages.dev/file/39e4d89b0ad2e162fc927.png" alt="image-20240305122106642" style="zoom:35%;" /><img src="https://telegraph-image-9wl.pages.dev/file/398f56978e617d3ace085.png" alt="image-20240305122419300" style="zoom:35%;" /><h3 id="3-kcp-发送数据"><a href="#3-kcp-发送数据" class="headerlink" title="3. kcp 发送数据"></a>3. kcp 发送数据</h3><img src="https://telegraph-image-9wl.pages.dev/file/8181a08e3e382c18de1a0.png" alt="image-20240305123149287" style="zoom:90%;" /><img src="https://telegraph-image-9wl.pages.dev/file/2ab6383dbc4f12ec9cafe.png" alt="image-20240305123215527" style="zoom:50%;" /><img src="https://telegraph-image-9wl.pages.dev/file/26669535ad18d97ec691c.png" alt="image-20240305123239026" style="zoom:90%;" /><img src="https://telegraph-image-9wl.pages.dev/file/6410dbbb7287715327f77.png" alt="image-20240305123511842" style="zoom:35%;" /><h3 id="4-kcp-接受数据"><a href="#4-kcp-接受数据" class="headerlink" title="4. kcp 接受数据"></a>4. kcp 接受数据</h3><img src="https://telegraph-image-9wl.pages.dev/file/2b9c6c3613dd3f7745258.png" alt="image-20240305124506349" style="zoom:90%;" /><img src="https://telegraph-image-9wl.pages.dev/file/2da4f813f62bcd0712dc7.png" alt="image-20240305124630859" style="zoom:37%;" /><img src="https://telegraph-image-9wl.pages.dev/file/bd37b6bdee97b1b48395b.png" alt="image-20240305124738972" style="zoom:33%;" /><img src="https://telegraph-image-9wl.pages.dev/file/2c0ff121f268eb2e0d146.png" alt="image-20240305124820947" style="zoom:33%;" /><img src="https://telegraph-image-9wl.pages.dev/file/09a58bad6736b5885aaf2.png" alt="image-20240305124850915" style="zoom:93%;" /><img src="https://telegraph-image-9wl.pages.dev/file/9a2564f621f0c0ce45f75.png" alt="image-20240305124917844" style="zoom:37%;" /><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><img src="https://telegraph-image-9wl.pages.dev/file/141d5ea84d7b287b5c448.png" alt="07081af5a570153004a55b3eaf7a804c" style="zoom:80%;" /><img src="https://telegraph-image-9wl.pages.dev/file/a5ea3115bf56b397c90e8.png" alt="image-20240305125247636" style="zoom:33%;" /><img src="https://telegraph-image-9wl.pages.dev/file/4dc5e6eeb575684435586.png" alt="image-20240305125305919" style="zoom:33%;" /><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6. 使用"></a>6. 使用</h3><img src="https://telegraph-image-9wl.pages.dev/file/babb1d59f85fb5f902821.jpg" alt="v2-4d501634718ef8a880745546ca470b84_r" style="zoom:93%;" />]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PosixAPI与网络协议栈</title>
      <link href="/2024/03/04/C-%E9%9B%B6%E5%A3%B0linux-15-PosixAPI%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
      <url>/2024/03/04/C-%E9%9B%B6%E5%A3%B0linux-15-PosixAPI%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="PosixAPI与网络协议栈"><a href="#PosixAPI与网络协议栈" class="headerlink" title="PosixAPI与网络协议栈"></a>PosixAPI与网络协议栈</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><blockquote><p>网络API</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/cee675650e8b6df0cf264.png" style="zoom:37%;" ><blockquote><p>TCP与UDP</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/fee9274d1896bf104c9b5.png" alt="image-20240304123233388" style="zoom:30%;" /><blockquote><p>TCP头</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5b8e5ed6b3b81cedd2354.png" alt="image-20240304132536134" style="zoom:50%;" /><h2 id="2-API详解"><a href="#2-API详解" class="headerlink" title="2.API详解"></a>2.API详解</h2><h3 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h3><img src="https://telegraph-image-9wl.pages.dev/file/1f64a22e59fdebda8c492.png" alt="image-20240304125501236" style="zoom:67%;" /><blockquote><p>listen</p></blockquote><ol><li>底层listenfd 对应一个tcb块</li><li>tcb块设置为监听状态</li></ol><blockquote><p>accept</p></blockquote><ol><li><p>条件阻塞，等待TCP三次握手的第一次请求（放入半连接队列）</p><p><code>while(accept_queue == nullpty)&#123; pthread_cond_wait();&#125;</code></p></li><li><p>从半连接队列获取和TCP三次握手第三次ack标志相同的tcb</p><p><code>*tcb = get_tcb_from(accept_queue)</code></p></li><li><p>分配fd给连接</p><p><code>clientfd = get_tcb_from(accept_queue);</code></p><p><code>tcb = clientfd</code></p><p><code>return clientfd</code></p></li></ol><blockquote><p>connect</p></blockquote><ol><li>通过网络数据包tcb的五元组(sip, dip,sport,dport,proto)，查找对应的半连接队列节点。</li></ol><blockquote><p>socket</p></blockquote><ol><li>socket 意为插座，分配一个fd，供后续tcb使用</li></ol><blockquote><p>bind</p></blockquote><ol><li>将 tcb的ip和port进行绑定，供后续使用，此时连接状态仍为closed。</li></ol><blockquote alt="info">    <p>        网络状态转移图与三次握手    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/4bb3f42d67ec9edfc3fda.png" alt="image-20240304130347849" style="zoom:50%;" /><h3 id="2-TCP传输"><a href="#2-TCP传输" class="headerlink" title="2. TCP传输"></a>2. TCP传输</h3><img src="https://telegraph-image-9wl.pages.dev/file/13d08098276f6923b57fa.png" alt="image-20240304132943253" style="zoom:50%;" /><blockquote><p>send</p></blockquote><ol><li>将待发送内容 copy 到kernel中，至于何时发送、发送多长都是由网络协议栈决定。</li><li>tcp分包的两种实现：1）分包添加长度length。2）添加分割符。</li></ol><blockquote><p>recv</p></blockquote><ol><li>从kernel拷贝内容到app中。</li></ol><blockquote><p>如何确定send成功？TCP是可靠传输，为什么应用层还要做校验？</p></blockquote><ul><li>在应用层收到对方的ack值。</li><li>TCP的可靠传输只保证在传输层确定收到。</li><li>send函数是应用层，无法感知到传输层的状态，因此需要在应用层校验确认。</li></ul><h3 id="3-连接断开"><a href="#3-连接断开" class="headerlink" title="3. 连接断开"></a>3. 连接断开</h3><blockquote><p>close</p></blockquote><blockquote><p>FIN标识位</p></blockquote><ol><li>携带数据，可以随send的最后一个包一起发送，&#x3D;&#x3D;FIN&#x3D;&#x3D;标志位置1。</li><li>长时间没有&#x3D;&#x3D;send&#x3D;&#x3D;数据时，才单独发送一个包。</li></ol><blockquote><p>server出现大量close_wait，这是什么原因？如何解决？</p></blockquote><ol><li>server收到client发送的&#x3D;&#x3D;FIN&#x3D;&#x3D;后，进入&#x3D;&#x3D;close_wait&#x3D;&#x3D;状态。</li><li>原因：server没有及时调用&#x3D;&#x3D;close&#x3D;&#x3D;，recv时，先清理缓存，再调用了close。</li><li>将清理缓存等操作做到&#x3D;&#x3D;另外个线程&#x3D;&#x3D;，做成和&#x3D;&#x3D;close异步&#x3D;&#x3D;。</li></ol><blockquote><p>client出现大量fin_wait_2，如何退出？</p></blockquote><ol><li>server出现大量close时，就会出现这种情况。</li><li>client系统有超时处理。</li></ol><blockquote alt="info">    <p>        网络状态转移图与四次挥手    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/fe600437e4fa27a273557.png" alt="image-20240305095233993" style="zoom:35%;" />]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Unified Model for Multi-class Anomaly Detection</title>
      <link href="/2024/03/04/%E7%A7%91%E7%A0%94-5-UniAD/"/>
      <url>/2024/03/04/%E7%A7%91%E7%A0%94-5-UniAD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="UniAD"><a href="#UniAD" class="headerlink" title="UniAD"></a>UniAD</h1><blockquote><p>NeurIPS 2022 </p></blockquote><blockquote><p>上海交通大学，Zhiyuan You，Lei Cui</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/138726b6b4bf6be3f1b30.png" alt="image-20240304100711319" style="zoom:60%;" /><blockquote><ol><li>解决重构时，正常和异常图像都能很好重构问题</li><li>从公式出发，用不含平凡解的self-attention用作特征提取器</li><li>mask周围的块，让图像块不能从周围块算出来</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-使用统一的框架来检测不同对象类的异常"><a href="#1-使用统一的框架来检测不同对象类的异常" class="headerlink" title="1. 使用统一的框架来检测不同对象类的异常"></a>1. 使用统一的框架来检测不同对象类的异常</h3><blockquote><p>对有限类别进行模型建模</p></blockquote><p>​训练数据涵盖了一系列类别的正常样本，并且要求学习到的模型在不进行任何微调的情况下完成所有这些类别的异常检测。分类信息(即类标签)在&#x3D;&#x3D;训练和推理阶段都是不可访问&#x3D;&#x3D;的。</p><h3 id="2-重构图像异常检测问题：identity-shortcut-标识快捷方式"><a href="#2-重构图像异常检测问题：identity-shortcut-标识快捷方式" class="headerlink" title="2. 重构图像异常检测问题：identity shortcut 标识快捷方式"></a>2. 重构图像异常检测问题：identity shortcut 标识快捷方式</h3><blockquote><p>重建网络在该工作中，返回输入的直接结果，而不考虑内容，因此异常样本也能很好的恢复，从而变得难以检测异常</p></blockquote><p>​在统一情况下，正态数据的分布更为复杂，“相同捷径”问题被放大。直观地说，要学习一个可以重构各种对象的统一模型，需要模型非常努力地学习联合分布。从这个角度来看，学习“相同的捷径”似乎是一个更容易的解决方案。</p><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-分层查询解码器来加强查询嵌入（QKV中Q）的使用"><a href="#1-分层查询解码器来加强查询嵌入（QKV中Q）的使用" class="headerlink" title="1. 分层查询解码器来加强查询嵌入（QKV中Q）的使用"></a>1. 分层查询解码器来加强查询嵌入（QKV中Q）的使用</h3><blockquote><p>全连接层和卷积层都面临学习平凡解的风险</p></blockquote><p>​在多类别设置下，正态数据分布变得复杂得多，这一缺点进一步被放大。相反，注意力层避免了这种风险，受益于可学习的查询嵌入，详细消融结果见图</p><img src="https://telegraph-image-9wl.pages.dev/file/0b91dfb98516e47dd3b8d.png" alt="image-20240304100101083" style="zoom:63%;" />$$y = x^+w + b \in R^{K×C}$$​对于上述全连接层，$x^+$ 和 $x^-$ 分别代表正常和异常输入。当 $w\mapsto I$ (identity matrix)时，$b \mapsto 0$ 时，模型仍然能较好的重构正常和异常样本。<p>​对于CNN来说，可以看成参数和容量都更多的全连接层。<br>$$<br>y &#x3D; \text{softmax}\left(\frac{q(x^+)^T}{\sqrt{C}}\right)x^+ \in \mathbb{R}^{K \times C}<br>$$<br>​对于transformer attention，$softmax()$ 中 $q$ 必须和 $x^+$ 相关，才能更好的将 $y \mapsto x^+$，因此transformer受&#x3D;&#x3D;shortcut&#x3D;&#x3D;问题影响较小，但是仍然存在。 </p><h3 id="2-邻居屏蔽关注模块"><a href="#2-邻居屏蔽关注模块" class="headerlink" title="2. 邻居屏蔽关注模块"></a>2. 邻居屏蔽关注模块</h3><blockquote><p>特征点既不与自身相关，也不与邻居相关</p></blockquote><p>​充分的关注(即每个特征点彼此相关)也有助于捷径问题，因为它提供了直接将输入复制到输出的机会</p><h3 id="3-特征抖动策略"><a href="#3-特征抖动策略" class="headerlink" title="3. 特征抖动策略"></a>3. 特征抖动策略</h3><blockquote><p>有噪声的输入下也能恢复源消息</p></blockquote><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-邻居屏蔽关注模块"><a href="#1-邻居屏蔽关注模块" class="headerlink" title="1. 邻居屏蔽关注模块"></a>1. 邻居屏蔽关注模块</h3><p>​充分注意的情况下，一个令牌被允许看到自己，因此它很容易通过简单的复制来重建。此外，考虑到特征令牌是由CNN主干提取的，邻居令牌必须具有许多相似之处。</p><img src="https://telegraph-image-9wl.pages.dev/file/527bd202461298ce99bb8.png" alt="image-20240304101318941" style="zoom:50%;" /><p>​上图，对于特征点“星星”，它周围的一圈被屏蔽，其余值不变。</p><h3 id="2-分层查询解码器"><a href="#2-分层查询解码器" class="headerlink" title="2. 分层查询解码器"></a>2. 分层查询解码器</h3><p>​根据&#x3D;&#x3D;查询嵌入q可以防止异常重构&#x3D;&#x3D;，将查询嵌入添加到每一层解码器中，而不是仅在vanilla transformer的第一层。</p><p>​由于一个令牌可以看到它自己和它的邻近区域，所以通过简单的复制就可以很容易地重建它。因此，我们在计算注意图时屏蔽邻居令牌，即使用邻居屏蔽关注模块</p><h3 id="3-特征抖动策略-1"><a href="#3-特征抖动策略-1" class="headerlink" title="3. 特征抖动策略"></a>3. 特征抖动策略</h3><p>$$<br>D \sim \mathcal{N}(\mu &#x3D; 0, \sigma^2 &#x3D; \left(\frac{\alpha \lVert ftok \rVert_2}{C}\right)^2)<br>$$</p><p>​受 Denoising Auto-Encoder (DAE) 启发，在特征标记 $ftok \in \mathbb{R}^C$ 中以固定概率 $P$ 加入干扰 $D$ 。$\alpha$ 是超参数。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p>​在&#x3D;&#x3D;MVTec-AD&#x3D;&#x3D;中学习15个类别的单个模型时，我们在异常检测和异常定位任务上都取得了最先进的性能，将&#x3D;&#x3D;AUROC&#x3D;&#x3D;分别从88.1%提高到&#x3D;&#x3D;96.5%&#x3D;&#x3D;和从89.5%提高到&#x3D;&#x3D;96.8%&#x3D;&#x3D;。</p><img src="https://telegraph-image-9wl.pages.dev/file/7343f02a157e977c809cd.png" alt="image-20240304105321767" style="zoom:50%;" /><p><a href="https://arxiv.org/pdf/2206.03687.pdf">论文链接</a></p><p><a href="https://github.com/zhiyuanyou/UniAD">代码链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 服务器</title>
      <link href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-13-http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-13-http%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC] </p><h1 id="http-服务器"><a href="#http-服务器" class="headerlink" title="http 服务器"></a>http 服务器</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactor反应堆</title>
      <link href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-14-reactor%E5%8F%8D%E5%BA%94%E5%A0%86/"/>
      <url>/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-14-reactor%E5%8F%8D%E5%BA%94%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC] </p><h1 id="reactor反应堆"><a href="#reactor反应堆" class="headerlink" title="reactor反应堆"></a>reactor反应堆</h1><h2 id="1-网络IO"><a href="#1-网络IO" class="headerlink" title="1. 网络IO"></a>1. 网络IO</h2><blockquote><p>io函数都有两个作用</p></blockquote><ol><li>io 检测&#x3D;&#x3D;是否就绪&#x3D;&#x3D;</li><li>io 操作</li></ol><img src="https://telegraph-image-9wl.pages.dev/file/0c9ca246cc97757fa1103.png" alt="image-20240302202909659" style="zoom:40%;" /><blockquote><p>accept 作用时机</p></blockquote><p>​TCP三次握手时，&#x3D;&#x3D;server&#x3D;&#x3D;第一次收到消息，将其放入&#x3D;&#x3D;半连接&#x3D;&#x3D;队列，第二次收到消息，将其放入&#x3D;&#x3D;全连接&#x3D;&#x3D;队列。</p><p>​<code>accept</code>检测&#x3D;&#x3D;全连接队列&#x3D;&#x3D;是否有数据。</p><blockquote><p>connect 成功条件</p></blockquote><p>​TCP三次握手时，&#x3D;&#x3D;client&#x3D;&#x3D;收到服务端确认回复时，表示建立成功。</p><blockquote><p>read &#x3D; 0 被动断开</p></blockquote><p>​TCP四次挥手时，&#x3D;&#x3D;client&#x3D;&#x3D;发送&#x3D;&#x3D;FIN&#x3D;&#x3D;数据包，里面有&#x3D;&#x3D;EoF&#x3D;&#x3D;数据段。&#x3D;&#x3D;server&#x3D;&#x3D;的<code>read()/recv()</code>读取buffer 数据时，检测到&#x3D;&#x3D;EoF&#x3D;&#x3D;，返回 0. </p><blockquote><p>read() 、write() 作用时机</p></blockquote><p>​<code>read、write</code>一直检测内核空间对应&#x3D;&#x3D;buffer&#x3D;&#x3D;中数据。阻塞一直等待，直到&#x3D;&#x3D;buffer&#x3D;&#x3D;中有数据；非阻塞没有数据则返回。</p><ul><li><p><code>int n = read(clientfd, buf, sz);</code></p></li><li><p><code>int n = write(clientfd, buf, sz);</code></p></li><li><p>向&#x3D;&#x3D;buf中&#x3D;&#x3D;读&#x2F;写sz长度数据，返回实际读&#x2F;写长度数据。只要&#x3D;&#x3D;n&gt;0就算成功&#x3D;&#x3D;。</p></li></ul><img src="https://telegraph-image-9wl.pages.dev/file/e653fb00a737e910413e7.png" alt="image-20240302203801515" style="zoom:23%;" /><h2 id="2-reactor"><a href="#2-reactor" class="headerlink" title="2. reactor"></a>2. reactor</h2><h3 id="1-epoll-模式的问题"><a href="#1-epoll-模式的问题" class="headerlink" title="1. epoll 模式的问题"></a>1. epoll 模式的问题</h3><ol><li>对于 io 未读完的数据，不好存储。（收发同步）</li><li>就绪 io 占比较少。</li></ol><h3 id="2-reactor-是什么？"><a href="#2-reactor-是什么？" class="headerlink" title="2. reactor 是什么？"></a>2. reactor 是什么？</h3><ol><li><p>事件驱动 <code>EPOLLIN / EPOLLOUT</code></p></li><li><p>回调</p><p><code>listenfd ----&gt; accept_cb</code> </p><p><code>clientfd ----&gt; recv_cb</code> </p><p><code>clientfd ----&gt; send_cb</code></p></li><li><p>业务与网络分离</p></li></ol><blockquote><p>服务器性能指标</p></blockquote><ol><li>并发 （同时承载的客户端数量）</li><li>qps</li><li>最大时延</li><li>新建连接数（建链）</li><li>吞吐量</li></ol><blockquote><p>回调函数别名</p></blockquote><p><code>typedef int (*ZVCALLBACK)(int fd,int event,void* arg);</code></p><h3 id="3-reactor-补充"><a href="#3-reactor-补充" class="headerlink" title="3. reactor 补充"></a>3. reactor 补充</h3><blockquote><p>io 多路复用</p></blockquote><ul><li>只有&#x3D;&#x3D;io检测功能&#x3D;&#x3D;</li><li>可以&#x3D;&#x3D;检测多条&#x3D;&#x3D;连接的io状态</li><li>&#x3D;&#x3D;不能操作&#x3D;&#x3D;具体io&#x3D;&#x3D;功能&#x3D;&#x3D;</li><li>&#x3D;&#x3D;同步io&#x3D;&#x3D;（select、poll、epoll都是同步io），即执行了函数就能得到准确的结果。</li><li>&#x3D;&#x3D;事件是异步&#x3D;&#x3D;的。</li></ul><blockquote alt="warn">    <p>        int n = epoll_wait(epfd,events,events_size,timeout); 只要执行了这个函数，就能知道 n 的值。    </p></blockquote>> reactor 作用<ul><li>让 &#x3D;&#x3D;io 多路复用&#x3D;&#x3D;进行多连接的 io 检测。</li><li>用&#x3D;&#x3D;循环对有状态反应&#x3D;&#x3D;的事件进行 io 操作（callback）。</li></ul><blockquote><p>reactor 模版</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/eedd011db3c1e037ebafd.png" alt="image-20240302213004441" style="zoom:67%;" /><blockquote><p>reactor 构成部分</p></blockquote><ol><li>事件封装 callback</li><li>事件的注册、注销 epoll_ctl</li><li>事件循环</li></ol><blockquote><p>reactor 把对 io 的处理转化为对事件的处理</p></blockquote><ol><li>io 多路复用检测就绪io</li><li>遍历所有有事件发生的io，并进行回调处理。</li></ol><blockquote><p>one eventloop per thread</p></blockquote><ol><li>一个线程最多只有一个epoll对象</li><li>每个线程的epoll对象epfd要不同</li></ol><blockquote><p>网络模块与业务逻辑的关系</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/1756ea35b67f8b728d7c4.png" alt="image-20240302215755516" style="zoom:67%;" /><blockquote><p>为什么 reactor 把 io 就绪检测功能丢给 io多路复用来做？而不是让 io 函数自己检测？</p></blockquote><ul><li>提升性能</li><li>可能存在很多连接，但是&#x3D;&#x3D;大部分连接都没有 io 操作&#x3D;&#x3D;，io 多路复用让 reactor 重点&#x3D;&#x3D;关注有状态反应&#x3D;&#x3D;的 io 。</li><li>&#x3D;&#x3D;io 函数自己做io检测&#x3D;&#x3D;，&#x3D;&#x3D;阻塞每个连接需要一个线程&#x3D;&#x3D;不断检测，&#x3D;&#x3D;非阻塞每个连接需要循环在应用层&#x3D;&#x3D;不断检测，性能差。</li></ul><blockquote><p>为什么 reactor 搭配非阻塞 io</p></blockquote><ol><li>多线程环境：多个线程监听1个listenFd，当一个线程accept成功时，其余线程会返回-1。如果使用阻塞io，则本应返回-1的线程会持续阻塞。</li><li>边缘触发：读事件需要把read buffer读空，此时其余线程如果是阻塞io，则会一直阻塞在read</li><li>select bug： 当数据到达时，select将会报告读事件。但是这个数据可能没有通过校验而被丢弃，而select已经上报读事件了，如果此时是阻塞io read，则会阻塞线程。</li></ol><blockquote><p>io 多路复用搭配阻塞io 的情况</p></blockquote><ol><li>MySQL</li><li>libevent</li></ol><h3 id="4-IO-多路复用工作流程"><a href="#4-IO-多路复用工作流程" class="headerlink" title="4. IO 多路复用工作流程"></a>4. IO 多路复用工作流程</h3><img src="https://telegraph-image-9wl.pages.dev/file/d2b74a22b4587c690db3b.png" alt="image-20240302210631581" style="zoom:30%;" /><blockquote><p>各个fd约定 </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/4588ce232a32c0f94ad9d.png" alt="image-20240302212556932" style="zoom:70%;" /><blockquote><p>连接建立</p></blockquote><ol><li><p>被动连接：io 多路复用&#x3D;&#x3D;监听 listenFd 的读&#x3D;&#x3D;事件</p></li><li><p>主动连接：io 多路复用&#x3D;&#x3D;监听 connectFd的写&#x3D;&#x3D;事件</p></li></ol><blockquote alt="warn">    <p>        主动连接监听写事件，是因为 connect 成功的条件是接受对方发送的ACK确认，此时刚好能写数据。    </p></blockquote><blockquote><p>连接断开</p></blockquote><p>​TCP是全双工模式，服务端既能读也能写。</p><ol><li>&#x3D;&#x3D;EPOLLRDHUB&#x3D;&#x3D; server 读端关闭。</li><li>&#x3D;&#x3D;EPOLLHUB&#x3D;&#x3D; server 读写端都关闭。</li></ol><blockquote><p>消息接受</p></blockquote><ol><li>监听 &#x3D;&#x3D;clientFd 的读&#x3D;&#x3D;事件。</li><li>&#x3D;&#x3D;EPOLLIN&#x3D;&#x3D;</li></ol><blockquote><p>消息发送</p></blockquote><ol><li>监听&#x3D;&#x3D;clientFd的写&#x3D;&#x3D;事件。</li><li>&#x3D;&#x3D;EPOLLOUT&#x3D;&#x3D;</li><li><code>int n = write(clientfd, buf, sz);</code>当 &#x3D;&#x3D;n &lt; sz&#x3D;&#x3D; 时，表示&#x3D;&#x3D;write buffer&#x3D;&#x3D;中没有剩余空间，此时需要&#x3D;&#x3D;注册写事件&#x3D;&#x3D;。</li></ol><blockquote alt="warn">    <p>        注册写事件，即让io多路复用帮忙监听write buffer，一旦有空间，就将未写完的数据写入buffer。    </p></blockquote>## 3. reactor的应用<h3 id="1-redis"><a href="#1-redis" class="headerlink" title="1. redis"></a>1. redis</h3><img src="https://telegraph-image-9wl.pages.dev/file/08059db4cef8fa061120b.png" alt="image-20240302220321053" style="zoom:70%;" /><blockquote><p>单 reactor</p></blockquote><ol><li>一个线程使用reactor，产生一个epfd。</li></ol><blockquote alt="warn">    <p>        redis数据库中业务是对相同的数据进行操作，如果多线程则必须加锁，为了不加锁（存储的数据类型太多，加锁麻烦）而使用单线程。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/14e948a14c0c55d992441.png" alt="image-20240302220742481" style="zoom:50%;" /><ol start="2"><li>由于redis的业务模块（compute）只能当线程处理，可能会存在性能慢的情况。</li><li>将read、decode、encode、send等模块放到 io 线程池中处理。</li><li>业务模块，采用分治思想和采用不同数据结构实现相同的对象模型。</li></ol><h3 id="2-nginx"><a href="#2-nginx" class="headerlink" title="2. nginx"></a>2. nginx</h3><blockquote><p>多进程 reactor</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/55154ca2c04da7030d185.png" alt="image-20240302221436672" style="zoom:67%;" /><ol><li>master 创建listenfd bind监听</li><li>worker通过fork写时复制listenfd，即每个worker都有listenfd</li><li>worker 进程争夺 accept 锁</li><li>根据锁来建立新连接</li><li>之后的操作在连接的worker中进行</li></ol><h3 id="3-memcached"><a href="#3-memcached" class="headerlink" title="3. memcached"></a>3. memcached</h3><blockquote><p>多线程 reactor</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/88e4d2f1c1466f5083ff6.png" alt="image-20240302222025961" style="zoom:67%;" /><ol><li>主线程只进行accept。</li><li>根据cpu核心数，建立对应的reactor子线程。</li><li>每个子线程有一个队列，存放主线程给的新连接。</li><li>主线程和子线程通过pipe管道通信。</li></ol><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="1-reactor"><a href="#1-reactor" class="headerlink" title="1. reactor"></a>1. reactor</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by lkh on 24-2-29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENTS_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_PORT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> START_FD 3 <span class="comment">//从fd=3开始存储到connect中</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义ZVCALLBACK函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*ZVCALLBACK)</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义 reactor 结构体</span></span><br><span class="line"><span class="comment"> * zv_reactor ----&gt; zv_connBlock ----&gt; zv_connect</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zv_connBlock结构体</span></span><br><span class="line"><span class="comment"> * 存放每一个event对应的fd，最小的block</span></span><br><span class="line"><span class="comment"> * rBuffer 和 wBuffer 用于存放接受和发送的消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zv_connect_s</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">//epoll监听对应的fd</span></span><br><span class="line">    ZVCALLBACK cb;<span class="comment">//每个epoll对应的回调函数</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//包接受长度</span></span><br><span class="line">    <span class="comment">//？？count具体作用？？</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> rSize;<span class="comment">//recv的长度</span></span><br><span class="line">    <span class="type">int</span> rBuffer[BUFFER_SIZE];<span class="comment">//recv buffer</span></span><br><span class="line">    <span class="comment">//？？rBuffer 对应的类型是int？？</span></span><br><span class="line">    <span class="type">ssize_t</span> wSize;<span class="comment">//send的长度</span></span><br><span class="line">    <span class="type">int</span> wBuffer[BUFFER_SIZE];<span class="comment">//send buffer</span></span><br><span class="line"></span><br><span class="line">&#125;zv_connect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zv_connBlock结构体</span></span><br><span class="line"><span class="comment"> * 存放EVENTS_SIZE个zv_connect</span></span><br><span class="line"><span class="comment"> * 链表形式，方便扩展</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zv_connBlock_s</span>&#123;</span><br><span class="line">    zv_connect * block;<span class="comment">//每个block存放EVENTS_SIZE个zv_connect</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">zv_connBlock_s</span> *next;<span class="comment">//链表</span></span><br><span class="line">&#125;zv_connBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 指向zv_connBlock的头</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zv_reactor_s</span>&#123;</span><br><span class="line">    <span class="type">int</span> epfd;<span class="comment">//epoll实例fd</span></span><br><span class="line">    <span class="type">int</span> block_size;<span class="comment">//当前block的总块数</span></span><br><span class="line">    zv_connBlock *blockHeadr;<span class="comment">//指向zv_connBlock头</span></span><br><span class="line">&#125;zv_reactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 返回值：1成功，-1失败</span></span><br><span class="line"><span class="comment"> * 功能：初始化zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_reactor</span><span class="params">(zv_reactor* reactor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!reactor) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    reactor-&gt;blockHeadr = (zv_connBlock*)<span class="built_in">malloc</span>((EVENTS_SIZE) * <span class="built_in">sizeof</span> (zv_connect)</span><br><span class="line">            + <span class="built_in">sizeof</span> (zv_connBlock));</span><br><span class="line">    <span class="keyword">if</span>(!reactor-&gt;blockHeadr)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reactor-&gt;blockHeadr-&gt;block = (zv_connect*)(reactor-&gt;blockHeadr + <span class="number">1</span>);</span><br><span class="line">    reactor-&gt;blockHeadr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    reactor-&gt;block_size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 返回值：1成功，-1失败</span></span><br><span class="line"><span class="comment"> * 功能：销毁zv_reactor结构体（reactor内存，reactor存放的epfd，reactor本身指针）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dec_reactor</span><span class="params">(zv_reactor* reactor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!reactor) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!reactor-&gt;blockHeadr)&#123;</span><br><span class="line">        <span class="built_in">free</span>(reactor-&gt;blockHeadr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(reactor-&gt;epfd);</span><br><span class="line">    reactor = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：socket fd</span></span><br><span class="line"><span class="comment"> * 返回值：成功 0，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：使socket 能够被复用，不会报错：</span></span><br><span class="line"><span class="comment"> * /bind() error!: Address already in use</span></span><br><span class="line"><span class="comment"> * init server error!: Address already in use/</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ntySerReuseAddr</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">char</span> *)&amp;reuse, <span class="built_in">sizeof</span>(reuse));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：server监听ip和port</span></span><br><span class="line"><span class="comment"> * 返回值：监听socket fd，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：初始化服务器</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_server</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> socket_listen = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ntySerReuseAddr</span>(socket_listen);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> lisAddr;</span><br><span class="line">    lisAddr.sin_family = AF_INET;</span><br><span class="line">    lisAddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    lisAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(socket_listen,(<span class="keyword">struct</span> sockaddr*)&amp;lisAddr,<span class="built_in">sizeof</span> (lisAddr))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">listen</span>(socket_listen,LISTEN_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen: %d\n&quot;</span>,port);</span><br><span class="line">    <span class="keyword">return</span> socket_listen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：zv_reactor结构体，连接fd，回调函数</span></span><br><span class="line"><span class="comment"> * 返回值：成功 1，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：设置reactor中connect的 fd，回调函数cb，和epoll对应事件</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_reactor_listen</span><span class="params">(zv_reactor *reactor,<span class="type">int</span> fd, ZVCALLBACK cb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!reactor || !reactor-&gt;blockHeadr) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    reactor-&gt;blockHeadr-&gt;block-&gt;fd = fd;</span><br><span class="line">    reactor-&gt;blockHeadr-&gt;block-&gt;cb = cb;</span><br><span class="line"></span><br><span class="line">    reactor-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(reactor-&gt;epfd,EPOLL_CTL_ADD,fd,&amp;event);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：zv_reactor结构体、事件fd</span></span><br><span class="line"><span class="comment"> * 返回值：事件fd对应的connect的地址</span></span><br><span class="line"><span class="comment"> * 功能：寻找事件fd对应的connect块，没有则创建</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">zv_connect* <span class="title">zv_connect_idx</span><span class="params">(zv_reactor *reactor, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!reactor) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> blk = fd / EVENTS_SIZE;<span class="comment">//目前fd应该存放在哪一块</span></span><br><span class="line">    zv_connBlock *block = reactor-&gt;blockHeadr;</span><br><span class="line">    <span class="comment">//fd是顺序生成，理论上不会比当前存在blokc大2+</span></span><br><span class="line">    <span class="keyword">if</span>(blk &gt; reactor-&gt;block_size + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fd 数据不正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(blk &gt; reactor-&gt;block_size)&#123;</span><br><span class="line">        <span class="comment">//移动到block链表末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;reactor-&gt;block_size;i++)&#123;</span><br><span class="line">            block = reactor-&gt;blockHeadr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        block-&gt;next = (zv_connBlock*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (zv_connBlock));</span><br><span class="line">        block-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到fd存在哪个块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;blk;i++)&#123;</span><br><span class="line">            block = reactor-&gt;blockHeadr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//START_FD 表示 fd为 0 1 2不存储，从3开始</span></span><br><span class="line">    <span class="keyword">return</span> block-&gt;block + (fd%EVENTS_SIZE - START_FD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：epoll的fd，事件fd，zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 返回值：成功 1，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：accept回调函数，进行监听socket的accept()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_cb</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;accept_cb()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!arg) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">    <span class="type">int</span> cliLen = <span class="built_in">sizeof</span> (cliLen);</span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">accept</span>(fd,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,(<span class="type">socklen_t</span>*)&amp;cliLen);</span><br><span class="line">    <span class="keyword">if</span>(client_socket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;client_socket() error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储新连接的clientfd</span></span><br><span class="line">    <span class="keyword">auto</span> *reactor = (zv_reactor *)arg;</span><br><span class="line">    zv_connect *conn = <span class="built_in">zv_connect_idx</span>(reactor,client_socket);</span><br><span class="line">    conn-&gt;cb = recv_cb;</span><br><span class="line">    conn-&gt;fd = client_socket;</span><br><span class="line"><span class="comment">//    conn-&gt;count = BUFFER_SIZE;//能够读取的数据长度</span></span><br><span class="line">    <span class="comment">//设置新事件fd</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.data.fd =client_socket;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(reactor-&gt;epfd,EPOLL_CTL_ADD,client_socket,&amp;ev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：epoll的fd，事件fd，zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 返回值：成功 1，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：recv回调函数，accept() 后进行recv()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv_cb</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv_cb\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!arg) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">ssize_t</span> recvSize = <span class="built_in">recv</span>(fd,buf,BUFFER_SIZE,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> *reactor = (zv_reactor *)arg;</span><br><span class="line">    zv_connect *conn = <span class="built_in">zv_connect_idx</span>(reactor,fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == recvSize)&#123;</span><br><span class="line">        <span class="built_in">close</span>(conn-&gt;fd);</span><br><span class="line">        conn-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">        conn-&gt;wSize = <span class="number">0</span>;</span><br><span class="line">        conn-&gt;rSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(reactor-&gt;epfd,EPOLL_CTL_DEL,fd, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;断开连接：%d&quot;</span>,fd);</span><br><span class="line">        <span class="comment">//断开连接</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> &gt; recvSize)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv() error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//正常接收</span></span><br><span class="line">        buf[recvSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        recvSize += <span class="number">1</span>;</span><br><span class="line">        conn-&gt;cb = send_cb;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">        ev.data.fd = fd;</span><br><span class="line">        ev.events = EPOLLOUT;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(reactor-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">        <span class="built_in">memcpy</span>(conn-&gt;rBuffer,buf,recvSize);</span><br><span class="line">        conn-&gt;rSize = recvSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：epoll的fd，事件fd，zv_reactor结构体</span></span><br><span class="line"><span class="comment"> * 返回值：成功 1，失败 -1</span></span><br><span class="line"><span class="comment"> * 功能：recv回调函数，accept() 后进行recv()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_cb</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> event,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send_cb\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!arg) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> *reactor = (zv_reactor*)arg;</span><br><span class="line">    zv_connect *conn = <span class="built_in">zv_connect_idx</span>(reactor,fd);</span><br><span class="line">    <span class="type">ssize_t</span> sendSize = <span class="built_in">send</span>(fd,conn-&gt;rBuffer,conn-&gt;rSize,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(reactor-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">    conn-&gt;cb = recv_cb;</span><br><span class="line">    conn-&gt;wSize = sendSize;</span><br><span class="line">    <span class="built_in">memcpy</span>(conn-&gt;wBuffer,conn-&gt;rBuffer,sendSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    zv_reactor reactor;</span><br><span class="line">    <span class="built_in">init_reactor</span>(&amp;reactor);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = <span class="string">&quot;192.168.1.223&quot;</span>;</span><br><span class="line">    <span class="type">int</span> port = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; OPEN_PORT;i++)&#123;</span><br><span class="line">        <span class="type">int</span> socket_listen = <span class="built_in">init_server</span>(ip,port+i);</span><br><span class="line">        <span class="keyword">if</span>(socket_listen&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;init server error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set_reactor_listen</span>(&amp;reactor,socket_listen,accept_cb)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;set reactor listen error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[EVENTS_SIZE];</span><br><span class="line">    <span class="comment">//epoll pool</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(reactor.epfd,events,EVENTS_SIZE,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">            <span class="type">int</span> connfd = events[i].data.fd;</span><br><span class="line">            zv_connect *conn = <span class="built_in">zv_connect_idx</span>(&amp;reactor,connfd);</span><br><span class="line">            <span class="keyword">if</span>(!conn)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;connect index error!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                conn-&gt;<span class="built_in">cb</span>(connfd,EPOLLIN,&amp;reactor);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT)&#123;</span><br><span class="line">                conn-&gt;<span class="built_in">cb</span>(connfd,EPOLLOUT,&amp;reactor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnomalyGPT</title>
      <link href="/2024/03/02/%E7%A7%91%E7%A0%94-4-AnomalyGPT/"/>
      <url>/2024/03/02/%E7%A7%91%E7%A0%94-4-AnomalyGPT/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="AnomalyGPT"><a href="#AnomalyGPT" class="headerlink" title="AnomalyGPT"></a>AnomalyGPT</h1><blockquote><p>AAAI 2024</p></blockquote><blockquote><p>中国科学院自动化研究所，Zhaopeng Gu，Bingke Zhu</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/48e47db1fa6ec57ffd202.png" style="zoom:50%;"  >]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc、calloc和realloc区别.md</title>
      <link href="/2024/03/01/C-%E7%9F%A5%E8%AF%86%E7%82%B9-1-malloc%E3%80%81calloc%E5%92%8Crealloc%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/03/01/C-%E7%9F%A5%E8%AF%86%E7%82%B9-1-malloc%E3%80%81calloc%E5%92%8Crealloc%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="malloc、calloc和realloc区别"><a href="#malloc、calloc和realloc区别" class="headerlink" title="malloc、calloc和realloc区别"></a>malloc、calloc和realloc区别</h1><h2 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h2><h3 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1. malloc"></a>1. malloc</h3><blockquote><p>malloc</p></blockquote><ul><li><code>void* malloc (size_t size);</code></li><li>从堆申请&#x3D;&#x3D;size&#x3D;&#x3D;字节数 &#x3D;&#x3D;未初始化&#x3D;&#x3D;空间。</li><li>成功返回地址，失败NULL。</li></ul><h3 id="2-calloc"><a href="#2-calloc" class="headerlink" title="2. calloc"></a>2. calloc</h3><blockquote><p>calloc</p></blockquote><ul><li><code>void* calloc (size_t num, size_t size);</code></li><li>从堆申请&#x3D;&#x3D;num X size&#x3D;&#x3D;字节数 &#x3D;&#x3D;初始化0&#x3D;&#x3D;空间。</li><li>成功返回地址，失败NULL。</li></ul><h3 id="3-realloc"><a href="#3-realloc" class="headerlink" title="3. realloc"></a>3. realloc</h3><blockquote><p>realloc</p></blockquote><ul><li><code>void* realloc (void* ptr, size_t size);</code></li><li>从已经分配好的内存中&#x3D;&#x3D;重新分配，不会初始化&#x3D;&#x3D;</li><li>&#x3D;&#x3D;没有申请&#x3D;&#x3D;，和<code>malloc</code>一样，字节分配</li><li>&#x3D;&#x3D;申请过&#x3D;&#x3D;的：<ul><li>&#x3D;&#x3D;新内存 &gt; 原内存&#x3D;&#x3D;：原内存上&#x3D;&#x3D;新增或拷贝&#x3D;&#x3D;到新地方。</li><li>&#x3D;&#x3D;新内存 &lt; 原内存&#x3D;&#x3D;：原内存上&#x3D;&#x3D;削减&#x3D;&#x3D;</li></ul></li><li>成功返回地址，失败NULL。</li></ul><h3 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h3><blockquote><p>new</p></blockquote><ul><li><p>new &#x3D;&#x3D;按照元素个数&#x3D;&#x3D;申请空间，&#x3D;&#x3D;自动检测元素类型&#x3D;&#x3D;，计算所需字节数</p></li><li><p><code>中括号[]</code>申请多个元素空间，<code>delete[]</code></p></li><li><p><code>小括号()</code>申请一个空间，并初始化，<code>delete</code></p></li><li><p><code>无括号</code>，申请空间不初始化，<code>delete</code></p></li><li><p>new 给&#x3D;&#x3D;自定义类型&#x3D;&#x3D;开辟空间时调用&#x3D;&#x3D;构造函数&#x3D;&#x3D;，释放调用&#x3D;&#x3D;析构函数&#x3D;&#x3D;。</p></li></ul><p><code>malloc</code>仅分配内存，不进行初始化，可能包含垃圾数据。</p><p><code>calloc</code>分配内存并将其初始化为零，适用于需要清零的数组或其他数据结构。</p><p><code>realloc</code>调整已分配内存的大小，可以用于动态数组等结构的内存管理。</p><h2 id="2-new-delete的底层调用"><a href="#2-new-delete的底层调用" class="headerlink" title="2. new&#x2F;delete的底层调用"></a>2. new&#x2F;delete的底层调用</h2><blockquote><p>operator new 和operator delete是系统提供的全局函数</p></blockquote><ul><li>&#x3D;&#x3D;new&#x3D;&#x3D; 调用&#x3D;&#x3D;operator new&#x3D;&#x3D;全局函数来申请空间，operator new再去调用&#x3D;&#x3D;malloc&#x3D;&#x3D;</li><li>成功直接返回，失败&#x3D;&#x3D;抛出异常&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;delete&#x3D;&#x3D;在底层通过&#x3D;&#x3D;operator delete&#x3D;&#x3D;全局函数来释放空间</li></ul><h2 id="3-malloc底层实现"><a href="#3-malloc底层实现" class="headerlink" title="3. malloc底层实现"></a>3. malloc底层实现</h2><h3 id="1-malloc-原理"><a href="#1-malloc-原理" class="headerlink" title="1. malloc 原理"></a>1. malloc 原理</h3><blockquote><p>malloc采用的是内存池的管理方式，以减少内存碎片。</p></blockquote><ul><li>先申请&#x3D;&#x3D;大块内存作为堆区&#x3D;&#x3D;，然后将堆区分为&#x3D;&#x3D;多个内存块&#x3D;&#x3D;。当用户申请内存时，直接从堆区&#x3D;&#x3D;分配一块合适的空闲块&#x3D;&#x3D;。</li><li>采用&#x3D;&#x3D;隐式链表将所有空闲块连接&#x3D;&#x3D;，每一个&#x3D;&#x3D;空闲块记录了一个未分配的、连续的内存地址&#x3D;&#x3D;。</li><li>当开辟的空间&#x3D;&#x3D;小于 128K&#x3D;&#x3D; 时，调用 &#x3D;&#x3D;brk 函数&#x3D;&#x3D;。</li><li>当开辟的空间&#x3D;&#x3D;大于 128K&#x3D;&#x3D; 时，调用 &#x3D;&#x3D;mmap 函数&#x3D;&#x3D;。</li></ul><h3 id="2-brk-函数"><a href="#2-brk-函数" class="headerlink" title="2. brk 函数"></a>2. brk 函数</h3><h3 id="3-mmap函数"><a href="#3-mmap函数" class="headerlink" title="3. mmap函数"></a>3. mmap函数</h3><h2 id="4-new-和-malloc-区别"><a href="#4-new-和-malloc-区别" class="headerlink" title="4.new 和 malloc 区别"></a>4.new 和 malloc 区别</h2><ol><li>new是&#x3D;&#x3D;操作符&#x3D;&#x3D;，malloc是&#x3D;&#x3D;函数&#x3D;&#x3D;（&#x3D;&#x3D;定义&#x3D;&#x3D;的角度）</li><li>new的参数是申请的&#x3D;&#x3D;元素个数&#x3D;&#x3D;，malloc的参数是申请&#x3D;&#x3D;空间所占字节数&#x3D;&#x3D;（&#x3D;&#x3D;参数&#x3D;&#x3D;的角度）</li><li>malloc的返回值是 &#x3D;&#x3D;void*&#x3D;&#x3D;，必须要&#x3D;&#x3D;强转&#x3D;&#x3D;，new不需要（&#x3D;&#x3D;返回类型&#x3D;&#x3D;）</li><li>给自定义类型开辟空间时，new会&#x3D;&#x3D;调用构造函数&#x3D;&#x3D;，malloc不会（特殊情况，&#x3D;&#x3D;自定义类型&#x3D;&#x3D;）</li><li>new发生&#x3D;&#x3D;错误&#x3D;&#x3D;是&#x3D;&#x3D;抛异常&#x3D;&#x3D;，malloc&#x3D;&#x3D;返回null&#x3D;&#x3D;</li></ol><p><a href="https://blog.csdn.net/challenglistic/article/details/123852957">new &#x2F; malloc &#x2F; calloc &#x2F; realloc的区别</a></p><p><a href="https://blog.csdn.net/be_programmer/article/details/104804501">brk 和 mmap 函数详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll 系统调用</title>
      <link href="/2024/02/27/C-%E9%9B%B6%E5%A3%B0linux-12-epoll-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2024/02/27/C-%E9%9B%B6%E5%A3%B0linux-12-epoll-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="epoll-系统调用"><a href="#epoll-系统调用" class="headerlink" title="epoll 系统调用"></a>epoll 系统调用</h1><h2 id="1-epoll"><a href="#1-epoll" class="headerlink" title="1. epoll"></a>1. epoll</h2><p>​ epoll 是 Linux 特有的 I&#x2F;O 多路复用机制，&#x3D;&#x3D;Mac、windows 不支持&#x3D;&#x3D;。</p><h3 id="1-epoll的数据结构"><a href="#1-epoll的数据结构" class="headerlink" title="1. epoll的数据结构"></a>1. epoll的数据结构</h3><p>​epoll 要为两个集合选择数据结构</p><ol><li>所有 fd 的总集</li><li>就绪 fd 的总集</li></ol><blockquote><p>所有 fd 的总集 —-&gt; &#x3D;&#x3D;红黑树&#x3D;&#x3D;</p></blockquote><p>​首先，对于&#x3D;&#x3D;一个 fd ，其底层对应一个 TCB&#x3D;&#x3D;，这是典型的 &#x3D;&#x3D;kv 型&#x3D;&#x3D;数据结构，那么只能从 hash、b&#x2F;b+树和红黑树进行选择。</p><ol><li><p>&#x3D;&#x3D;hash&#x3D;&#x3D; 查询快，但是我们创建 epoll 时并&#x3D;&#x3D;不知道究竟需要多大的数组&#x3D;&#x3D;，如果 hash 不断&#x3D;&#x3D;扩容成本很高&#x3D;&#x3D;，且&#x3D;&#x3D;hash的查询不稳定&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;b&#x2F;b+树&#x3D;&#x3D; 是一课多叉树，用于&#x3D;&#x3D;降低层高来增加查询效率&#x3D;&#x3D;，适合大量数据查询，主要&#x3D;&#x3D;用于磁盘索引，不适合内存索引场景&#x3D;&#x3D;。</p></li><li><p>&#x3D;&#x3D;红黑树&#x3D;&#x3D; 一般用于内存索引场景，其&#x3D;&#x3D;查询速度快&#x3D;&#x3D; $O(log(n))$，并且&#x3D;&#x3D;创建 epoll 时只需创建一个红黑树树根&#x3D;&#x3D;，无需额外空间。</p></li></ol><blockquote><p>就绪 fd 的总集 —-&gt; &#x3D;&#x3D;链表&#x3D;&#x3D;</p></blockquote><p>​就绪集合&#x3D;&#x3D;不是以查找为主&#x3D;&#x3D;的，就绪集合的作用是&#x3D;&#x3D;将里面的元素拷贝给用户进行处理&#x3D;&#x3D;，所以集合里的元素没有优先级，那么就可以采用&#x3D;&#x3D;线性&#x3D;&#x3D;的数据结构，使用&#x3D;&#x3D;队列&#x3D;&#x3D;来存储。</p><blockquote><p>红黑树与就绪队列的&#x3D;&#x3D;关系&#x3D;&#x3D;</p></blockquote><p>​红黑树的结点和就绪队列的结点的&#x3D;&#x3D;同一个节点&#x3D;&#x3D;，所谓的加入就绪队列，就是将结点的前后指针联系到一起。所以就绪了不是将红黑树结点delete掉然后加入队列。他们是同一个结点，&#x3D;&#x3D;不需要delete&#x3D;&#x3D;。</p><h3 id="2-协议栈触发回调"><a href="#2-协议栈触发回调" class="headerlink" title="2. 协议栈触发回调"></a>2. 协议栈触发回调</h3><blockquote><p>触发时机</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/2dddc31789b4100ddc4dd.jpg" style="zoom:100%;" ><ol><li>三次握手完成之后</li><li>接收数据回复ACK之后</li><li>发送数据收到ACK之后</li><li>接收FIN回复ACK之后 </li><li>接收RST(复位)回复ACK之后</li></ol><blockquote><p>epoll 匹配就绪io</p></blockquote><ol><li>ip头可以解析出源ip，目的ip和协议，从tcp头可以解析出源端口和目的端口，此时五元组就凑齐了。</li><li>socket fd — &#x3D;&#x3D;&lt; 源IP地址 , 源端口 , 目的IP地址 , 目的端口 , 协议 &gt;&#x3D;&#x3D; 一个fd就是一个五元组。</li><li>知道了fd，就能&#x3D;&#x3D;从红黑树中找到&#x3D;&#x3D;对应的结点。</li></ol><h3 id="3-epoll-线程锁"><a href="#3-epoll-线程锁" class="headerlink" title="3. epoll 线程锁"></a>3. epoll 线程锁</h3><blockquote><p>epoll 的三个 api</p></blockquote><ol><li><p><code>epoll_create()</code> —-&gt; 创建红黑树的根节点</p></li><li><p><code>epoll_ctl()</code> —-&gt; add 、del、mod 增加、删除、修改结点</p></li><li><p><code>epoll_wait()</code> —-&gt; 把就绪队列的结点copy到用户态放到events里面，跟recv函数很像</p></li></ol><blockquote><p>分析加锁</p></blockquote><ol><li>如果同时调用 <code>epoll_create()</code> ，那就是创建三颗红黑树，没有涉及到资源竞争，没有关系</li><li>如果同时调用 <code>epoll_ctl()</code> ，对&#x3D;&#x3D;同一颗红黑树进行增删改&#x3D;&#x3D;，这就涉及到资源竞争需要加锁了，此时我们&#x3D;&#x3D;对整棵树进行加锁&#x3D;&#x3D;</li><li>如果同时调用<code>epoll_wait()</code> ，其&#x3D;&#x3D;同时操作的是就绪队列&#x3D;&#x3D;，所以需要&#x3D;&#x3D;对就绪队列进行加锁&#x3D;&#x3D;。</li></ol><blockquote><p>加锁类型</p></blockquote><ol><li>对于红黑树这种节点比较多的时候，采用&#x3D;&#x3D;互斥锁来加锁&#x3D;&#x3D;</li><li>就绪队列就跟生产者消费者一样，结点是从协议栈回调函数来生产的，消费是epoll_wait()来消费。那么对于队列而言，用&#x3D;&#x3D;自旋锁&#x3D;&#x3D;（对于队列而言，插入删除比较简单，cpu自旋等待比让出的成本更低，所以用自旋锁）。</li></ol><h3 id="4-ET-与-LT"><a href="#4-ET-与-LT" class="headerlink" title="4. ET 与 LT"></a>4. ET 与 LT</h3><blockquote><p>ET 边沿触发</p></blockquote><ul><li>ET边沿触发，&#x3D;&#x3D;只触发一次&#x3D;&#x3D;</li><li>从协议栈检测到接收数据，就调用一次回调，这就是ET，&#x3D;&#x3D;接收到数据，调用一次回调&#x3D;&#x3D;</li></ul><blockquote><p>LT 水平触发</p></blockquote><ul><li>LT水平触发，如果&#x3D;&#x3D;没有读完就一直触发&#x3D;&#x3D;</li><li>LT水平触发，检测到 &#x3D;&#x3D;recvbuf 里面有数据就调用回调&#x3D;&#x3D;</li></ul><h3 id="5-代码原理"><a href="#5-代码原理" class="headerlink" title="5. 代码原理"></a>5. 代码原理</h3><img src="https://telegraph-image-9wl.pages.dev/file/b24757cd85b00bf9f08bd.jpg" style="zoom:100%;" ><ol><li><code>epoll_create()</code> 创建一个 &#x3D;&#x3D;eventpoll&#x3D;&#x3D; ，里面存储红黑树和就绪链表的&#x3D;&#x3D;头节点&#x3D;&#x3D; 。</li><li><code>epoll_ctl()</code> 创建&#x3D;&#x3D;每个事件&#x3D;&#x3D;的节点信息 &#x3D;&#x3D;epitem&#x3D;&#x3D; ，里面存储红黑树和就绪链表的&#x3D;&#x3D;节点&#x3D;&#x3D;</li><li><code>epoll_wait()</code> 返回&#x3D;&#x3D;就绪链表&#x3D;&#x3D;里面的数据。</li></ol><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6. 使用"></a>6. 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll</span></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[EVENT_SIZE];</span><br><span class="line">event.data.fd = listen_socket;</span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listen_socket,&amp;event);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(epfd,events,EVENT_SIZE,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">        <span class="type">int</span> eventFd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span>(eventFd == listen_socket)&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">            <span class="type">socklen_t</span> cliLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">            <span class="type">int</span> client_socket = <span class="built_in">accept</span>(eventFd,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,&amp;cliLen);</span><br><span class="line">            event.data.fd = client_socket;</span><br><span class="line">            event.events = EPOLLIN;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,client_socket,&amp;event);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">            <span class="type">int</span> recvLen = <span class="built_in">recv</span>(eventFd,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &gt;= recvLen)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 断开连接\n&quot;</span>,eventFd);</span><br><span class="line">                <span class="built_in">close</span>(eventFd);</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,eventFd,&amp;event);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,buf);</span><br><span class="line">            <span class="type">int</span> sendLen = <span class="built_in">send</span>(eventFd,buf,recvLen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="1-epoll-多路复用通信"><a href="#1-epoll-多路复用通信" class="headerlink" title="1. epoll 多路复用通信"></a>1. epoll 多路复用通信</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> lisAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;lisAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(lisAddr));</span><br><span class="line">    lisAddr.sin_family = AF_INET;</span><br><span class="line">    lisAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    lisAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="built_in">bind</span>(listen_socket, (<span class="keyword">struct</span> sockaddr *)&amp;lisAddr, <span class="built_in">sizeof</span>(lisAddr));</span><br><span class="line">    <span class="built_in">listen</span>(listen_socket, LISTEN_SIZE);</span><br><span class="line">    <span class="comment">// epoll</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[EVENT_SIZE];</span><br><span class="line">    event.data.fd = listen_socket;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listen_socket,&amp;event);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">epoll_wait</span>(epfd,events,EVENT_SIZE,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">            <span class="type">int</span> eventFd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(eventFd == listen_socket)&#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">                <span class="type">socklen_t</span> cliLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">                <span class="type">int</span> client_socket = <span class="built_in">accept</span>(eventFd,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,&amp;cliLen);</span><br><span class="line">                event.data.fd = client_socket;</span><br><span class="line">                event.events = EPOLLIN;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,client_socket,&amp;event);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">                <span class="type">int</span> recvLen = <span class="built_in">recv</span>(eventFd,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &gt;= recvLen)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d 断开连接\n&quot;</span>,eventFd);</span><br><span class="line">                    <span class="built_in">close</span>(eventFd);</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,eventFd,&amp;event);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,buf);</span><br><span class="line">                <span class="type">int</span> sendLen = <span class="built_in">send</span>(eventFd,buf,recvLen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/545309958?utm_id=0">epoll原理：协议栈与epoll通信</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select() 客户端 printf() 不打印</title>
      <link href="/2024/02/24/C-%E9%97%AE%E9%A2%98-4-select-%E5%AE%A2%E6%88%B7%E7%AB%AF-printf-%E4%B8%8D%E6%89%93%E5%8D%B0/"/>
      <url>/2024/02/24/C-%E9%97%AE%E9%A2%98-4-select-%E5%AE%A2%E6%88%B7%E7%AB%AF-printf-%E4%B8%8D%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h1><blockquote><p>​在学习 select() 函数实现多路 IO 复用时，遇到问题：客户端能够正常收发数据，而服务端却只能打印客户端第一次发送的数据，后续这个客户端发送数据都无法打印，只能打印新客户端第一次发送的数据。</p></blockquote><div style="display: flex; justify-content: space-around; align-items: center;">    <img src="https://telegraph-image-9wl.pages.dev/file/38104938908afdebb9910.png" alt="image-20240224110106018" style="width: 50%;">    <img src="https://telegraph-image-9wl.pages.dev/file/c47e8e5becea517f2bea8.png" alt="image-20240224110155790" style="width: 50%;"></div><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​printf() 在终端打印时，是行缓冲，需要 <code>&#39;\n&#39;</code> 或者 <code>fflush(stdout)</code> 刷新后才能正常打印。</p></blockquote><h1 id="3-stdout-的三种缓冲策略"><a href="#3-stdout-的三种缓冲策略" class="headerlink" title="3. stdout 的三种缓冲策略"></a>3. stdout 的三种缓冲策略</h1><h2 id="1-无缓冲"><a href="#1-无缓冲" class="headerlink" title="1. 无缓冲"></a>1. 无缓冲</h2><p>​标准错误输出（<code>stderr</code>）通常是无缓冲的，输出操作将直接写入目标（例如终端或文件），不经过缓冲区。</p><h2 id="2-行缓冲"><a href="#2-行缓冲" class="headerlink" title="2. 行缓冲"></a>2. 行缓冲</h2><p>​当输出被定向到终端（如控制台或命令行界面）时，<code>stdout</code>通常是行缓冲的。在行缓冲模式下，输出数据会被存储在缓冲区中，直到缓冲区满、手动刷新（使用<code>fflush</code>函数），或者遇到换行符（<code>\n</code>）时才实际写入目标。</p><h2 id="3-全缓冲"><a href="#3-全缓冲" class="headerlink" title="3. 全缓冲"></a>3. 全缓冲</h2><p>​当输出被重定向到文件或者程序不是直接与终端交互时（例如，通过管道连接到另一个程序），<code>stdout</code>通常是全缓冲的。在全缓冲模式下，输出数据会被积累在缓冲区中，直到缓冲区满或者调用<code>fflush</code>函数时才进行实际的写入操作。</p><blockquote alt="info">    <p>        <strong style="color:red;">        fflush(stdout);         </strong>        函数进行强制刷新缓冲区。    </p></blockquote># 4. std::endl 与 '\n'<blockquote><p><code>std::endl;</code>会刷新缓冲区，可能会影响性能。而<code>\n</code>不会刷新缓冲区。</p></blockquote><p>​<code>std::cout &lt;&lt; std::endl</code> 插入一个新行并刷新流（输出缓冲区），而 <code>std::cout &lt;&lt; &#39;\n&#39;</code> 只插入一个新行。因此， <code>std::cout &lt;&lt; std::endl;</code> 可以说等同于<code>std::cout&lt;&lt;&#39;\n&#39;&lt;&lt;std::flush;</code> <code>std::cout&lt;&lt;&#39;\n&#39;; std::fflush(stdout);</code></p><p><a href="https://blog.csdn.net/a_18067/article/details/101914147">输出流缓冲的意义</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文引用记录</title>
      <link href="/2024/02/23/%E7%A7%91%E7%A0%94-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/02/23/%E7%A7%91%E7%A0%94-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="工业异常检测"><a href="#工业异常检测" class="headerlink" title="工业异常检测"></a>工业异常检测</h1><h3 id="1-UCAD"><a href="#1-UCAD" class="headerlink" title="1. UCAD"></a>1. UCAD</h3><p>​<a href="https://arxiv.org/pdf/2401.01010.pdf">UCAD</a> (Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt)，AAAI 2024，<a href="https://github.com/shirowalker/UCAD">github（未上传）</a>。</p><blockquote><p>相关工作 —- 无监督工业异常检测&#x3D;&#x3D;两大类&#x3D;&#x3D;</p></blockquote><details>    <summary>        Feature-embedding-based methods    </summary>    <p>       &nbsp;&nbsp;&nbsp;&nbsp;Feature-embedding-based methods can be further cate-gorized into four subcategories, including teacher-student model (Bergmann et al. 2020; Salehi et al. 2021; Deng and Li 2022; Tien et al. 2023), one-class classification meth-ods (Li et al. 2021; Liu et al. 2023c), mapping-based meth-ods (Rudolph, Wandt, and Rosenhahn 2021; Gudovskiy,Ishizaka, and Kozuka 2022; Rudolph et al. 2022; Lei et al.2023) and memory-based methods (Defard et al. 2021; Rothet al. 2022; Jiang et al. 2022b; Xie et al. 2022; Liu et al.2023a).    </p></details><details>    <summary>        Reconstruction-based methods    </summary>    <p>       &nbsp;&nbsp;&nbsp;&nbsp;Reconstruction-based methods can be categorized based on the type of reconstruction network, including autoencoder-based methods (Zavrtanik, Kristan, and Skočaj 2021, 2022; Schlüter et al. 2022), Generative Adversarial Networks (GANs) based methods (Goodfellow et al. 2014; Yan et al. 2021; Liang et al. 2022), ViT-based methods (Mishra et al. 2021; Pirnay and Chai 2022; Jiang et al. 2022a), and Diffusion model-based methods (Mousakhan, Brox, and Tayyub 2023; Zhang et al. 2023).    </p></details>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt</title>
      <link href="/2024/02/22/%E7%A7%91%E7%A0%94-3-UCAD/"/>
      <url>/2024/02/22/%E7%A7%91%E7%A0%94-3-UCAD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="UCAD"><a href="#UCAD" class="headerlink" title="UCAD"></a>UCAD</h1><blockquote><p>AAAI 2024</p></blockquote><blockquote><p>南方科技大学，Jiaqi Liu，Kai Wu，Feng Zheng</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/2a512fa3e06ff4c31a979.png" alt="image-20240223101013966" style="zoom:60%;" /><blockquote><ol><li>第一个异常检测无监督增量学习</li><li>构建memory(Knowledge)，用于新类查找最相似</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>###1. 增量训练任务</p><p>​不可预测的缺陷使得获得工业异常检测&#x3D;&#x3D;获得足够的标记数据不可行&#x3D;&#x3D;。</p><h3 id="2-持续学习用于UAD（无监督异常检测）的问题"><a href="#2-持续学习用于UAD（无监督异常检测）的问题" class="headerlink" title="2. 持续学习用于UAD（无监督异常检测）的问题"></a>2. 持续学习用于UAD（无监督异常检测）的问题</h3><blockquote><p>​持续学习方法主要&#x3D;&#x3D;依赖于监督&#x3D;&#x3D;注释，而 UAD 缺乏监督。</p></blockquote><p>​当前的UAD方法依次为&#x3D;&#x3D;不同的类训练单独的模型&#x3D;&#x3D;，导致灾难性遗忘和沉重的计算负担。</p><blockquote><p>​一些方法只关注类内连续异常，&#x3D;&#x3D;忽略类间异常&#x3D;&#x3D;。</p></blockquote><p>​<a href="https://www.sciencedirect.com/science/article/abs/pii/S2452414X23000365?via=ihub">IDDM</a> 和 <a href="https://arxiv.org/abs/2107.12571">LeMo</a> 只关注类内连续异常，DNE（Towards Continual Adaptation in Industrial Anomaly Detection）和作者类似，但 DNE 仅存储类级信息的限制，它不能进行细粒度的定位，因此不适合异常分割。</p><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-UCAD是第一个在无监督异常检测和分割上进行任务不可知持续学习的框架。"><a href="#1-UCAD是第一个在无监督异常检测和分割上进行任务不可知持续学习的框架。" class="headerlink" title="1. UCAD是第一个在无监督异常检测和分割上进行任务不可知持续学习的框架。"></a>1. UCAD是第一个在无监督异常检测和分割上进行任务不可知持续学习的框架。</h3><p>​UCAD是第一个在无监督异常检测和分割上进行任务不可知持续学习的框架。</p><h3 id="2-持续提示模块-CPM"><a href="#2-持续提示模块-CPM" class="headerlink" title="2. 持续提示模块(CPM)"></a>2. 持续提示模块(CPM)</h3><blockquote><p>CPM用来来动态适应和指导无监督模型预测。</p></blockquote><p>​持续学习在异常检测中&#x3D;&#x3D;遇到问题&#x3D;&#x3D;：</p><ol><li>如何自动确定输入图像的任务身份</li><li>如何以无监督的方式引导模型对相关任务的预测</li></ol><p>​CPM学习一个&#x3D;&#x3D;“key-prompt-knowledge”内存空间来存储&#x3D;&#x3D;自动选择的任务查询、任务适应提示和不同类的“正常”知识。</p><h3 id="3-对比学习-SCL-模块"><a href="#3-对比学习-SCL-模块" class="headerlink" title="3. 对比学习(SCL)模块"></a>3. 对比学习(SCL)模块</h3><blockquote><p>SCL 从各种任务中提取更紧凑的特征。</p></blockquote><ol><li><p>工业图像主要包含&#x3D;&#x3D;纹理和边缘结构&#x3D;&#x3D;信息，不同工业产品图像之间的&#x3D;&#x3D;相似性很高&#x3D;&#x3D;。这允许使用更少的特征来表示正常的工业图像。</p></li><li><p>冻结主干(ViT)&#x3D;&#x3D;不能跨各种任务提供紧凑的特征&#x3D;&#x3D;表示，CPM模块 的性能受到限制。</p></li></ol><p>​SCL利用SAM的分割能力来减少域间隙，设计对比学习使&#x3D;&#x3D;同一结构(分段区域)的特征被拉到一起&#x3D;&#x3D;，并从其他结构的特征中推开。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-持续提示模块-CPM"><a href="#1-持续提示模块-CPM" class="headerlink" title="1. 持续提示模块(CPM)"></a>1. 持续提示模块(CPM)</h3><p>​给定图像，将自动选择键以检索相应的任务提示。根据提示，进一步提取图像特征，并与其正常知识进行比较，进行异常检测。</p><p>​内存空间 $M$ 来存储键提示知识架构 &#x3D;&#x3D;key-prompt-knowledge&#x3D;&#x3D; $(Ke, V, Kn)$，该架构包含两个不同的阶段:</p><ol><li>任务识别（Key）。</li><li>任务适应（prompt &amp;&amp; knowledge）。</li></ol><blockquote><p>Key 的获取 $K_e$ &#x3D;&#x3D;任务标识&#x3D;&#x3D;</p></blockquote><ol><li>将原始图像通过ViT，得到&#x3D;&#x3D;任务标识&#x3D;&#x3D;。$f_i$ 是ViT的第 $i$ 层，$N_p$ 表示经过第 $i$ 个块后 patch 数。（这里 $k$ 是累积 $i$ 层后的结果）</li></ol><p>$$<br>k &#x3D; f^i(x) ，x\in R_{图像}^{H\times W \times \C}，k \in \mathbb{R}^{N_p \times C}<br>$$</p><ol start="2"><li>由于该任务需要对&#x3D;&#x3D;多个任务进行训练&#x3D;&#x3D;，因此提取到特征如下</li></ol><p>$$<br>K_t \in \mathbb{R}^{N_I \times N_p \times C}<br>$$</p><ol start="3"><li>为了提高匹配效率和较少内存空间，用&#x3D;&#x3D;一张图像代表整个任务&#x3D;&#x3D;。</li></ol><p>$$<br>\mathbb{R}^{N_I \times N_p \times C} \rightarrow \mathbb{R}^{N_p \times C}<br>$$</p><ol start="4"><li>&#x3D;&#x3D;最远点采样方法&#x3D;&#x3D; (Eldar et al. 1997) 对于选择代表性特征作为键是有效的。$FPS$ 表示最远点采样，$t$ 表示有 $t$ 个任务。</li></ol><p>$$<br>K_e^t &#x3D; {FPS}(K_t) ，K_e^t \in \mathbb{R}^{N_p \times C}<br>$$</p><p>$$<br>K_e&#x3D; {K_{e}^0, K_{e}^1, …, K_{e}^t}， t \in \mathbb{N}_{\text{task}}<br>$$</p><blockquote><p>Prompt 的获取 $V$ &#x3D;&#x3D;任务相关信息转移到当前图像&#x3D;&#x3D;</p></blockquote><ol><li>设计的可学习Prompt $V$ ，添加到ViT模型的&#x3D;&#x3D;每一层&#x3D;&#x3D;中。</li></ol><p>$$<br>k^i &#x3D; f^i(k^{i-1} + p^i), \quad p \in V<br>$$</p><blockquote><p>knowledge 的获取 $K_n$ &#x3D;&#x3D;知识存储&#x3D;&#x3D;</p></blockquote><p>​由于没有使用监督，因此用 $K_n$ 作为评价标准，通过&#x3D;&#x3D;将异常数据与测试图像特征进行比较&#x3D;&#x3D;来区分异常数据。</p><ol><li>任务转移图像特征 $k^i$ 来创建，并使用&#x3D;&#x3D;核心集采样&#x3D;&#x3D;(Roth et al. 2022)来减少$V$的存储。$M$ 为训练时的标称图像特征，$M_c$为经过&#x3D;&#x3D;核心集采样&#x3D;&#x3D;的 patch 级特征 $k^i$。</li></ol><p>$$<br>K_n &#x3D; \text{CoreSetSampling}(k^i) &#x3D; \underset{M_c \subset M}{\arg\min} \ \max_{m \in M} \ \min_{n \in M_c} \ ||m - n||_2<br>$$</p><blockquote alt="danger">    <p>        没有使用监督，因此 Kn 作为标准，通过将        <strong style="color:red;">        异常数据与测试图像特征进行比较        </strong>        来区分异常数据    </p></blockquote><blockquote alt="info">    <p>        公式理解    </p></blockquote>​该公式目标是找到一个子集 $M_c$，使得对于 $M$ 中的任何特征 $m$，其到 $M_c$ 中最近的特征 $n$ 的欧式距离 $∣∣m−n∣∣_2  $ 最大值被最小化。​简而言之，这意味着希望 $Mc$ 中的点能够尽可能覆盖 $M$ 中的所有点，使得 $M$ 中任何点到 $M_C$ 的距离都尽可能小。<h3 id="2-对比学习-SCL-模块"><a href="#2-对比学习-SCL-模块" class="headerlink" title="2. 对比学习(SCL)模块"></a>2. 对比学习(SCL)模块</h3><p>​对ViT特征和SAM分割特征，使其&#x3D;&#x3D;同一结构的特征被拉到一起，其他结构的特征推开&#x3D;&#x3D;。</p><ol><li>使用&#x3D;&#x3D;SAM&#x3D;&#x3D;获取结构知识，获取分割图像 $I_s$</li><li>获取ViT每层特征 $F_s \in k^i$</li><li>分割图像 $I_s$ 大小对其  $F_s \in R^{c \times h \times w}$ ，以获取位置标签 $L_s$</li><li>使用对比学习，凸显结构特征。$F_{ij}$ 表示 $(i, j)$ 位置的ViT层特征，$L_{ij}$ 表示对应位置标签，$F_{pq}$ 和$L_{pq}$ 表示SAM分割对应的特征和位置标签。</li></ol><p>$$<br>L_{\text{pos_con}} &#x3D; \sum_{i,p}^{H} \sum_{j,q}^{W} \cos(F_{ij}, F_{pq}), \quad (L_{ij} &#x3D; L_{pq}),<br>$$</p><p>$$<br>L_{\text{neg_con}} &#x3D; \sum_{i,p}^{H} \sum_{j,q}^{W} \cos(F_{ij}, F_{pq}), \quad (L_{ij} \neq L_{pq}),<br>$$</p><p>$$<br>L_{\text{total}} &#x3D; \lambda_{\alpha} L_{\text{neg con}} - \lambda_{\beta} L_{\text{pos con}}.<br>$$</p><h3 id="3-推理时，新任务的处理"><a href="#3-推理时，新任务的处理" class="headerlink" title="3. 推理时，新任务的处理"></a>3. 推理时，新任务的处理</h3><p>​图像 $x^{test}$ 通过在 $K_e$ （Key）中匹配相似性最高的值，来自动确定任务身份。<br>$$<br>K_e^t &#x3D; \arg \min_{m \in K_e} {Sim}(m - m^{test})<br>$$</p><p>$$<br>{Sim}(m - m^{test}) &#x3D; \sum_{x \in N_p} \min_{y \in N_p} ||m_x - m_{y}^{test}||_2<br>$$</p><p>​$m^{test}$ 是推理输入图像 $x^{test}$ 经过多层ViT后的特征（累积 $i$ 层后的结果）。</p><h3 id="4-推理时，异常分数计算"><a href="#4-推理时，异常分数计算" class="headerlink" title="4. 推理时，异常分数计算"></a>4. 推理时，异常分数计算</h3><p>$$<br>m^{test,<em>}, m^</em> &#x3D; \arg \max_{m^{test} \in P(x^{test})}\arg \min_{m \in K^t_n} \lVert m^{test} - m \rVert_2，m^* \in K^t_n<br>$$</p><p>​$P(x^{test})$ 为测试集特征，$K^t_n$ 为知识存储（knowledge）。上述公式为求与 $K^t_n$ 最接近的特征  $m^{test,<em>}$ 。<br>$$<br>s^</em> &#x3D; \lVert m^{test,<em>} - m^</em> \rVert_2<br>$$</p><p>$$<br>s &#x3D; \left( 1 - \frac{\exp \left( \lVert m^{\text{test},<em>} - m^</em> \rVert_2 \right)}{\sum_{m \in N_b(m^*)} \exp \left( \lVert m^{\text{test},<em>} - m \rVert_2 \right)} \right) \cdot s^</em><br>$$</p><p>​上述公式中，前项为基础异常分数，后项 $s^*$ 为权重。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/e41ced359e4c431481fba.png" alt="image-20240226162429712" style="zoom:50%;" /><p><a href="https://arxiv.org/pdf/2401.01010.pdf">论文链接</a></p><p><a href="https://github.com/shirowalker/UCAD">代码链接（未上传）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络 io 与 select，poll</title>
      <link href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
      <url>/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="网络-io-与-select，poll"><a href="#网络-io-与-select，poll" class="headerlink" title="网络 io 与 select，poll"></a>网络 io 与 select，poll</h1><h2 id="1-简单的WebSocket"><a href="#1-简单的WebSocket" class="headerlink" title="1. 简单的WebSocket"></a>1. 简单的WebSocket</h2><div style="text-align:center;">    <img src="https://telegraph-image-9wl.pages.dev/file/f2b8e3524dd1f08b33efa.jpg" alt="tcp socket" style="zoom:65%;" />    <img src="https://telegraph-image-9wl.pages.dev/file/c1160960eeddd19999f53.jpg" alt="udp socket" style="zoom:40%;" /></div>### 1. socket 函数<blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> af,<span class="comment">//地址类型，ipv4: AF_INET; ipv6: AF_INET6。af(address family)</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> type,<span class="comment">//套接字类型，TCP: SOCK_STREAM; UDP: SOCK_DGRAM。DGRAM(datagram socket)</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> protocol<span class="comment">//协议类型，一般设0，自动选择</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功为 新创建socket的文件描述符，失败为 -1。</span></span><br></pre></td></tr></table></figure><blockquote><p>使用案例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == listen_socket )&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-bind-函数"><a href="#2-bind-函数" class="headerlink" title="2. bind 函数"></a>2. bind 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s, <span class="comment">//创建的socket</span></span></span></span><br><span class="line"><span class="params"><span class="function">sockaddr * name, <span class="comment">//包含地址和端口的结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> namelen <span class="comment">//sockaddr 结构长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败 -1</span></span><br></pre></td></tr></table></figure><blockquote><p>使用案例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;<span class="comment">//sockaddr_in结构体</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));<span class="comment">//将addr中数据置 0</span></span><br><span class="line">addr.sin_family = AF_INET;<span class="comment">//结构体地址类型</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(PORT);<span class="comment">//结构体端口</span></span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//监听IP地址为所有</span></span><br><span class="line"><span class="comment">//addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line"><span class="comment">//inet_aton(&quot;127.0.0.1&quot;,&amp;(addr.sin_addr));//监听指定ip地址</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(listen_socket,(sockaddr *)&amp;addr,<span class="built_in">sizeof</span>(addr));<span class="comment">//绑定socket()</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-listen-函数"><a href="#3-listen-函数" class="headerlink" title="3. listen 函数"></a>3. listen 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s, <span class="comment">//要监听的socket</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> backlog <span class="comment">//等待连接的最大队列长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功 0，失败 -1</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="built_in">listen</span>(listen_socket,LISTEN_NUMBER);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-accept-函数"><a href="#4-accept-函数" class="headerlink" title="4. accept 函数"></a>4. accept 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s, <span class="comment">//接收的socket</span></span></span></span><br><span class="line"><span class="params"><span class="function">sockaddr* addr, <span class="comment">//接收到客户端的地址信息</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> * addrlen <span class="comment">//地址信息长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功返回客户端的套接字，可进行发送和接收消息，失败 -1</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (cliAddr));</span><br><span class="line"><span class="type">int</span> cliAddrLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line"><span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(sockaddr *)&amp;cliAddr,(<span class="type">socklen_t</span> *)&amp;cliAddrLen);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;等待客户端连接......&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;成功接收到一个客户端：&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(cliAddr.sin_addr)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><h3 id="5-connect-函数"><a href="#5-connect-函数" class="headerlink" title="5. connect 函数"></a>5. connect 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s, <span class="comment">//与服务器连接的socket</span></span></span></span><br><span class="line"><span class="params"><span class="function">sockaddr* name, <span class="comment">//服务器的地址端口</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> namelen <span class="comment">//上个参数结构体 name 的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：失败 -1 ，否则成功</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(cliAddr));</span><br><span class="line">cliAddr.sin_family = AF_INET;</span><br><span class="line">cliAddr.sin_port = <span class="built_in">htons</span>(PORT);<span class="comment">//指定port</span></span><br><span class="line">cliAddr.sin_addr.s_addr = <span class="built_in">htons</span>(INADDR_ANY);<span class="comment">//INADDR_ANY 表示任意ip地址，打印则为0.0.0.0</span></span><br><span class="line"><span class="built_in">inet_aton</span>(IP,&amp;(cliAddr.sin_addr));<span class="comment">//指定ip地址</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(client_socket,(sockaddr *)&amp;cliAddr,<span class="built_in">sizeof</span> (cliAddr));<span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;连接成功：&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(cliAddr.sin_addr)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><h3 id="6-send-函数"><a href="#6-send-函数" class="headerlink" title="6. send 函数"></a>6. send 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s,<span class="comment">//socket_FD</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> * buf,<span class="comment">//要发送的内容</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> len, <span class="comment">//内容长度</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flags <span class="comment">//一般为0，拷贝到程序中就立即删除内核中的数据,或MSG_DONTROUTE:要求传输层不要将数据路由出去，MSG_OOB：标志数据应该被带外发送</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：-1（或宏SOCKET_ERROR）表示发送失败，否则返回发送成功的字节数</span></span><br><span class="line"><span class="comment">//通常不考虑 返回0的情况</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string info = <span class="string">&quot;我是客户端&quot;</span>;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="built_in">send</span>(client_socket,(<span class="type">char</span> *)&amp;info, info.<span class="built_in">size</span>() ,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;发送了 &quot;</span>&lt;&lt;ret &lt;&lt;<span class="string">&quot; 字节数据！！&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><h3 id="7-recv-函数"><a href="#7-recv-函数" class="headerlink" title="7. recv 函数"></a>7. recv 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> s, <span class="comment">//套接字</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">void</span> * buf, <span class="comment">//接受数据的缓存区</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> len, <span class="comment">//缓存区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flags <span class="comment">//标志，一般填0，将消息拷贝到应用程序中，将内核中的数据删除，还可以填MSG_PEEK,只取数据，不从内核中删除数据，MSG_OOB：处理带外数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：小于0表示出错，等于0表示断开连接，大于0则表示接收成功的数据大小</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">0xff</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf)); <span class="comment">// 初始化缓冲区，确保没有垃圾数据</span></span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="built_in">recv</span>(client_socket,buf,<span class="number">0xff</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;接受了 &quot;</span>&lt;&lt;ret &lt;&lt;<span class="string">&quot; 字节数据！！&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">buf[ret] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以空字符终止</span></span><br><span class="line">std::cout &lt;&lt;<span class="string">&quot;接受内容：&quot;</span>&lt;&lt; buf &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote alt="warn">    <p>        注意，recv接受到的数据不会加 '\0' ，如果想打印，要手动加上 buf[ret] = '\0'    </p></blockquote><h3 id="8-write-和-read"><a href="#8-write-和-read" class="headerlink" title="8. write 和 read"></a>8. write 和 read</h3><blockquote><p>​<code>write</code>和<code>read</code>是更通用的输入&#x2F;输出函数，可以用于文件、管道、FIFO和socket等多种类型的文件描述符。</p></blockquote><blockquote><p>write 函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>read 函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="9-sendto-函数"><a href="#9-sendto-函数" class="headerlink" title="9. sendto 函数"></a>9. sendto 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> sockfd, <span class="comment">//socket套接字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buf, <span class="comment">//发送数据的缓存区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> len, <span class="comment">//发送数据内容长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags, <span class="comment">//一般为0，拷贝到程序中就立即删除内核中的数据,或MSG_DONTROUTE:要求传输层不要将数据路由出去，MSG_OOB：标志数据应该被带外发送</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> sockaddr *dest_addr, <span class="comment">//目的地的地址信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">socklen_t</span> addrlen<span class="comment">//目的地 sockaddr 结构长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：失败 -1，成功 返回发送的字节数。</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr)); <span class="comment">// 清零servaddr结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器地址信息</span></span><br><span class="line">servaddr.sin_family = AF_INET; <span class="comment">// 指定地址族为IPv4</span></span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>); <span class="comment">// 设置服务器端口号，htons确保字节顺序符合网络标准</span></span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 设置服务器IP地址，这里使用本地回环地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备发送的消息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, server!&quot;</span>;</span><br><span class="line"><span class="comment">// 使用sendto发送消息给服务器</span></span><br><span class="line"><span class="type">ssize_t</span> sentBytes = <span class="built_in">sendto</span>(</span><br><span class="line">    sockfd, <span class="comment">// socket文件描述符</span></span><br><span class="line">    message, <span class="comment">// 指向发送数据的指针</span></span><br><span class="line">    <span class="built_in">strlen</span>(message), <span class="comment">// 要发送数据的长度</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 指定发送选项，这里没有特殊选项</span></span><br><span class="line">    (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="comment">// 指向目的地地址结构的指针</span></span><br><span class="line">    <span class="built_in">sizeof</span>(servaddr)); <span class="comment">// 目的地地址结构的大小</span></span><br><span class="line"><span class="comment">// 检查sendto调用是否成功</span></span><br><span class="line"><span class="keyword">if</span> (sentBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;sendto failed&quot;</span>); <span class="comment">// 若发送失败，打印错误信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 并返回错误码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印发送的字节数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sent %zd bytes to server\n&quot;</span>, sentBytes);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-recvfrom-函数"><a href="#10-recvfrom-函数" class="headerlink" title="10 . recvfrom 函数"></a>10 . recvfrom 函数</h3><blockquote><p>函数原型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> sockfd, <span class="comment">//socket套接字</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buf, <span class="comment">//接受数据的缓存区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> len, <span class="comment">//接受数据内容长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> flags, <span class="comment">//标志，一般填0，将消息拷贝到应用程序中，将内核中的数据删除，还可以填MSG_PEEK,只取数据，不从内核中删除数据，MSG_OOB：处理带外数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> sockaddr *src_addr, <span class="comment">//存放发送方的地址信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">socklen_t</span> addrlen<span class="comment">//存放发送方 sockaddr 结构长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：失败 -1 ，连接关闭 0，成功 返回发送的字节数。</span></span><br></pre></td></tr></table></figure><blockquote><p>函数使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务端地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servaddr)); <span class="comment">// 清零servaddr结构体，确保不含有随机值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器地址信息</span></span><br><span class="line">servaddr.sin_family = AF_INET; <span class="comment">// 指定地址族为IPv4</span></span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>); <span class="comment">// 设置服务器端口号，使用htons确保端口号的字节顺序符合网络标准</span></span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 将字符串形式的IP地址转换为适合网络传输的数值格式，这里指定为本地回环地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备接收服务器回复的相关变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> fromAddr; <span class="comment">// 用于存放发送方（服务器）的地址信息</span></span><br><span class="line"><span class="type">socklen_t</span> fromAddrLen = <span class="built_in">sizeof</span>(fromAddr); <span class="comment">// 发送方地址结构的初始大小</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// 数据接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用recvfrom接收数据</span></span><br><span class="line"><span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(</span><br><span class="line">    sockfd, <span class="comment">// socket文件描述符</span></span><br><span class="line">    buffer, <span class="comment">// 数据接收缓冲区</span></span><br><span class="line">    <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>, <span class="comment">// 最大接收数据大小，留出一个字符的空间用于字符串终止符</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 接收标志，这里没有特殊要求</span></span><br><span class="line">    (<span class="keyword">struct</span> sockaddr *)&amp;fromAddr, <span class="comment">// 存放发送方地址信息的结构体</span></span><br><span class="line">    &amp;fromAddrLen); <span class="comment">// 输入时表示发送方地址结构的大小，输出时表示实际接收到的地址的大小</span></span><br><span class="line"><span class="comment">// 检查recvfrom调用是否成功</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;recvfrom failed&quot;</span>); <span class="comment">// 接收失败，打印错误信息并退出</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">buffer[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在接收到的数据后加上字符串终止符，确保可以作为C字符串处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印服务器回复的消息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server reply: %s\n&quot;</span>, buffer); <span class="comment">// 显示服务器的响应</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-其他函数"><a href="#11-其他函数" class="headerlink" title="11. 其他函数"></a>11. 其他函数</h3><blockquote><p>sockaddr_in 结构体</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;<span class="comment">//sockaddr_in结构体</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));<span class="comment">//将addr中数据置 0</span></span><br><span class="line">addr.sin_family = AF_INET;<span class="comment">//结构体地址类型</span></span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(PORT);<span class="comment">//结构体端口</span></span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//监听IP地址为所有</span></span><br><span class="line"><span class="comment">//监听指定ip地址</span></span><br><span class="line"><span class="comment">//addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line"><span class="comment">//inet_aton(&quot;127.0.0.1&quot;,&amp;(addr.sin_addr));</span></span><br></pre></td></tr></table></figure><blockquote><p>inet_ntoa() 函数 —&gt; network to ascii</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">std::string ip_addr = <span class="built_in">inet_ntoa</span>(client_socket.sin_addr);<span class="comment">//获取客户端ip地址</span></span><br></pre></td></tr></table></figure><blockquote><p>inet_aton() 函数 —-&gt; ascii to network</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="built_in">inet_aton</span>(<span class="string">&quot;127.0.0.1&quot;</span>,&amp;(cliAddr.sin_addr));<span class="comment">//把字符串ip的值赋给cliAddr.sin_addr</span></span><br></pre></td></tr></table></figure><h2 id="2-io-多路复用"><a href="#2-io-多路复用" class="headerlink" title="2.io 多路复用"></a>2.io 多路复用</h2><p>​select, poll,  epoll,  kqueue (unix下),  icon (windows下),  io_uring</p><h3 id="1-多线程实现多对一"><a href="#1-多线程实现多对一" class="headerlink" title="1. 多线程实现多对一"></a>1. 多线程实现多对一</h3><blockquote><p><code>while(1)</code> 中进行 <code>accept</code>，并开启多线程进行 <code>recv()</code> 和 <code>send()</code>。</p></blockquote><blockquote alt="info">    <p>       多线程函数    </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">pthread_t</span> *thread, <span class="comment">// 指向pthread_t变量的指针，该变量用于唯一标识新创建的线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="comment">// 指向线程属性对象的指针，传入NULL使用默认属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="comment">// 新线程将运行的函数，该函数必须接受一个void*参数并返回一个void*值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg <span class="comment">// 传递给start_routine函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功，返回0；否则，返回错误号。</span></span><br></pre></td></tr></table></figure><blockquote><p>核心代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//accept</span></span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(<span class="keyword">struct</span>  sockaddr*)&amp;cliAddr,(<span class="type">socklen_t</span> *)&amp;cliAddrLen);</span><br><span class="line"><span class="comment">//开启多线程</span></span><br><span class="line">    <span class="type">pthread_t</span> cliPth;<span class="comment">//线程id符</span></span><br><span class="line">    <span class="comment">//创建clientPhread函数的线程</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(</span><br><span class="line">        &amp;cliPth,<span class="literal">nullptr</span>,clientPhread,&amp;client_socket);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">clientPhread</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_socket = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">        <span class="type">ssize_t</span> recvLen = <span class="built_in">recv</span>(client_socket,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == recvLen)&#123;<span class="comment">//连接断开，recv() 接受到 0</span></span><br><span class="line">            <span class="built_in">close</span>(client_socket);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;****from client: %d ****  %s\n&quot;</span>,client_socket,buf);</span><br><span class="line">        <span class="type">ssize_t</span> sendLen = <span class="built_in">send</span>(client_socket,buf,recvLen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="danger">    <p>           <strong style="color:red;">           存在问题:        </strong>        每次都会创建一个线程，内存占用过高，多线程上下文切换频繁。   </p></blockquote>### 2. select() 函数<blockquote><p>原理简述</p></blockquote><blockquote alt="info">    <p>        &nbsp;&nbsp;&nbsp;&nbsp;select函数仅仅知道有几个I/O事件发生了，但并不知道具体是哪几个socket连接有I/O事件，还需要轮询去查找，时间复杂度为O(n)，处理的请求数越多，所消耗的时间越长。    </p></blockquote><ol><li><p>从用户空间&#x3D;&#x3D;拷贝&#x3D;&#x3D; fd_set （注册的事件集合）到内核空间</p></li><li><p>内核&#x3D;&#x3D;遍历&#x3D;&#x3D;所有文件描述符，将进程添加到每个fd的等待队列，等待 I&#x2F;O 事件的发生。</p></li><li><p>如果&#x3D;&#x3D;没有立即检测&#x3D;&#x3D;到I&#x2F;O事件，进程挂起（睡眠）。&#x3D;&#x3D;当任一 fd 有 I&#x2F;O 事件发生或超时时&#x3D;&#x3D;，进程被唤醒。</p></li></ol><blockquote><p>函数使用</p></blockquote><ol><li>创建动作对应的集合变量 fd_set</li><li>每次使用之前把所有位清零 FD_ZERO</li><li>设置关注的位 FD_SET();</li><li>使用select轮询状态</li><li>通过FD_ISSET来查询状态是否改变</li></ol><blockquote><p>函数缺点</p></blockquote><ol><li><p>单个进程所打开的&#x3D;&#x3D;FD是有限制的&#x3D;&#x3D;，通过 FD_SETSIZE 设置，FD_SETSIZE 默认1024 。</p></li><li><p>每次调用 select，都需要&#x3D;&#x3D;把 fd 集合从用户态拷贝到内核态&#x3D;&#x3D;，这个开销在 fd 很多时会很大</p></li><li><p>每次调用select都需要&#x3D;&#x3D;将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除&#x3D;&#x3D;</p></li><li><p>select函数在&#x3D;&#x3D;每次调用之前都要对参数进行重新设定&#x3D;&#x3D;，这样做比较麻烦，而且会降低性能</p></li><li><p>进程被唤醒后，程序并不知道哪些socket收到数据，还需要&#x3D;&#x3D;遍历&#x3D;&#x3D;一次</p></li></ol><blockquote><p>函数接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大支持1024个连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据结构 (bitmap)</span></span><br><span class="line"><span class="comment">* fd_set保存了相关的socket事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* select是一个阻塞函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 返回值就绪描述符的数目</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> max_fd,  <span class="comment">// 最大的文件描述符值，遍历时取0-max_fd</span></span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readset,  <span class="comment">// 读事件列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writeset,  <span class="comment">// 写事件列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptset,  <span class="comment">// 异常列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> timeval *timeout  <span class="comment">// 阻塞超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">FD_ZERO</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>   <span class="comment">// 清空集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符加入集合</span></span></span><br><span class="line"><span class="function"><span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>  <span class="comment">// 判断指定描述符是否在集合中 </span></span></span><br><span class="line"><span class="function"><span class="title">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set* fds)</span>    <span class="comment">// 将给定的描述符从文件中删除  </span></span></span><br></pre></td></tr></table></figure><h3 id="3-poll-函数"><a href="#3-poll-函数" class="headerlink" title="3. poll() 函数"></a>3. poll() 函数</h3><blockquote><p>函数原理</p></blockquote><blockquote alt="info">    <p>        poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，         <strong style="color:red;">        但是它没有最大连接数的限制(太多性能会下降)，原因是它是基于链表来存储的。        </strong>    </p></blockquote><blockquote><p>函数使用</p></blockquote><ol><li>创建并初始化 pollfd 结构数组fs，默认置所有 fs.fd 为 -1 。</li><li>设置监听端口 fs.fd[0] 和 fs[0].event 为 POLLIN;</li><li>使用 poll 轮询状态</li><li>通过 fs.fd[i].revent 来查询状态是否改变</li></ol><blockquote><p>函数接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;                         <span class="comment">// 需要监视的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;                   <span class="comment">// 需要内核监视的事件</span></span><br><span class="line">    <span class="type">short</span> revents;                  <span class="comment">// 实际发生的事件，1：表示有事件发生，0：没有事件发生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fds[],   <span class="comment">// 需要监听的文件描述符列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">nfds_t</span> nfds,           <span class="comment">// 文件描述符个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">int</span> timeout            <span class="comment">// 超时时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-知识点"><a href="#3-知识点" class="headerlink" title="3. 知识点"></a>3. 知识点</h2><h3 id="1-阻塞-IO"><a href="#1-阻塞-IO" class="headerlink" title="1. 阻塞 IO"></a>1. 阻塞 IO</h3><blockquote><p><code>accept()</code> 阻塞</p></blockquote><p>​&#x3D;&#x3D;没有连接请求&#x3D;&#x3D;在队列中，<code>accept</code>的进程会被阻塞，直到&#x3D;&#x3D;至少有一个连接&#x3D;&#x3D;。</p><blockquote><p><code>connect()</code> 阻塞</p></blockquote><p>​连接立即建立，则<code>connect</code>返回；如果&#x3D;&#x3D;连接建立需要一段时间&#x3D;&#x3D;，<code>connect</code>会阻塞，直到&#x3D;&#x3D;连接成功建立或发生错误&#x3D;&#x3D;。</p><blockquote><p><code>send()</code> 和 <code>write()</code> 阻塞</p></blockquote><p>​&#x3D;&#x3D;套接字被设置为阻塞模式，并且发送操作不能立即完成&#x3D;&#x3D;，<code>send</code> <code>write</code> 函数就会阻塞。&#x3D;&#x3D;发送缓冲区满时&#x3D;&#x3D;，<code>send</code> <code>write</code> 函数可能会阻塞，直到&#x3D;&#x3D;有足够的空间在缓冲区中存储&#x3D;&#x3D;要发送的数据。</p><blockquote><p><code>recv()</code> 和 <code>read()</code> 阻塞</p></blockquote><p>​&#x3D;&#x3D;读取缓冲区为空，并且没有数据可以读取&#x3D;&#x3D;，<code>recv</code> <code>read</code> 会阻塞，直到&#x3D;&#x3D;有数据到达或连接关闭&#x3D;&#x3D;。</p><blockquote><p><code>select</code> 和 <code>poll </code>阻塞</p></blockquote><p>​&#x3D;&#x3D;没有任何监视的文件描述符变为可操作状态&#x3D;&#x3D;，<code>select</code>和<code>poll</code>会阻塞，直到&#x3D;&#x3D;指定的超时时间到达或至少一个文件描述符变为可操作状态&#x3D;&#x3D;。</p><h3 id="2-非阻塞-IO"><a href="#2-非阻塞-IO" class="headerlink" title="2. 非阻塞 IO"></a>2. 非阻塞 IO</h3><blockquote><p><code>fcntl()</code> 操作文件描述符的系统调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> flags = <span class="built_in">fcntl</span>(listen_socket,F_GETFL,<span class="number">0</span>);<span class="comment">//获取listen_socket文件描述符标志</span></span><br><span class="line">flags |= O_NONBLOCK;<span class="comment">//启用非阻塞模式</span></span><br><span class="line"><span class="built_in">fcntl</span>(listen_socket,F_SETFL,flags);<span class="comment">//修改后的标志设置回 listen_socket</span></span><br></pre></td></tr></table></figure><h3 id="3-socket文件描述符socketFD"><a href="#3-socket文件描述符socketFD" class="headerlink" title="3. socket文件描述符socketFD"></a>3. socket文件描述符socketFD</h3><blockquote><p><code>accept()</code>, <code>socket()</code> 会返回新的文件描述符。</p></blockquote><p>​socketFD 有以下值：</p><ul><li><code>0</code> &#x3D;&#x3D;标准输入&#x3D;&#x3D; <code>stdin</code>，用于从外部接收输入数据，通常指键盘输入或来自于其他程序的数据流。</li><li><code>1</code> &#x3D;&#x3D;标准输出&#x3D;&#x3D; <code>stdout</code> ，用于向外部发送数据，通常指屏幕输出或重定向到其他程序或文件。</li><li><code>2</code> &#x3D;&#x3D;标准错误输出&#x3D;&#x3D;，专门用于输出错误信息和警告。</li><li><code>3+</code> 按照&#x3D;&#x3D;顺序创建&#x3D;&#x3D;的文件描述符。</li></ul><h3 id="4-accept-建立多个连接"><a href="#4-accept-建立多个连接" class="headerlink" title="4. accept() 建立多个连接"></a>4. accept() 建立多个连接</h3><blockquote><p><code>accept()</code> 放在循环中，实现建立多个连接。</p></blockquote><blockquote alt="danger">    <p>        &nbsp;&nbsp;&nbsp;&nbsp;如果不使用while死循环每次阻塞在accept函数，也可以面向多个客户连接，此时        <strong style="color:red;">        将在socket抽象层，自动建立socket，并且该socket不受控制        </strong>    </p></blockquote>## 常用命令<blockquote><p>netstat -anop | grep 9999</p></blockquote><ul><li><code>-a</code> 列出&#x3D;&#x3D;所有&#x3D;&#x3D;状态的套接字。</li><li><code>-n</code> 以&#x3D;&#x3D;数字&#x3D;&#x3D;形式显示地址和端口。</li><li><code>-o</code> 示每个连接的&#x3D;&#x3D;计时器&#x3D;&#x3D;信息</li><li><code>-p</code> 显示每个套接字关联的&#x3D;&#x3D;进程&#x3D;&#x3D;信息。</li><li><code>grep 9999</code> &#x3D;&#x3D;过滤&#x3D;&#x3D;端口9999。</li><li>&#x3D;&#x3D;mac&#x3D;&#x3D; 对应 <code>lsof -i:9999</code></li></ul><blockquote><p>ulimit -n </p></blockquote><ul><li>查看当前对每个进程的&#x3D;&#x3D;文件描述符数量的限制&#x3D;&#x3D;</li><li><code>ulimit -n 4096</code> 临时&#x3D;&#x3D;设置最大限制&#x3D;&#x3D;值。</li></ul><blockquote><p>htop</p></blockquote><ul><li>查看当前 linux 内存等进程信息</li></ul><blockquote><p>watch -n 1 free -h</p></blockquote><ul><li>查看系统内存，每秒刷新</li></ul><blockquote><p>eval “$(ssh-agent -s)”</p><p>ssh-add ~&#x2F;.ssh&#x2F;github</p></blockquote><ul><li>ssh 授予github 权限</li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="1-简单的WebSocket-1"><a href="#1-简单的WebSocket-1" class="headerlink" title="1.简单的WebSocket"></a>1.简单的WebSocket</h2><blockquote><p>功能：只能1对1，客户端向服务端发送信息，输入 end 退出。</p></blockquote><h3 id="1-客户端源码"><a href="#1-客户端源码" class="headerlink" title="1. 客户端源码"></a>1. 客户端源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：成功 客户端socket，失败 -1</span></span><br><span class="line"><span class="comment">*功能：连接服务器</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connectToServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.socket()</span></span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.connect()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(cliAddr));</span><br><span class="line">    cliAddr.sin_family = AF_INET;</span><br><span class="line">    cliAddr.sin_port = <span class="built_in">htons</span>(PORT);<span class="comment">//指定port</span></span><br><span class="line">    cliAddr.sin_addr.s_addr = <span class="built_in">htons</span>(INADDR_ANY);</span><br><span class="line">    <span class="built_in">inet_aton</span>(IP,&amp;(cliAddr.sin_addr));<span class="comment">//指定ip地址</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(client_socket,(sockaddr *)&amp;cliAddr,<span class="built_in">sizeof</span> (cliAddr));<span class="comment">//连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;连接成功：&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(cliAddr.sin_addr)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> client_socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：客户端socket</span></span><br><span class="line"><span class="comment">*返回值：客户端socket</span></span><br><span class="line"><span class="comment">*功能：客户端发送请求</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">requestToServer</span><span class="params">(<span class="type">int</span> client_socket)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0xFF</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf,<span class="number">0</span>,<span class="built_in">sizeof</span> (buf));</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;请输入内容：&quot;</span>;</span><br><span class="line">        std::cin&gt;&gt;buf;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(<span class="string">&quot;end&quot;</span>,buf,<span class="number">3</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;关闭client&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> client_socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ssize_t</span> ret = <span class="built_in">send</span>(client_socket,buf,<span class="built_in">sizeof</span> (buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        std::cout&lt;&lt;&quot;发送了 &quot;&lt;&lt;ret &lt;&lt;&quot; 字节数据！！&quot;&lt;&lt;std::endl;</span></span><br><span class="line">        ret = <span class="built_in">recv</span>(client_socket,buf,<span class="built_in">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;********from server********&quot;</span>&lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">connectToServer</span>();</span><br><span class="line">    client_socket = <span class="built_in">requestToServer</span>(client_socket);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;发送数据失败。&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;成功，关闭socket&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">close</span>(client_socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-服务端源码"><a href="#2-服务端源码" class="headerlink" title="2. 服务端源码"></a>2. 服务端源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_NUMBER 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：监听socket文件描述符，失败 -1</span></span><br><span class="line"><span class="comment">*功能：创建socket、初始化、监听函数</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creatSocket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. socket()</span></span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen_socket )&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. bind()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;<span class="comment">//sockaddr_in结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));<span class="comment">//将addr中数据置 0</span></span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//结构体地址类型</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(PORT);<span class="comment">//结构体端口</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//监听IP地址为所有</span></span><br><span class="line">    <span class="comment">//addr.sin_addr.s_addr = htonl(INADDR_ANY);</span></span><br><span class="line">    <span class="comment">//inet_aton(&quot;127.0.0.1&quot;,&amp;(addr.sin_addr));//监听指定ip地址</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_socket,(sockaddr *)&amp;addr,<span class="built_in">sizeof</span>(addr));<span class="comment">//绑定socket()</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listen_socket,LISTEN_NUMBER);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listen_socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：监听socket文件描述符</span></span><br><span class="line"><span class="comment">*返回值：成功返回客户端socket，失败 -1</span></span><br><span class="line"><span class="comment">*功能：等待客户端连接</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">waitSocket</span><span class="params">(<span class="type">int</span> listen_socket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (cliAddr));</span><br><span class="line">    <span class="type">int</span> cliAddrLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(sockaddr *)&amp;cliAddr,(<span class="type">socklen_t</span> *)&amp;cliAddrLen);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;等待客户端连接......&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;成功接收到一个客户端：&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(cliAddr.sin_addr)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> client_socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：客户端socket</span></span><br><span class="line"><span class="comment">*返回值：客户端socket</span></span><br><span class="line"><span class="comment">*功能：服务端处理socket连接</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handleSocket</span><span class="params">(<span class="type">int</span> client_socket)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0xff</span>];</span><br><span class="line">    <span class="comment">//持续连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf)); <span class="comment">// 初始化缓冲区，确保没有垃圾数据</span></span><br><span class="line">        <span class="type">ssize_t</span> ret = <span class="built_in">recv</span>(client_socket,buf,<span class="built_in">sizeof</span> (buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        std::cout&lt;&lt;&quot;接受了 &quot;&lt;&lt;ret &lt;&lt;&quot; 字节数据！！&quot;&lt;&lt;std::endl;</span></span><br><span class="line">        buf[ret] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保字符串以空字符终止</span></span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;********from client********&quot;</span>&lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">        std::string recvInfo =<span class="string">&quot;server 成功接受！&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">send</span>(client_socket,(<span class="type">char</span> *)&amp;recvInfo,recvInfo.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(<span class="string">&quot;end&quot;</span>,buf,<span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;断开server&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> client_socket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">creatSocket</span>();</span><br><span class="line">    <span class="type">int</span> client_socket = <span class="built_in">waitSocket</span>(listen_socket);</span><br><span class="line">    client_socket = <span class="built_in">handleSocket</span>(client_socket);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;接受数据失败。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;成功，关闭socket&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">close</span>(client_socket);</span><br><span class="line">    <span class="built_in">close</span>(listen_socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多线程实现多对一通信"><a href="#2-多线程实现多对一通信" class="headerlink" title="2. 多线程实现多对一通信"></a>2. 多线程实现多对一通信</h2><blockquote><p>功能：多对一，客户端发送什么，服务端打印并返回。</p></blockquote><h3 id="1-服务端源码"><a href="#1-服务端源码" class="headerlink" title="1. 服务端源码"></a>1. 服务端源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="comment">//多线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">clientPhread</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_socket = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">        <span class="type">ssize_t</span> recvLen = <span class="built_in">recv</span>(client_socket,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &gt; recvLen)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == recvLen)&#123;</span><br><span class="line">            <span class="built_in">close</span>(client_socket);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;****from client: %d ****  %s\n&quot;</span>,client_socket,buf);</span><br><span class="line">        <span class="type">ssize_t</span> sendLen = <span class="built_in">send</span>(client_socket,buf,recvLen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sendLen &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//socket()</span></span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen_socket)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bind()</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> lisAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;lisAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    lisAddr.sin_family = AF_INET;</span><br><span class="line">    lisAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    lisAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_socket,(<span class="keyword">struct</span>  sockaddr*)&amp;lisAddr,<span class="built_in">sizeof</span> (lisAddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen()</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listen_socket,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//client address</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">    <span class="type">int</span> cliAddrLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程 recv and send</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//多线程 accept</span></span><br><span class="line">        <span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(<span class="keyword">struct</span>  sockaddr*)&amp;cliAddr,(<span class="type">socklen_t</span> *)&amp;cliAddrLen);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == client_socket)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;clientSocket: %d, listenSocket: %d .&quot;</span>,client_socket,listen_socket);</span><br><span class="line">        <span class="type">pthread_t</span> cliPth;</span><br><span class="line">        ret = <span class="built_in">pthread_create</span>(&amp;cliPth,<span class="literal">nullptr</span>,clientPhread,&amp;client_socket);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> != ret)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;pthread_create() error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-多路复用实现多对一通信"><a href="#3-多路复用实现多对一通信" class="headerlink" title="3. 多路复用实现多对一通信"></a>3. 多路复用实现多对一通信</h2><blockquote><p>功能：多对一，客户端发送什么，服务端打印并返回。</p></blockquote><h3 id="1-select-实现服务端"><a href="#1-select-实现服务端" class="headerlink" title="1. select() 实现服务端"></a>1. select() 实现服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_SIZE 10</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen_socket)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> lisAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;lisAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (<span class="keyword">struct</span>  sockaddr_in));</span><br><span class="line">    lisAddr.sin_family = AF_INET;</span><br><span class="line">    lisAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    lisAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_socket,(<span class="keyword">struct</span> sockaddr*)&amp;lisAddr,<span class="built_in">sizeof</span> (lisAddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listen_socket,LISTEN_SIZE);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//多路IO复用</span></span><br><span class="line">    fd_set read_set,all_set;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;all_set);</span><br><span class="line">    <span class="built_in">FD_SET</span>(listen_socket,&amp;all_set);</span><br><span class="line">    <span class="type">int</span> all_fd = listen_socket;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        read_set = all_set;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">select</span>(all_fd+<span class="number">1</span>,&amp;read_set, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">//检测是否有新连接</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(listen_socket,&amp;read_set))&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">            <span class="type">socklen_t</span> cliLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">            <span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,(<span class="type">socklen_t</span>*)&amp;cliLen);</span><br><span class="line">            <span class="built_in">FD_SET</span>(client_socket,&amp;all_set);</span><br><span class="line">            <span class="keyword">if</span>(client_socket &gt; all_fd)&#123;</span><br><span class="line">                all_fd = client_socket;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == --nready)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> buf[BUF_SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//检测是否有client_socket状态发生变化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=listen_socket+<span class="number">1</span>;i&lt;all_fd+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(i,&amp;read_set))&#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">                <span class="comment">//当前client_socket发生变化，开始收发数据</span></span><br><span class="line">                <span class="type">ssize_t</span> recvLen = <span class="built_in">recv</span>(i,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(recvLen == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">close</span>(i);</span><br><span class="line">                    <span class="built_in">FD_CLR</span>(i,&amp;all_set);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client: %d over.\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(recvLen &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;recv() error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf[recvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliAddr;</span><br><span class="line">                <span class="type">socklen_t</span> cliLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">                ret = <span class="built_in">getpeername</span>(i,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,&amp;cliLen);</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">-1</span> == ret)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;getpeername() error&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;**** from IP: %s Port: %d SocketFD: %d **** %s\n&quot;</span>,<span class="built_in">inet_ntoa</span>(cliAddr.sin_addr), <span class="built_in">ntohs</span>(cliAddr.sin_port),i,buf);</span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                <span class="type">ssize_t</span> sendLen = <span class="built_in">send</span>(i,buf,recvLen+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sendLen &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;sendLen() error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-poll-实现服务端"><a href="#2-poll-实现服务端" class="headerlink" title="2. poll() 实现服务端"></a>2. poll() 实现服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Just花语 on 2024/2/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLL_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 9999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTEN_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="type">int</span> listen_socket = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> lisAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;lisAddr,<span class="number">0</span>,<span class="built_in">sizeof</span> (lisAddr));</span><br><span class="line">    lisAddr.sin_family = AF_INET;</span><br><span class="line">    lisAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    lisAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="built_in">bind</span>(listen_socket,(<span class="keyword">struct</span> sockaddr*)&amp;lisAddr,<span class="built_in">sizeof</span> (lisAddr));</span><br><span class="line">    <span class="built_in">listen</span>(listen_socket,LISTEN_SIZE);</span><br><span class="line">    <span class="comment">//poll</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fs[POLL_SIZE];</span><br><span class="line">    fs[<span class="number">0</span>].fd=listen_socket;</span><br><span class="line">    fs[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;POLL_SIZE;i++)&#123;</span><br><span class="line">        fs[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nready = <span class="built_in">poll</span>(fs,maxfd+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == nready)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;断开连接。\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">-1</span> == nready)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;连接失败。\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fs[<span class="number">0</span>].revents &amp;&amp; POLLIN)&#123;</span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliAddr;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;cliAddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(cliAddr));</span><br><span class="line">                <span class="type">socklen_t</span> cliLen = <span class="built_in">sizeof</span> (cliAddr);</span><br><span class="line">                <span class="type">int</span> client_socket = <span class="built_in">accept</span>(listen_socket,(<span class="keyword">struct</span> sockaddr*)&amp;cliAddr,&amp;cliLen);</span><br><span class="line">                <span class="type">bool</span> fs_full = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;POLL_SIZE;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fs[i].fd &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        fs[i].fd = client_socket;</span><br><span class="line">                        fs[i].events = POLLIN;</span><br><span class="line">                        maxfd++;</span><br><span class="line">                        fs_full = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(fs_full)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;too many client\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == --nready)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxfd+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fs[i].revents &amp;&amp; POLLIN)&#123;</span><br><span class="line">                    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">                    <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUF_SIZE);</span><br><span class="line">                    <span class="type">ssize_t</span> recvSize = <span class="built_in">recv</span>(fs[i].fd,buf,BUF_SIZE,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(recvSize == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">close</span>(fs[i].fd);</span><br><span class="line">                        fs[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buf[recvSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">                    <span class="type">ssize_t</span> sendSize = <span class="built_in">send</span>(fs[i].fd,buf,recvSize+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://pan.baidu.com/s/1qY7_bMgIuefF4Vf75o3nog">完整虚拟机环境：提取码 g7on，用户名 king 密码 123456</a></p><p><a href="https://blog.csdn.net/qq_43316970/article/details/124331142">C++ Socket 网络编程：大小写转换案例</a></p><p><a href="https://zhuanlan.zhihu.com/p/650758773">C++ Socket 网络编程：常用函数讲解</a></p><p><a href="https://blog.csdn.net/weixin_41114301/article/details/130448728">select、poll ：select原理讲解详细</a></p><p><a href="https://blog.csdn.net/fengyuyeguirenenen/article/details/124234675">select、poll ：select 、poll、epoll 函数详解</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令使用</title>
      <link href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux-命令使用"><a href="#Linux-命令使用" class="headerlink" title="Linux 命令使用"></a>Linux 命令使用</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 中插入 Latex 公式 hexo -g 报错</title>
      <link href="/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/"/>
      <url>/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>在md文档中插入了 $Latex$ 公式，使用 <code>hexo -g</code>时报错如下：</p></blockquote><img src="/Users/justhuayu/Library/Application Support/typora-user-images/image-20240221141850987.png" alt="image-20240221141850987" style="zoom:30%;" /><blockquote><p>​出现这种情况是因为 $Latex$ 公式块中有<code>&#123;&#123;&#125;&#125;</code>这样的双花括号，与另外的某些模块，如 Nunjucks 模块发生了冲突。</p></blockquote><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​将<code>&#123;&#123;&#125;&#125;</code>改为<code>&#123;&#125;</code>单花括号即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation</title>
      <link href="/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/"/>
      <url>/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ClipSAM"><a href="#ClipSAM" class="headerlink" title="ClipSAM"></a>ClipSAM</h1><blockquote><p>arxiv 2023</p></blockquote><blockquote><p>复旦大学，Shengze Li，Jianjian Cao，Tao Chen</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/610c334d0084c2b8c8875.png" alt="image-20240220155331043" style="zoom:30%;"/><blockquote><ol><li>CLIP + SAM 作 ZSAD</li><li>CLIP粗分割，SAM细分割，本质还是SAM</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-ZSAD（零样本异常检测）任务"><a href="#1-ZSAD（零样本异常检测）任务" class="headerlink" title="1. ZSAD（零样本异常检测）任务"></a>1. ZSAD（零样本异常检测）任务</h3><p>​需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。</p><h3 id="2-CLIP-用于ZSAS问题"><a href="#2-CLIP-用于ZSAS问题" class="headerlink" title="2. CLIP 用于ZSAS问题"></a>2. CLIP 用于ZSAS问题</h3><blockquote><p>​CLIP主要关注不同输入之间的全局特征对齐，&#x3D;&#x3D;导致局部异常部分的分割不精确&#x3D;&#x3D;。</p></blockquote><h3 id="3-SAM-用于ZSAS问题"><a href="#3-SAM-用于ZSAS问题" class="headerlink" title="3. SAM 用于ZSAS问题"></a>3. SAM 用于ZSAS问题</h3><blockquote><p>​SAM会&#x3D;&#x3D;产生大量冗余掩码&#x3D;&#x3D;，&#x3D;&#x3D;需要合适的提示&#x3D;&#x3D;。&#x3D;&#x3D;简单的文本提示不能有效描述异常区域&#x3D;&#x3D;，导致异常定位性能欠佳，SAM功能利用率不足。同时，&#x3D;&#x3D;模糊的提示会产生冗余的掩码&#x3D;&#x3D;。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-CLIP-和-SAM-协同"><a href="#1-CLIP-和-SAM-协同" class="headerlink" title="1. CLIP 和 SAM 协同"></a>1. CLIP 和 SAM 协同</h3><blockquote><p>​CLIP进行&#x3D;&#x3D;异常定位和粗分割&#x3D;&#x3D;，SAM利用定位和粗分割结果进行&#x3D;&#x3D;细分割&#x3D;&#x3D;。</p></blockquote><h3 id="2-统一多尺度跨模态交互-UMCI-模块"><a href="#2-统一多尺度跨模态交互-UMCI-模块" class="headerlink" title="2.  统一多尺度跨模态交互(UMCI)模块"></a>2.  统一多尺度跨模态交互(UMCI)模块</h3><blockquote><p>​UMCI (Unified Multi-scale Cross-modal Interaction) 实现CLIP&#x3D;&#x3D;不同层次的多模态特征融合&#x3D;&#x3D;，以获得异常定位和粗分割。</p></blockquote><p>​UMCI将&#x3D;&#x3D;水平方向和垂直方向&#x3D;&#x3D;的图像 patch tokens 聚合，并利用&#x3D;&#x3D;相应的行、列特征与 text 特征交互&#x3D;&#x3D;，感知不同方向的局部异常。UMCI还考虑了语言和多尺度视觉特征的相互作用。</p><p>​该模块通过在&#x3D;&#x3D;行-列和多尺度级别&#x3D;&#x3D;上的语言特征与视觉特征交互来学习异常部件的局部和全局语义。</p><h3 id="3-多级掩码细化-MMR-模块"><a href="#3-多级掩码细化-MMR-模块" class="headerlink" title="3. 多级掩码细化(MMR)模块"></a>3. 多级掩码细化(MMR)模块</h3><blockquote><p>​MMR (Multi-level Mask Refinement) 利用CLIP的定位信息来指导SAM进行分割细化</p></blockquote><p>​首先从CLIP的异常定位结果中&#x3D;&#x3D;提取不同的点和边界框&#x3D;&#x3D;提示，然后使用这些提示来&#x3D;&#x3D;指导SAM生成&#x3D;&#x3D;精确的掩码。最后，将这些&#x3D;&#x3D;掩码与基于不同掩码置信度的CLIP结果融合&#x3D;&#x3D;。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-CLIP-部分"><a href="#1-CLIP-部分" class="headerlink" title="1.CLIP 部分"></a>1.CLIP 部分</h3><img src="https://telegraph-image-9wl.pages.dev/file/394ad1f18de0a39c09f69.png" alt="image-20240221100305823" style="zoom:30%;" /><p>​主要关注&#x3D;&#x3D;提示词&#x3D;&#x3D;的设计，对于上图中CLIP Text的两个输入：</p><ol><li>上面输入，表示有 $n$ 个&#x3D;&#x3D;描述短语&#x3D;&#x3D;。</li><li>左边输入，表示有 $m_{normal}$ 个&#x3D;&#x3D;描述正常状态的词&#x3D;&#x3D;， $m_{abnormal}$ 个&#x3D;&#x3D;描述异常状态的词&#x3D;&#x3D;。</li><li>对于&#x3D;&#x3D;同一类&#x3D;&#x3D;（类&#x3D;&#x3D;默认已知&#x3D;&#x3D;，未知类用&#x3D;&#x3D;[object]站位&#x3D;&#x3D;），总有 $n \times (m_{normal} + m_{abnormal})$ 个&#x3D;&#x3D;提示句子&#x3D;&#x3D;。</li><li>所有句子通过CLIP Text，计算文本特征&#x3D;&#x3D;平均值&#x3D;&#x3D;。</li></ol><h3 id="2-统一多尺度跨模态交互-UMCI-模块-1"><a href="#2-统一多尺度跨模态交互-UMCI-模块-1" class="headerlink" title="2.统一多尺度跨模态交互(UMCI)模块"></a>2.统一多尺度跨模态交互(UMCI)模块</h3><img src="https://telegraph-image-9wl.pages.dev/file/028a98e00e7ca82792078.png" alt="image-20240221100638886" style="zoom:41%;" /><blockquote><p>​UMCI模块的输入为CLIP编码器处理后得到的文本特征 $L$ （与WinCLIP一致）和第 $i$ 阶段生成的 patch tokens $P_i$ 。</p></blockquote><p>​UMCI模型由两条并行路径组成：&#x3D;&#x3D;条形路径(Strip Path)和比例路径(Scale Path)&#x3D;&#x3D;。Strip Path捕获 patch tokens 的&#x3D;&#x3D;行级和列级特征&#x3D;&#x3D;，&#x3D;&#x3D;以精确定位位置&#x3D;&#x3D;。Scale Path 侧重于掌握图像的&#x3D;&#x3D;各种尺度的全局特征&#x3D;&#x3D;，从而全面了解异常。</p><ol><li>&#x3D;&#x3D;Strip path&#x3D;&#x3D; 条形路径、 &#x3D;&#x3D;Scale path&#x3D;&#x3D; 比例路径，算法中 $B(.)$ 指双线性插值。</li></ol><div style="display:flex; justify-content:space-between;">  <img src="https://telegraph-image-9wl.pages.dev/file/c1d36198d0ebcdf6612e9.png" alt="image-20240221130203205" style="width: 48%;">  <img src="https://telegraph-image-9wl.pages.dev/file/2f1978ec8967f2947e030.png" alt="image-20240221130246384" style="width: 48%;"></div><ol start="2"><li>输出&#x3D;&#x3D;最终结果&#x3D;&#x3D;。</li></ol><p>$$<br>v_{ori} &#x3D; {conv}_{ori}^{3 \times 3}(\hat{P})<br>$$</p><p>$$<br>M_{all} &#x3D; {conv}<em>{all}^{3 \times 3}({concat}(v</em>{ori}, M_{row,col}, M_{g_1}, M_{g_2}))<br>$$</p><p>$$<br>O &#x3D; {MLP}({ReLU}(M_{all} + \hat{P}))<br>$$</p><ol start="3"><li>如果编码器中&#x3D;&#x3D;有 $n$ 个阶段&#x3D;&#x3D;，将第 $i$ 阶段的分割输出设为 $O_i$ ，则&#x3D;&#x3D;最终的分割结果&#x3D;&#x3D;可计算为。</li></ol><p>$$<br>O &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} O_i<br>$$</p><h3 id="3-SAM部分，多级掩码细化-MMC"><a href="#3-SAM部分，多级掩码细化-MMC" class="headerlink" title="3. SAM部分，多级掩码细化(MMC)"></a>3. SAM部分，多级掩码细化(MMC)</h3><img src="https://telegraph-image-9wl.pages.dev/file/a28dbdcfac76ca5f7113c.png" alt="image-20240221103130908" style="zoom:40%;" /><blockquote><p>​MMC 的输入为 CLIP处理后的&#x3D;&#x3D;定位信息和粗分割&#x3D;&#x3D;，该模块流程如下：</p></blockquote><ol><li>根据输入，获得&#x3D;&#x3D;二进制掩码&#x3D;&#x3D;，&#x3D;&#x3D;1 表示异常像素点&#x3D;&#x3D;。</li></ol><p>$$<br>v(x, y)_b &#x3D;<br>\begin{cases}<br>1, &amp; \text{if } v(x, y)_f &gt; \text{threshold} \<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p><ol start="2"><li>生成&#x3D;&#x3D;点提示&#x3D;&#x3D;。随机选择 $m$ 个点，$(x_{pm}, y_{pm})$ 表示第 $i$ 个点位置。</li></ol><p>$$<br>S_p &#x3D; \left[ (x_{p1}, y_{p1}), \ldots, (x_{pm}, y_{pm}) \right],<br>$$</p><ol start="3"><li>生成&#x3D;&#x3D;框提示&#x3D;&#x3D;。根据二进制掩码中&#x3D;&#x3D;连通区域的大小&#x3D;&#x3D;和&#x3D;&#x3D;第 $i$ 个点位置&#x3D;&#x3D;，生成 $q$ 个方框。</li></ol><p>$$<br>S_{b_i} &#x3D; \left[ (x_{b_i}, y_{b_i}, h_{b_i}, w_{b_i}) \right]，<br>{S}<em>{b} &#x3D; [{S}</em>{b_1}, \ldots, {S}_{b_q}]<br>$$</p><blockquote alt="info">    <p>        消融实验：点提示和框提示的有效性。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5e0b58ad16f56d91d70f1.png" alt="image-20240221110923658" style="zoom:70%;" /><ol start="4"><li>使用 SAM 分割原始图像。输入是&#x3D;&#x3D;原始图像和提示 $S$&#x3D;&#x3D; ，&#x3D;&#x3D;编码后特征为 $Z_i$和$Z_S$&#x3D;&#x3D;，解码后结果为&#x3D;&#x3D;掩码 $masks$ 和相应的置信度分数 $scores$&#x3D;&#x3D;。SAM 为每个框提示生成三个具有不同置信度分数的掩码。</li></ol><p>$$<br>S &#x3D; S_b \cup S_p<br>$$</p><p>$$<br>({masks}, {scores}) &#x3D; D_{sam}(z_i | z_s).<br>$$</p><p>$$<br>\text{masks} &#x3D; \left[<br>\begin{array}{ccc}<br>m_{1}^1 &amp; m_{1}^2 &amp; m_{1}^3 \<br>\vdots &amp; \vdots &amp; \vdots \<br>m_{q}^1 &amp; m_{q}^2 &amp; m_{q}^3 \<br>\end{array}<br>\right], \quad \text{scores} &#x3D; \left[<br>\begin{array}{ccc}<br>s_{1}^1 &amp; s_{1}^2 &amp; s_{1}^3 \<br>\vdots &amp; \vdots &amp; \vdots \<br>s_{q}^1 &amp; s_{q}^2 &amp; s_{q}^3 \<br>\end{array}<br>\right]<br>$$</p><ol start="5"><li>SAM 结果与原始输入叠加，得到&#x3D;&#x3D;最终结果&#x3D;&#x3D;。</li></ol><p>$$<br>O_{final} &#x3D; {Norm}\left(O + \sum_{i&#x3D;1}^{q} \sum_{j&#x3D;1}^{3} m_{i}^j \times s_{i}^j\right)<br>$$</p><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><blockquote><p>使用 Focal loss 和 Mice loss</p></blockquote><p>$$<br>L_{focal} &#x3D; -\frac{1}{H \times W} \sum_{i&#x3D;0}^{H \times W} (1 - p_i)^\gamma \log(p_i)，\gamma &#x3D; 2<br>$$</p><p>$$<br>L_{dice} &#x3D; 1 - \frac{2 \times \sum_{i&#x3D;1}^{N} y_i \hat{y}<em>i}{\sum</em>{i&#x3D;1}^{N} y_i^2 + \sum_{i&#x3D;1}^{N} \hat{y}_i^2}  ，N &#x3D; H \times W<br>$$</p><p>$$<br>L_{all} &#x3D; \sum_{i&#x3D;1}^{n} \lambda_i (L_{focal}^i + L_{dice}^i),<br>$$</p><p>​$λ_i$ 为第 $i$ 阶段的损失权值。CLIP编码器本文总共由4个阶段组成，$λ_i$ 分别为 &#x3D;&#x3D;0.1、0.1、0.1和0.7&#x3D;&#x3D;。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/164cbfacd619c4499eba5.png" alt="image-20240221104522472" style="zoom:60%;" /><blockquote><p>$AUROC$ 接收者特性曲线下方的面积</p></blockquote><p>​AUROC (area under the receiver operating characteristic) 接收者特性曲线下方的面积，&#x3D;&#x3D;AUROC值越大，正确率越高&#x3D;&#x3D;。AUROC 衡量模型在区分两个类别（如正类和负类）方面的能力，其中 $AUROC &#x3D; 0.5$ 表示随机猜测。</p><p>​横坐标是&#x3D;&#x3D;假正率&#x3D;&#x3D;（False Positive Rate, FPR），纵坐标是&#x3D;&#x3D;真正率&#x3D;&#x3D;（True Positive Rate, TPR）。<br>$$<br>FRR &#x3D; \frac{FN}{FN + TP} &#x3D; \frac{假阳性数量}{实际阴性样本总数}<br>$$</p><p>$$<br>TPR &#x3D; \frac{TP}{TP + FN}&#x3D;\frac{真阳性数量}{实际阳性样本总数}<br>$$</p><blockquote><p>$F_1-max$ 在不同的决策阈值或不同的条件下，F1分数的最大值</p></blockquote><p>​F1分数（F1-Score）是一个用于衡量二分类模型性能的指标，它是模型&#x3D;&#x3D;精确率（Precision）和召回率（Recall）的调和平均数&#x3D;&#x3D;。F1分数的范围从0到1，1表示完美的精确率和召回率，0表示至少有一个为零。<br>$$<br>F_{1{-max}} &#x3D; \max \left(2 \times \frac{Precision} \times {Recall}{Precision} + {Recall}\right)<br>$$</p><p>$$<br>{Precision} &#x3D; \frac{TP}{TP + FP}<br>$$</p><p>$$<br>\text{Recall} &#x3D; \frac{TP}{TP + FN}<br>$$</p><blockquote><p>$AP$ 平均精度</p></blockquote><p>​AP (Average Precision) 平均精度是&#x3D;&#x3D;对精确率（Precision）在不同召回率（Recall）阈值下的表现进行平均的结果&#x3D;&#x3D;。AP考虑了模型在&#x3D;&#x3D;所有可能的分类阈值下的性能&#x3D;&#x3D;，因此是一个衡量模型整体性能的有力指标。<br>$$<br>AP &#x3D; \frac{1}{正例总数} \sum_{k&#x3D;1}^{n} (P(k) \times {rel}(k))<br>$$<br>​其中 $n$ 是返回结果的数量，$P(k)$ 是在前 $k$ 个返回结果中的精确率，$\text{rel}(k)$ 是一个指示函数，如果第 $k$ 个结果是正例，则为 $1$，否则为 $0$。</p><blockquote><p>$PRO$ (per-region-overlap)</p></blockquote><p>​PRO评价模型识别出的&#x3D;&#x3D;异常或目标区域与实际的异常或目标区域的匹配精度&#x3D;&#x3D;。<br>$$<br>PRO &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \frac{P \cap G_n}{G_n} &#x3D; \frac{1}{N} \sum_{n&#x3D;1}^{N} \frac{TP_n}{TP_n + FN_n}<br>$$<br>​定位的缺陷结果和实际的真值按连通域划分为 $N$ 个区域，接着求出每个区域中预测结果 $P$ 和真值 $G_n$ 的交集，将交集除以 $G_n$ 后 $N$ 个区域加权平均即可求得 $PRO$ 值 。同时预测结果 $P$ 和真值 $G_n$ 的交集即真阳性样本 $TP_n$ ，故 $PRO$ 也可根据混淆矩阵计算。</p><p><a href="https://arxiv.org/abs/2303.14814">相关论文：WinCLIP</a></p><p><a href="https://arxiv.org/abs/2304.02643">相关论文：SAM</a></p><p><a href="https://arxiv.org/abs/2401.12665">论文链接</a></p><p><a href="https://github.com/Lszcoding/ClipSAM">代码链接（未上传）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式版本控制 Git</title>
      <link href="/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/"/>
      <url>/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-仓库"><a href="#1-仓库" class="headerlink" title="1. 仓库"></a>1. 仓库</h3><blockquote><p>git init –bare</p></blockquote><p>​&#x3D;&#x3D;初始化&#x3D;&#x3D;裸仓库 </p><blockquote><p>git clone …</p></blockquote><p>​&#x3D;&#x3D;克隆&#x3D;&#x3D;远程仓库</p><h3 id="2-ssh-协议"><a href="#2-ssh-协议" class="headerlink" title="2. ssh 协议"></a>2. ssh 协议</h3><blockquote><p>ssh-keygen -t rsa </p></blockquote><ul><li>生成 rsa 公钥(.pub)和私钥，使用<code>-f ~/.ssh/名字</code> 参数指定文件路径和名字。</li><li>生成目录：<code>/Users/用户/.ssh</code>，使用 <code>open ~/.ssh</code> 直接在 finder 打开。</li></ul><blockquote><p>ssh-copy-id -i ~&#x2F;.ssh&#x2F;名字.pub username@hostname</p></blockquote><p>​将公钥内容拷贝至&#x3D;&#x3D;服务器.ssh&#x3D;&#x3D;文件夹中&#x3D;&#x3D;authorized_keys&#x3D;&#x3D;文件中。本地目录可以使用ssh免密登陆服务器。</p><blockquote><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#106;&#117;&#x73;&#x74;&#104;&#x75;&#x61;&#121;&#x75;&#x40;&#49;&#x32;&#55;&#46;&#x30;&#46;&#x30;&#46;&#49;">&#106;&#117;&#x73;&#x74;&#104;&#x75;&#x61;&#121;&#x75;&#x40;&#49;&#x32;&#55;&#46;&#x30;&#46;&#x30;&#46;&#49;</a>:&#x2F;home&#x2F;user&#x2F;git</p></blockquote><p>​从&#x3D;&#x3D;远程 ssh clone&#x3D;&#x3D; 代码到本地。</p><blockquote><p>启动代理ssh-agent</p></blockquote><ul><li><code>eval &quot;$(ssh-agent -s)&quot;</code></li><li><code>ssh-add ~/.ssh/github</code></li></ul><blockquote><p>git push启用ssh</p></blockquote><ul><li><code>git remote set-url origin git@github.com:Justhuayu/Read_NtyCo.git</code></li><li><code>git remote -v</code> 查看远程仓库名称</li></ul><h3 id="3-配置用户名和密码"><a href="#3-配置用户名和密码" class="headerlink" title="3. 配置用户名和密码"></a>3. 配置用户名和密码</h3><blockquote><p>git config user.name justhuayu</p></blockquote><p>​配置&#x3D;&#x3D;用户名&#x3D;&#x3D;。</p><blockquote><p>git config user.email justhuayu@foxmailcom</p></blockquote><p>​配置&#x3D;&#x3D;邮件&#x3D;&#x3D;。</p><ul><li><code>git config --global</code>参数，&#x3D;&#x3D;全局生效&#x3D;&#x3D;配置。</li><li>配置文件在<code>.git/config</code>中。</li></ul><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4. 工作原理"></a>4. 工作原理</h3><img src="https://telegraph-image-9wl.pages.dev/file/88aaf326263b0a4da0ee8.png" alt="image-20240220191850348" style="zoom:67%;" /><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h2><p>###1. 基本操作</p><blockquote><p>git status</p></blockquote><p>​查看当前&#x3D;&#x3D;工作区状态&#x3D;&#x3D;。  </p><blockquote><p>git add .</p></blockquote><p>​提交当前目录所有文件(.)到&#x3D;&#x3D;暂存区Index&#x3D;&#x3D;。</p><blockquote><p>git commit . -m “提交日志”</p></blockquote><p>​提交当前目录所有文件到&#x3D;&#x3D;本地仓库 Repository&#x3D;&#x3D;。<code>-m &quot;&quot;</code>表示提交&#x3D;&#x3D;日志&#x3D;&#x3D;。</p><blockquote><p>git push origin 本地分支名：远程分支名</p></blockquote><p>​提交当前目录所有文件到&#x3D;&#x3D;远程仓库 Remote&#x3D;&#x3D;。<code>origin</code>是远程仓库地址的&#x3D;&#x3D;别称&#x3D;&#x3D;。</p><blockquote><p>git pull</p></blockquote><p>​&#x3D;&#x3D;拉取合并&#x3D;&#x3D;远程仓库到本地，相当于<code>git fetch + git merge</code>。</p><blockquote><p>git fetch</p></blockquote><p>​将远程仓库所包含分支的&#x3D;&#x3D;最新 commit-id 记录&#x3D;&#x3D;到本地文件，即知道落后远程几个版本。</p><blockquote><p>git log</p></blockquote><p>​查看提交commit日志，会&#x3D;&#x3D;显示40位hash的版本号&#x3D;&#x3D;。下面介绍一些参数：</p><ul><li><code>--oneline</code> 每条日志显示一行</li><li><code>-[length]</code> 只显示前面的length条日志</li><li><code>--skip=[number]</code> 跳过前面number条日志</li><li><code>-p</code> 显示一些统计信息以及文件的改动内容和行信息</li><li><code>--stat</code> 显示提交的作者，日期，message和文件内容统计信息</li><li><code>git shortlog</code> 显示每个 作者提交多少条</li></ul><blockquote alt="info">    <p>        git log 过滤查看commit的内容    </p></blockquote><ul><li><p>按日期：</p><p><code>git log --after=&quot;2001-7-14&quot;</code>、<code>git log --before=&quot;2024-2-20&quot;</code></p></li><li><p>按作者：<br><code>git log --author=&quot;justhuayu&quot;</code></p></li><li><p>按包含提交内容<br><code>git log --grep=&quot;bug&quot;</code> 按照提交本中是否包含bug的日志</p></li><li><p>按文件<br><code>git log --/user/just/go.cpp</code></p></li><li><p>按内容<br><code>git log -S &quot;ngx_free&quot;</code> 所有文件中包含了 ngx_free字符串的修改</p></li><li><p>按照范围<br><code>git log &lt;since&gt;..&lt;until&gt;</code> git log master..feature这可以显示出自从master分支fork之后，feature分支上所有的提交</p></li></ul><blockquote><p>git show commit-id:文件名</p></blockquote><p>​显示&#x3D;&#x3D;commit-id的提交内容&#x3D;&#x3D;，包括所有文件的修改信息</p><blockquote><p>git diff 文件名</p></blockquote><p>​查看本地对某个文件做了&#x3D;&#x3D;哪些修改&#x3D;&#x3D;。<code>git diff commit-id 文件名（commit-id）</code> 显示&#x3D;&#x3D;与某个commit间所有的差异&#x3D;&#x3D;，commit-id可以替换成HEAD，比如HEAD~2。</p><blockquote><p>HEAD 指针</p></blockquote><p>​head指向&#x3D;&#x3D;当前检出记录&#x3D;&#x3D;，最近一次提交<code>commit</code>的引用。</p><h3 id="2-逆向操作"><a href="#2-逆向操作" class="headerlink" title="2. 逆向操作"></a>2. 逆向操作</h3><blockquote><p>git restore -S 文件名</p></blockquote><p>​&#x3D;&#x3D;index -&gt; workspace&#x3D;&#x3D; ，从&#x3D;&#x3D;暂存区 Index回退&#x3D;&#x3D;文件。</p><blockquote><p>git reset –参数 版本号(head^)</p></blockquote><p>​从&#x3D;&#x3D;本地仓库回退&#x3D;&#x3D;文件，回退到哪有&#x3D;&#x3D;3种&#x3D;&#x3D;方式。<code>head^</code>是上个版本。</p><ul><li><code>git reset --soft</code>回退到&#x3D;&#x3D;暂存区Index&#x3D;&#x3D;。</li><li><code>git reset --mixed</code>回退到&#x3D;&#x3D;工作区workspace&#x3D;&#x3D;。 </li><li><code>git reset --hard</code>直接从本地仓库&#x3D;&#x3D;删除&#x3D;&#x3D;。</li></ul><blockquote><p>git checkout -f(强制参数)</p></blockquote><p>​将&#x3D;&#x3D;工作区workspace&#x3D;&#x3D;的所有&#x3D;&#x3D;状态删掉&#x3D;&#x3D;，例如创建了文件，修改了文件后，<code>git status</code>会有提示，使用<code>git checkout</code>后提示消失，但是对文件的创建和修改不会消失。</p><h3 id="3-本地仓库整理操作"><a href="#3-本地仓库整理操作" class="headerlink" title="3. 本地仓库整理操作"></a>3. 本地仓库整理操作</h3><blockquote><p>git commit –amend</p></blockquote><p>​整理&#x3D;&#x3D;上一次&#x3D;&#x3D;提交，即将这次的提交&#x3D;&#x3D;复用上次的提交&#x3D;&#x3D;。</p><blockquote><p>git rebase -i h1 h2</p></blockquote><p>​整理&#x3D;&#x3D;多次&#x3D;&#x3D;提交，从版本号 h1 到 h2，&#x3D;&#x3D;左开右闭&#x3D;&#x3D;。<code>git rebase -i</code>是所有提交。</p><p>​&#x3D;&#x3D;左开右闭的理解&#x3D;&#x3D;：从1到3的几次提交，2会依赖3，1会依赖2，所以是左开右闭。</p><blockquote alt="info">    <p>        对于前后两次提交a和b，整理a操作流程    </p></blockquote><ol><li><code>git rebase -i a版本号 b版本号</code>，版本号只要能区分即可，无论多少位。</li><li>在vim页面，修改 a 前缀为<code>edit</code>，b前缀不变，保存退出vim。</li><li>此时在变基状态，修改需要修改的对应内容。</li><li><code>git add .</code>提交修改的内容到暂缓区Index。</li><li><code>git commit -amend</code>整理提交这次的内容到 a 版本号。</li><li><code>git rebase --continue</code> 退出变基。</li></ol><blockquote alt="danger">    <p>        使用整理仓库，必须没有人基于这个分支开发    </p></blockquote><p>​从变基（rebase）那个节点开始，往后&#x3D;&#x3D;所有节点的commit-id&#x3D;&#x3D;都会变化。</p><h3 id="4-分支操作"><a href="#4-分支操作" class="headerlink" title="4. 分支操作"></a>4. 分支操作</h3><blockquote><p>git branch </p></blockquote><p>​&#x3D;&#x3D;显示&#x3D;&#x3D;本地所有分支。<code>git branch -a</code>会显示&#x3D;&#x3D;本地和远程&#x3D;&#x3D;的分支。</p><blockquote><p>git branch 分支名 || git checkout -b 分支名</p></blockquote><p>​&#x3D;&#x3D;创建&#x3D;&#x3D;新分支。<code>git checkout -b</code>在创建分支后会&#x3D;&#x3D;自动切换&#x3D;&#x3D;到新分支上，而<code>git branch </code>不会。</p><blockquote><p>git switch 分支名 || git checkout 分支名</p></blockquote><p>​&#x3D;&#x3D;切换&#x3D;&#x3D;分支。</p><blockquote><p>git merge 分支名 || git rebase（不建议使用）</p></blockquote><p>​&#x3D;&#x3D;合并&#x3D;&#x3D;分支，即将命令中分支合并到当前分支。</p><blockquote alt="info">    <p>        对于两个分支pub和pri（pub是公，pri是私），git merge 合并分支操作流程    </p></blockquote><ol><li>&#x3D;&#x3D;切换&#x3D;&#x3D;分支 pub 并&#x3D;&#x3D;拉取&#x3D;&#x3D; pub 最新数据，<code>git switch pub </code>&amp;&amp;<code>git pull</code>。</li><li>将pub的代码&#x3D;&#x3D;合并到pri&#x3D;&#x3D;，<code>git switch pri </code>&amp;&amp;<code>git merge pub </code>。</li><li>进入merge状态，解决冲突，&#x3D;&#x3D;HEAD&#x3D;&#x3D;是本分支内容。</li><li><code>git add .</code>提交&#x3D;&#x3D;暂缓区&#x3D;&#x3D;。</li><li><code>git commit . -i -m &quot;fix:merge pub&quot;</code> &#x3D;&#x3D;提交冲突&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;测试&#x3D;&#x3D;代码是否正确。</li><li>将 pri 的代码&#x3D;&#x3D;合并到pub&#x3D;&#x3D;，<code>git switch pub</code>&amp;&amp;<code>git merge pri</code>。</li><li>提交代码到远端 pub 分支，<code>git push origin pub</code>。</li></ol><blockquote alt="danger">    <p>        git rebase 合并分支操作流程 （不建议），除非没别人依赖于当前分支    </p></blockquote><p>​大部分与<code>git merge</code>相同，只是依赖于哪个分支时，合并将<code>git merge 依赖分支</code>改成如下几步骤：</p><ol><li><code>git rebase 依赖分支名</code></li><li><code>git add .</code></li><li><code>git rebase --continue</code></li></ol><blockquote alt="danger">    <p>        git rebase 与 git merge 区别    </p></blockquote><p>​两者主要在于&#x3D;&#x3D;时间线不同&#x3D;&#x3D;，使用<code>git rebase</code>时要求&#x3D;&#x3D;没别人依赖&#x3D;&#x3D;于当前分支，因为会&#x3D;&#x3D;改变commit-id。&#x3D;&#x3D;</p><img src="https://telegraph-image-9wl.pages.dev/file/3a0bb7860bfec739a515c.png" alt="image-20240220215853137" style="zoom:70%;" /><p>​上图理解：左图将两个分支&#x3D;&#x3D;直接合并&#x3D;&#x3D;，右图（lshift和mod是一个东西）将另一个分支的修改&#x3D;&#x3D;直接放在当前分支最新状态的后面。&#x3D;&#x3D;</p><blockquote alt="danger">    <p>        git rebase 原理    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/cd978a907ace8e9cc044b.png" alt="image-20240220220558946" style="zoom:67%;" /><p>​<code>git rebase</code>将待合并分支&#x3D;&#x3D;直接应用&#x3D;&#x3D;到当前分支&#x3D;&#x3D;最新状态的后面&#x3D;&#x3D;，并且会改变&#x3D;&#x3D;commit-id&#x3D;&#x3D;，即上图中 $\text{C}$ 和 $\text{C’}$ 的 &#x3D;&#x3D;commit-id不同&#x3D;&#x3D;，因此使用<code>git rebase</code>&#x3D;&#x3D;要求没人依赖&#x3D;&#x3D;。</p><blockquote><p>git branch -d 分支名</p></blockquote><p>​&#x3D;&#x3D;删除本地&#x3D;&#x3D;分支。</p><blockquote><p>git push origin -d 分支名</p></blockquote><p>​&#x3D;&#x3D;删除远端&#x3D;&#x3D;分支。</p><h3 id="5-冲突"><a href="#5-冲突" class="headerlink" title="5.冲突"></a>5.冲突</h3><blockquote><p>产生冲突原因</p></blockquote><p>​&#x3D;&#x3D;不同分支修改&#x3D;&#x3D;了同一文件的&#x3D;&#x3D;同一行或相邻行&#x3D;&#x3D;。</p><blockquote><p>解决原则</p></blockquote><p>​不影响其他人提交的功能，也不破坏自己提交的功能。协商解决。</p><blockquote><p>解决 git merge 冲突</p></blockquote><ol><li>修改冲突代码。</li><li><code>git add .</code></li><li><code>git commit . -i -m &quot;fix:...&quot;</code></li></ol><blockquote><p>解决 git rebase 冲突</p></blockquote><ol><li><p>修改冲突代码</p></li><li><p><code>git add .</code></p></li><li><p><code>git rebase --continue</code></p></li></ol><h2 id="3-使用规范"><a href="#3-使用规范" class="headerlink" title="3. 使用规范"></a>3. 使用规范</h2><h3 id="1-分支规范"><a href="#1-分支规范" class="headerlink" title="1. 分支规范"></a>1. 分支规范</h3><img src="https://telegraph-image-9wl.pages.dev/file/e0453fca5043662c7e18f.png" alt="image-20240220221741111" style="zoom:50%;" /><p>​上述图片中，&#x3D;&#x3D;黑框是有远端分支&#x3D;&#x3D;，其余没有远端分支。</p><img src="https://telegraph-image-9wl.pages.dev/file/b7a3c487821d87bf6b86c.png" alt="image-20240220222205748" style="zoom:45%;" />]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection</title>
      <link href="/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/"/>
      <url>/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="AnomalyCLIP"><a href="#AnomalyCLIP" class="headerlink" title="AnomalyCLIP"></a>AnomalyCLIP</h1><blockquote><p>ICLR 2024</p></blockquote><blockquote><p>浙江大学 Qihang Zhou，Shibo He, Jiming Chen</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/bde3dbfce428b9d30dc25.png" alt="image-20240220100508474" style="zoom:43%;" /><blockquote><ol><li>CLIP + Prompt 做ZSAD</li><li>CLIP每个中间层训练一个Text Encoder Prompt</li></ol></blockquote><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-ZSAD（零样本异常检测）任务"><a href="#1-ZSAD（零样本异常检测）任务" class="headerlink" title="1. ZSAD（零样本异常检测）任务"></a>1. ZSAD（零样本异常检测）任务</h3><p>​需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。</p><h3 id="2-CLIP用于异常检测存在的问题"><a href="#2-CLIP用于异常检测存在的问题" class="headerlink" title="2. CLIP用于异常检测存在的问题"></a>2. CLIP用于异常检测存在的问题</h3><blockquote><p>​&#x3D;&#x3D;CLIP主要针对的是前景对象的类语义，而不是图像中的异常&#x2F;正常&#x3D;&#x3D;，这限制了它们在理解视觉异常&#x2F;正常时的泛化能力，导致ZSAD性能较弱。</p></blockquote><h3 id="3-之前的文本提示存在问题"><a href="#3-之前的文本提示存在问题" class="headerlink" title="3. 之前的文本提示存在问题"></a>3. 之前的文本提示存在问题</h3><blockquote><p>​使用手动定义的文本提示或可学习的提示，通常会导致快速嵌入，选择全局特征进行有效的对象语义对齐，&#x3D;&#x3D;未能捕捉到异常，这种异常通常表现为细粒度的局部特征&#x3D;&#x3D;。</p></blockquote><h2 id="2-创新"><a href="#2-创新" class="headerlink" title="2. 创新"></a>2. 创新</h2><h3 id="1-对象无关文本提示在ZSAD上的有效性"><a href="#1-对象无关文本提示在ZSAD上的有效性" class="headerlink" title="1. 对象无关文本提示在ZSAD上的有效性"></a>1. 对象无关文本提示在ZSAD上的有效性</h3><blockquote><p>​首次揭示了学习正常和异常的&#x3D;&#x3D;对象无关文本提示&#x3D;&#x3D;是一种简单而有效的准确的ZSAD方法，AnomalyCLIP模型&#x3D;&#x3D;允许对象不可知&#x3D;&#x3D;，具有很强的ZSAD性能。</p></blockquote><h3 id="2-对象无关提示模版"><a href="#2-对象无关提示模版" class="headerlink" title="2. 对象无关提示模版"></a>2. 对象无关提示模版</h3><blockquote><p>​定义了一个&#x3D;&#x3D;对象无关的提示模板&#x3D;&#x3D;，&#x3D;&#x3D;简化了提示符的设计&#x3D;&#x3D;，&#x3D;&#x3D;不需要修改提示词&#x3D;&#x3D;，即可用于不同领域。</p></blockquote><p>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{object}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{object}]<br>$$</p><h3 id="3-全局局部异常损失函数"><a href="#3-全局局部异常损失函数" class="headerlink" title="3. 全局局部异常损失函数"></a>3. 全局局部异常损失函数</h3><blockquote><p>​定义了一个&#x3D;&#x3D;全局局部异常损失函数&#x3D;&#x3D;。</p></blockquote><h3 id="4-对角突出注意力DPAM"><a href="#4-对角突出注意力DPAM" class="headerlink" title="4. 对角突出注意力DPAM"></a>4. 对角突出注意力DPAM</h3><blockquote><p>​DPAM(Diagonally Prominent Attention Map)，使得分割图的注意力更加突出。</p></blockquote><p>​CLIP 的 visual encoder 中的 $Q - K$ 注意力机制，替换为  $Q - Q$ ，  $K - K$ ，  $V - V$ 等对角注意力。 </p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-对象无关的提示词"><a href="#1-对象无关的提示词" class="headerlink" title="1. 对象无关的提示词"></a>1. 对象无关的提示词</h3><blockquote><p>​为区分异常和非异常，设计提示词 [damaged]</p></blockquote><p>​CLIP中常用提示 A photo of A [cls] ，主要&#x3D;&#x3D;关注对象语义&#x3D;&#x3D;。为了支持异常判别文本嵌入的学习，我们的&#x3D;&#x3D;目标是将先验异常语义整合到文本提示模板&#x3D;&#x3D;中。</p><p>​采用文本 damaged [cls] 为&#x3D;&#x3D;覆盖全面异常语义的通用提示模版&#x3D;&#x3D;，引入&#x3D;&#x3D;可学习的文本提示模板进行微调&#x3D;&#x3D;。<br>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{cls}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{cls}]<br>$$</p><blockquote><p>​为识别一般异常模式，忽略对象，设计提示词 [object]</p></blockquote><p>​对象语义上存在一些实质性的差异，但&#x3D;&#x3D;底层的异常模式可能是相似的&#x3D;&#x3D;。</p><p>​对于ZSAD来说，在对象感知的&#x3D;&#x3D;文本提示模板中包含对象语义通常是不必要的&#x3D;&#x3D;。它甚至会&#x3D;&#x3D;阻碍&#x3D;&#x3D;对学习过程中没有发现的类异常现象的检测。</p><p>​文本提示模板中排除对象语义允许可学习的文本提示模板&#x3D;&#x3D;专注于捕获异常本身的特征，而不是对象&#x3D;&#x3D;。</p><blockquote alt="info"><p>最终提示词</p></blockquote><p>$$<br>g_n &#x3D; [V_1][V_2] \ldots [V_E][\text{object}]<br>$$</p><p>$$<br>g_a &#x3D; [W_1][W_2] \ldots [W_E][\text{damaged}][\text{object}]<br>$$</p><h3 id="2-全局局部异常损失函数"><a href="#2-全局局部异常损失函数" class="headerlink" title="2. 全局局部异常损失函数"></a>2. 全局局部异常损失函数</h3><blockquote alt="info"><p>最终损失</p></blockquote><p>$$<br>L_{total} &#x3D; L_{global} + \lambda \sum_{M_k \in M} L_{local}^{M_k}<br>$$</p><blockquote><p>​$L_{global}$是全局上下文优化，目的是强制我们的不可知对象的文&#x3D;&#x3D;本嵌入与全局视觉嵌入的图像匹配&#x3D;&#x3D;。</p></blockquote><p>​$L_{global}$  是交叉熵函数，匹配正常&#x2F;异常图像的文本嵌入和视觉嵌入之间的余弦相似度。<br>$$<br>L_{\text{global}} &#x3D; -\frac{1}{N} \sum_{i&#x3D;1}^{N} \left[ y_i \log(\hat{y}_i) + (1 - y_i) \log(1 - \hat{y}_i) \right]<br>$$</p><blockquote><p>​$L_{local}$是局部上下文优化，关注视觉编码器&#x3D;&#x3D;M中间层细粒度的局部异常区域&#x3D;&#x3D;。</p></blockquote><p>$$<br>S^{(j,k)}_n &#x3D; P(g_n, f_i^{m(j,k)}), \quad j \in [1,H], \quad k \in [1,W]<br>$$</p><p>$$<br>S^{(j,k)}_a &#x3D; P(g_a, f_i^{m(j,k)}), \quad j \in [1,H], \quad k \in [1,W<br>$$</p><p>$$<br>L_ &#x3D; {Focal}([{Up}(S_n), {Up}(S_a)], S) + {Dice}({Up}(S_n), I - S) + {Dice}({Up}(S_a), S)<br>$$</p><ul><li>$[^.,^.]$ 代表沿着哪个维度。</li><li>$U_P(.)$  代表上采样。</li><li>$I$ 代表全 1 向量</li><li>$f_i^{m(j,k)}$ 代表图片经视觉编码器后M层特征</li><li>$P()$ 代表CLIP概率  $p(y &#x3D; c | x_i) &#x3D; P(g_c, f_i) &#x3D; \frac{\exp(\langle g_c, f_i \rangle &#x2F; \tau)}{\sum_{c \in C} \exp(\langle g_c, f_i \rangle &#x2F; \tau)}$</li></ul><blockquote><p>​Focal Loss</p></blockquote><p>​主要用于解决&#x3D;&#x3D;目标检测中的类别不平衡问题&#x3D;&#x3D;。这个损失函数是交叉熵损失的一个变体，它通过&#x3D;&#x3D;减少易分类样本的相对损失来增加模型对难分类样本的关注&#x3D;&#x3D;。</p><p>​给定模型对正类的预测概率为 $P$ （对于负类为 $1-P$）。<br>$$<br>{Focal Loss}(p_t) &#x3D; -\alpha_t (1 - p_t)^\gamma \log(p_t)<br>$$</p><ul><li><p>$p_t$ 是模型对实际标签为 $t$  的预测概率。</p></li><li><p>$\alpha$ 是一个权重因子，用于平衡正负样本之间的不平衡。</p></li><li><p>$\gamma$ 是调节因子，用于减少易分类样本的权重，增强难分类样本的影响。</p></li></ul><blockquote><p>​Dice Loss</p></blockquote><p>​通常用于&#x3D;&#x3D;医学图像分割领域&#x3D;&#x3D;，用于解决&#x3D;&#x3D;分割任务中的类别不平衡问题&#x3D;&#x3D;。Dice Loss 是一种用于&#x3D;&#x3D;比较两个样本相似度的度量&#x3D;&#x3D;，特别是在分割任务中，用于&#x3D;&#x3D;比较预测分割图和真实分割图的相似度&#x3D;&#x3D;。</p><p>​给定预测结果 $P$ 和真实标签 $G$（均为二值图像）。</p><p>$$<br>{Dice Loss}(P,G) &#x3D; 1 - \frac{2 \sum_{i&#x3D;1}^{N} p_i g_i + \epsilon}{\sum_{i&#x3D;1}^{N} p_i^2 + \sum_{i&#x3D;1}^{N} g_i^2 + \epsilon}<br>$$</p><ul><li>$p_i$和$g_i$分别是预测结果和真实标签在像素 $i$处的值。</li><li>$N$ 是图像中的像素总数。</li><li>$\epsilon$ 是一个小的平滑项，用于防止分母为零，通常取一个很小的正数。</li></ul><h3 id="3-Text-encoder的细化"><a href="#3-Text-encoder的细化" class="headerlink" title="3. Text encoder的细化"></a>3. Text encoder的细化</h3><img src="https://telegraph-image-9wl.pages.dev/file/fff42825d595a8caaaf5e.png" alt="image-20240221100146558" style="zoom:50%;" /><blockquote><p>​为了便于通过损失函数学习更有区别的文本空间，通过在&#x3D;&#x3D;CLIP的文本编码器中添加额外的可学习标记&#x3D;&#x3D;来优化原始文本空间。</p></blockquote><ol><li>随机初始化 $M$ 层可学习标记 $t’_{m}$。</li><li>在通道层 channel 拼接可学习标记 $t’<em>{m}$ 和原始向量 $t’</em>{m}$，$[t’_{m},t_m]$。</li><li>通过$M$ 层神经网络 $T_M$，即 $[r’<em>{m+1},t</em>{m+1}] &#x3D; T_M([t’_{m},t_m])$。</li><li>丢弃 $r’<em>{m+1}$（提供&#x3D;&#x3D;更多可学习标记&#x3D;&#x3D;） ，重新初始化新的可学习标记 $t’</em>{m+1}$ ，重复上述步骤。</li></ol><h3 id="4-Local-visual-embedding-的细化"><a href="#4-Local-visual-embedding-的细化" class="headerlink" title="4. Local visual embedding 的细化"></a>4. Local visual embedding 的细化</h3><blockquote><p>​提出DPAM注意力机制，减少其他标记的干扰，改善局部视觉语义。</p></blockquote><p>​CLIP中使用的对比损耗使得 visual encoder 产生一个具有代表性的全局嵌入来识别语义类，这些标记可能有助于全局对象识别，但它们&#x3D;&#x3D;破坏了局部视觉语义&#x3D;&#x3D;，这直接&#x3D;&#x3D;阻碍了&#x3D;&#x3D;对对象无关文本提示中的&#x3D;&#x3D;细粒度异常的有效学习&#x3D;&#x3D;。<br>$$<br>{Attention}(Q,K,V)<em>i &#x3D; {softmax}\left( \frac{q_i K^{\top}}{\sqrt{D}} \right) V &#x3D; \frac{\sum</em>{j&#x3D;1}^{n} a_{ij}^{qk} v_j}{\sum_{j&#x3D;1}^{n} a_{ij}^{qk}}, \quad a_{ij}^{qk} &#x3D; e^{\frac{q_i k_j^{\top}}{\sqrt{D}}}<br>$$<br>​对于上述 CLIP 的 visual encoder 中的 $Q - K$ 注意力机制，将 $a_{ij}^{qk}$ 替换如下：<br>$$<br>a_{ij}^{qq} &#x3D; e^{\frac{q_i q_j^{\top}}{\sqrt{D}}}, \quad a_{ij}^{kk} &#x3D; e^{\frac{k_i k_j^{\top}}{\sqrt{D}}}, \quad a_{ij}^{vv} &#x3D; e^{\frac{v_i v_j^{\top}}{\sqrt{D}}}<br>$$</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><img src="https://telegraph-image-9wl.pages.dev/file/d925c1729c6052f540266.png" alt="image-20240220152918094" style="zoom:38%;" /><ol><li><p>Image-level 使用相似度分数 $P(g_a,f_i)$ 作为异常分数，$g_a$ 是 text embedding，$f_i$ 是visual embedding。$g_a&#x3D;f_i$ 时，$P(g_a,f_i) &#x3D; 1$。</p></li><li><p>Pixel-level  使用如下公式计算异常得分。<br>$$<br>\quad M &#x3D; G_{\sigma}\left(\text{Bilinear Interpolation}\left( \frac{1}{2} (I - S_n + S_a)\right)\right)，M \in \mathbb{R}^{H_{\text{image}} \times W_{\text{image}}}<br>$$</p></li></ol><p><a href="https://arxiv.org/abs/2310.18961">论文链接</a></p><p><a href="https://github.com/zqhang/AnomalyCLIP">代码链接（未上传）</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install_name_tool 解决链接找不到动态库</title>
      <link href="/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>在学习cmake时，遇到链接动态库后，运行二进制文件找不到动态库的问题。</p><img src="https://telegraph-image-9wl.pages.dev/file/dbe8655627acc332ef9c7.png" alt="image-20240217224721043" style="zoom: 39%;" /></blockquote><p>​工程目录如下图</p><img src="https://telegraph-image-9wl.pages.dev/file/ac58a15f15d7acdb25de5.png" alt="image-20240217134118637" style="zoom:50%;" /><p>​在CMakeLists.txt文件中代码如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.8</span>.<span class="number">4</span>)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main main.c)</span><br><span class="line"><span class="comment">#添加项目头文件目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(../<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="comment">#设置项目lib库目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIB_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#链接动态库和项目</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main <span class="variable">$&#123;LIB_PATH&#125;</span>/libhello.dylib)</span><br><span class="line"><span class="comment">#在bin目录下生成二进制文件</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​我需要链接 libhello.dylib，但是打印链接路径却为</p><img src="https://telegraph-image-9wl.pages.dev/file/91608d55048c27e430d65.png" alt="image-20240217190928315" style="zoom:50%;" /><p>​这里的第一行 libhello.1.dylib 就是 libhello.dylib， libhello.dylib 的内部名称被设置为 libhello.1.dylib，使用 &#x3D;&#x3D;otool -D libhello.dylib&#x3D;&#x3D; 进行查看。</p><img src="https://telegraph-image-9wl.pages.dev/file/74d28ecd358f74d505746.png" alt="image-20240217224353351" style="zoom:80%;" /><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>install_name_tool 添加动态库路径</p></blockquote><blockquote><p>install_name_tool -change old_path new_path binary</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change libhello.1.dylib @executable_path/../../lib/libhello.1.dylib ./bin/main</span><br></pre></td></tr></table></figure><p>​查看此时链接文件路径：</p><img src="https://telegraph-image-9wl.pages.dev/file/112da3b94fbb6c6e98679.png" alt="image-20240217225920116" style="zoom:50%;" /><p>​直接运行二进制文件成功。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/"/>
      <url>/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="1-CMake使用"><a href="#1-CMake使用" class="headerlink" title="1. CMake使用"></a>1. CMake使用</h2><h3 id="1-内部构建"><a href="#1-内部构建" class="headerlink" title="1. 内部构建"></a>1. 内部构建</h3><blockquote><ol><li>&#x3D;&#x3D;cmake .&#x3D;&#x3D;  ，’ . ‘ 表示在当前目录构建。</li><li>在当前目录 &#x3D;&#x3D;make&#x3D;&#x3D;，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。</li></ol></blockquote><h3 id="2-外部构建"><a href="#2-外部构建" class="headerlink" title="2. 外部构建"></a>2. 外部构建</h3><blockquote><ol><li>创建目录 &#x3D;&#x3D;mkdir build&#x3D;&#x3D;。</li><li>构建 &#x3D;&#x3D;cmake ..&#x3D;&#x3D; ，’ .. ‘ 表示从上层构建。（其他路径构建用 &#x3D;&#x3D;cmake &lt;工程的全路径&gt;&#x3D;&#x3D;）</li><li>在当前目录 &#x3D;&#x3D;make&#x3D;&#x3D;，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。</li></ol></blockquote><blockquote alt="warn"><p>通过外部编译进行工程构建，PROJECT_SOURCE_DIR 仍然指代工程路径，即cmake/t1 而 PROJECT_BINARY_DIR 则指代编译路径，即cmake/t1/build</p></blockquote><h3 id="3-约定目录"><a href="#3-约定目录" class="headerlink" title="3. 约定目录"></a>3. 约定目录</h3><ol><li>子目录&#x3D;&#x3D;src&#x3D;&#x3D;，用来放置&#x3D;&#x3D;工程源代码&#x3D;&#x3D;。</li><li>子目录&#x3D;&#x3D;doc&#x3D;&#x3D;，用来放置这个工程的文档&#x3D;&#x3D;工程名.txt&#x3D;&#x3D;。</li><li>子目录&#x3D;&#x3D;lib&#x3D;&#x3D;，用于放置工程&#x3D;&#x3D;共享库&#x3D;&#x3D;。</li><li>工程目录添加文本文件 &#x3D;&#x3D;COPYRIGHT, README&#x3D;&#x3D;。</li><li>工程目录添加一个&#x3D;&#x3D;runhello.sh&#x3D;&#x3D; 脚本，用来&#x3D;&#x3D;调用工程二进制文件&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;构建后&#x3D;&#x3D;的目标文件放入构建目录的&#x3D;&#x3D;bin 子目录&#x3D;&#x3D;。</li><li>安装：将&#x3D;&#x3D;工程二进制&#x3D;&#x3D;与&#x3D;&#x3D;runhello.sh&#x3D;&#x3D; 安装至&#x2F;usr&#x2F;bin，将&#x3D;&#x3D;doc 目录的内容&#x3D;&#x3D;以及&#x3D;&#x3D;COPYRIGHT&#x2F;README&#x3D;&#x3D; 安装到&#x2F;usr&#x2F;share&#x2F;doc&#x2F;cmake&#x2F;项目名。</li></ol><h3 id="4-安装共享库"><a href="#4-安装共享库" class="headerlink" title="4. 安装共享库"></a>4. 安装共享库</h3><p>​使用外部构建，即在build文件下执行下列操作。</p><ol><li>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;Users&#x2F;justhuayu&#x2F;mylibs ..  设置项目安装目录</li><li>make </li><li>make install</li></ol><h3 id="5-使用共享库"><a href="#5-使用共享库" class="headerlink" title="5. 使用共享库"></a>5. 使用共享库</h3><p>​项目路径如下。</p><img src="https://telegraph-image-9wl.pages.dev/file/ac58a15f15d7acdb25de5.png" alt="image-20240217134118637" style="zoom:50%;" /><p>​子目录 CMakeLists.txt 文件代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">2.8</span>.<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main main.c)</span><br><span class="line"><span class="comment">#添加项目头文件目录</span></span><br><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(../<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="comment">#设置项目lib库目录</span></span><br><span class="line"><span class="keyword">SET</span>(LIB_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment">#MESSAGE(STATUS &quot;LIB_PATH is &quot; $&#123;LIB_PATH&#125;)</span></span><br><span class="line"><span class="comment">#链接动态库和项目</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main <span class="variable">$&#123;LIB_PATH&#125;</span>/libhello.dylib)</span><br><span class="line"><span class="comment">#在bin目录下生成二进制文件</span></span><br><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure><ol><li>cmake .. +  make 构建。</li><li>linux使用ldd bin&#x2F;main ，macos使用 otool -L bin&#x2F;main 查看链接库（静态库不显示）。</li></ol><h3 id="6-编译-debug-版和-release-版"><a href="#6-编译-debug-版和-release-版" class="headerlink" title="6. 编译 debug 版和 release 版"></a>6. 编译 debug 版和 release 版</h3><blockquote><p>编译debug版本</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>​生成的执行文件和库在 &#x2F;release&#x2F;linux&#x2F;Debug</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定构建类型的输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Debug)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Release)</span><br><span class="line"><span class="comment"># 对于库文件，也可以设置相应的目录</span></span><br><span class="line"><span class="comment"># set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ...)</span></span><br><span class="line"><span class="comment"># set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ...)</span></span><br></pre></td></tr></table></figure><blockquote><p>编译release版本</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><h3 id="1-PROJECT"><a href="#1-PROJECT" class="headerlink" title="1. PROJECT"></a>1. PROJECT</h3><blockquote><p>PROJECT(projectname [CXX] [C] [Java])</p></blockquote><p>​这个指令&#x3D;&#x3D;定义工程名称&#x3D;&#x3D;，并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。</p><p>​隐式的定义了两个 cmake 变量: <projectname>_BINARY_DIR 以及<projectname> _SOURCE_DIR。例如 <code>PROJECT(hello)</code>，则为 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。</p><p>​cmake 也预定义了 &#x3D;&#x3D;PROJECT_BINARY_DIR&#x3D;&#x3D; 和 &#x3D;&#x3D;PROJECT_SOURCE_DIR&#x3D;&#x3D;变量（&#x3D;&#x3D;建议使用&#x3D;&#x3D;），他们的值分别跟HELLO_BINARY_DIR 与HELLO_SOURCE_DIR 一致。</p><ol><li>PROJECT_BINARY_DIR 表示&#x3D;&#x3D;编译路径&#x3D;&#x3D;。</li><li>PROJECT_SOURCE_DIR 表示&#x3D;&#x3D;项目路径&#x3D;&#x3D;。</li></ol><h3 id="2-SET"><a href="#2-SET" class="headerlink" title="2. SET"></a>2. SET</h3><blockquote><p>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</p></blockquote><p>​SET 指令可以用来&#x3D;&#x3D;显式的定义变量&#x3D;&#x3D;。<code>SET(SRC_LIST main.c t1.c t2.c)</code>。</p><h3 id="3-MESSAGE"><a href="#3-MESSAGE" class="headerlink" title="3. MESSAGE"></a>3. MESSAGE</h3><blockquote><p>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “打印信息” …)</p></blockquote><p>​这个指令用于向终端&#x3D;&#x3D;输出用户定义的信息&#x3D;&#x3D;，包含了三种类型: </p><ol><li><p>&#x3D;&#x3D;SEND_ERROR&#x3D;&#x3D;，产生错误，生成过程被跳过。</p><p><code>message(SEND_ERROR &quot;cmake is error&quot;)</code></p></li><li><p>&#x3D;&#x3D;SATUS&#x3D;&#x3D;，输出前缀为—的信息。</p><p><code>message(STATUS &quot;This is BINARY dir &quot; $&#123;PROJECT_BINARY_DIR&#125;)</code></p></li><li><p>&#x3D;&#x3D;FATAL_ERROR&#x3D;&#x3D;，立即终止所有cmake 过程。</p></li></ol><h3 id="4-ADD-EXECUTABLE"><a href="#4-ADD-EXECUTABLE" class="headerlink" title="4. ADD_EXECUTABLE"></a>4. ADD_EXECUTABLE</h3><blockquote><p>ADD_EXECUTABLE(二进制文件名 ${源文件变量名})</p></blockquote><p>​生成可执行文件，相关的源文件是&#x3D;&#x3D;${源文件变量名}&#x3D;&#x3D;中定义的源文件列表。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello)</span><br><span class="line"><span class="keyword">SET</span>(src_file main.c)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello <span class="variable">$&#123;src_file&#125;</span>)</span><br></pre></td></tr></table></figure><p>​上述将 main.c 文件生成 hello 可执行文件，等价于</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello main.c)</span><br></pre></td></tr></table></figure><h3 id="5-ADD-SUBDIRECTORY"><a href="#5-ADD-SUBDIRECTORY" class="headerlink" title="5. ADD_SUBDIRECTORY"></a>5. ADD_SUBDIRECTORY</h3><blockquote><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p></blockquote><p>​向当前工程&#x3D;&#x3D;添加存放源文件的子目录&#x3D;&#x3D;，并可以指定中间二进制和目标二进制存放的位置。</p><p>​EXCLUDE_FROM_ALL 参数的含义是将&#x3D;&#x3D;这个目录从编译过程中排除&#x3D;&#x3D;。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>​上述代码会将 src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。</p><h3 id="6-指定保存目标二进制位置"><a href="#6-指定保存目标二进制位置" class="headerlink" title="6. 指定保存目标二进制位置"></a>6. 指定保存目标二进制位置</h3><blockquote><p>EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><p>​上述代码写在哪个 CMakeLists.txt ：在哪里 ADD_EXECUTABLE  或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义。</p><h3 id="7-INSTALL"><a href="#7-INSTALL" class="headerlink" title="7. INSTALL **"></a>7. INSTALL **</h3><blockquote><p>INSTALL(TARGETS targets…</p><p>[[ARCHIVE|LIBRARY|RUNTIME]</p><p>[DESTINATION <dir>]</p><p>[PERMISSIONS permissions…]</p><p>[CONFIGURATIONS</p><p>[Debug|Release|…]]</p><p>[COMPONENT <component>]</p><p>[OPTIONAL]</p><p>] […])</p></blockquote><h3 id="8-清理工程"><a href="#8-清理工程" class="headerlink" title="8. 清理工程"></a>8. 清理工程</h3><blockquote><p>make clean</p></blockquote><p>​和 Makefile 一样，使用 <code>make clean</code> 对构建结果进行清理。</p><h3 id="9-ADD-LIBRARY"><a href="#9-ADD-LIBRARY" class="headerlink" title="9. ADD_LIBRARY"></a>9. ADD_LIBRARY</h3><blockquote><p>ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL]</p><p>source1 source2 … sourceN)</p></blockquote><p>​生成库文件。</p><p>​libname不用写全称，写 hello，cmake会自动生成 libhello.X。</p><ol><li><p>SHARED，动态库</p></li><li><p>STATIC，静态库</p></li><li><p>MODULE，在使用 dyld 的系统有效，如果不支持dyld，则被当作SHARED 对待。</p></li></ol><p>​EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。</p><blockquote><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})#SHARED动态库</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在 lib 目录下建立 CMakeLists.txt，内容如下：</span></span><br><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.c)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#SHARED动态库</span></span><br></pre></td></tr></table></figure><p>​然后 <code>cmake ..</code> ， <code> make</code> ，此时可以在lib 目录得到一个&#x3D;&#x3D;libhello.so&#x3D;&#x3D;，这就是我们期望的共享库。</p><p>​指定 libhello.so 生成的位置，可以通过在&#x3D;&#x3D;主工程文件&#x3D;&#x3D;CMakeLists.txt 中修改 &#x3D;&#x3D;ADD_SUBDIRECTORY(lib)&#x3D;&#x3D;指令来指定一个编译输出位置 或者 在 &#x3D;&#x3D;lib&#x2F;CMakeLists.txt&#x3D;&#x3D; 中添加 &#x3D;&#x3D;SET(LIBRARY_OUTPUT_PATH &lt;路径&gt;)&#x3D;&#x3D;来指定一个新的位置。</p><h3 id="10-SET-TARGET-PROPERTIES"><a href="#10-SET-TARGET-PROPERTIES" class="headerlink" title="10. SET_TARGET_PROPERTIES"></a>10. SET_TARGET_PROPERTIES</h3><blockquote><p>SET_TARGET_PROPERTIES(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)</p></blockquote><p>​设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#STATIC静态库</span></span><br></pre></td></tr></table></figure><blockquote alt="danger"><p>工程中可同时存在静态库和动态库，只不过<strong style="color:red;">动态库后缀.so，静态库后缀.a</strong>。但当存在动态库时，使用上述命令会报错，因为<strong style="color:red;">hello 作为一个target 是不能重名的</strong>，所以，静态库构建指令无效。</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(LIBHELLO_SRC hello.c)</span><br><span class="line"><span class="keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)<span class="comment">#STATIC静态库</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>) </span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>上述代码执行后即可得到动态库和静态库，如果只有一个，则考虑下述解决方式</p></blockquote><p>​此时查看构建结果，发现&#x3D;&#x3D;hello.so&#x3D;&#x3D;消失，只有&#x3D;&#x3D;hello.a&#x3D;&#x3D;。cmake 在构建一个新的target 时，会尝试&#x3D;&#x3D;清理掉其他使用这个名字的库&#x3D;&#x3D;，因为，在构建libhello.a 时，就会清理掉libhello.so。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向lib/CMakeLists.txt 中添加:</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​这时候，我们再次进行构建，会发现build&#x2F;lib 目录中同时生成了libhello.so 和 libhello.a。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>) </span><br></pre></td></tr></table></figure><p>​VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="11-INCLUDE-DIRECTORIES"><a href="#11-INCLUDE-DIRECTORIES" class="headerlink" title="11. INCLUDE_DIRECTORIES"></a>11. INCLUDE_DIRECTORIES</h3><blockquote><p>INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</p></blockquote><p>​向工程添加多个特定的&#x3D;&#x3D;头文件搜索路径&#x3D;&#x3D;，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，&#x3D;&#x3D;默认&#x3D;&#x3D;的行为是追加到当前的&#x3D;&#x3D;头文件搜索路径的后面&#x3D;&#x3D;。</p><p>​控制将头文件搜索路径放在前面还是后面：</p><ol><li>CMAKE_INCLUDE_DIRECTORIES_BEFORE，通过&#x3D;&#x3D;SET 这个cmake 变量为on&#x3D;&#x3D;，可以将添加的&#x3D;&#x3D;头文件搜索路径&#x3D;&#x3D;放在已有路径的&#x3D;&#x3D;前面&#x3D;&#x3D;。</li><li>通过AFTER 或者BEFORE 参数，也可以控制是追加还是置前。</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(/usr/<span class="keyword">include</span>/hello)</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>上述代码执行后找到头文件，但可能会报错</p></blockquote><p>​进入build 目录，重新进行构建，这是找不到 hello.h 的错误已经消失，但是出现了一个新的错误：<code>main.c:(.text+0x12): undefined reference to HelloFunc</code>因为我们并没有&#x3D;&#x3D;link 到共享库libhello&#x3D;&#x3D; 上。</p><h3 id="12-LINK-DIRECTORIES"><a href="#12-LINK-DIRECTORIES" class="headerlink" title="12. LINK_DIRECTORIES"></a>12. LINK_DIRECTORIES</h3><blockquote><p>LINK_DIRECTORIES(directory1 directory2 …)</p></blockquote><p>​&#x3D;&#x3D;添加&#x3D;&#x3D;非标准的&#x3D;&#x3D;共享库搜索路径&#x3D;&#x3D;，比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。</p><h3 id="13-TARGET-LINK-LIBRARIES"><a href="#13-TARGET-LINK-LIBRARIES" class="headerlink" title="13. TARGET_LINK_LIBRARIES"></a>13. TARGET_LINK_LIBRARIES</h3><blockquote><p>TARGET_LINK_LIBRARIES(target library1 &lt;debug | optimized&gt; library2 …)</p></blockquote><p>​为 target  &#x3D;&#x3D;添加需要链接的共享库&#x3D;&#x3D;。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello)</span><br><span class="line"><span class="comment">#或者 链接动态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello.dylib)</span><br><span class="line"><span class="comment">#或者 链接静态库</span></span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello.a)</span><br></pre></td></tr></table></figure><h3 id="14-install-name-tool"><a href="#14-install-name-tool" class="headerlink" title="14. install_name_tool"></a>14. install_name_tool</h3><blockquote><p>链接动态库时，可能会找不到路径，使用install_name_tool 添加路径即可</p></blockquote><p>​install_name_tool 是 macOS 系统上用来修改 Mach-O 二进制文件（包括可执行文件、动态库(dylib)和捆绑包(bundle)）内部的动态链接信息的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change old_path new_path binary</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_name_tool -change libhello.1.dylib @executable_path/../../lib/libhello.1.dylib ./bin/main</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/112da3b94fbb6c6e98679.png" alt="image-20240217225920116" style="zoom:50%;" /><h3 id="15-FIND"><a href="#15-FIND" class="headerlink" title="15. FIND_"></a>15. FIND_</h3><blockquote><p>FIND_FILE(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表找到的&#x3D;&#x3D;文件全路径&#x3D;&#x3D;，包含文件名。</p><blockquote><p>FIND_LIBRARY(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量表示找到的&#x3D;&#x3D;库全路径&#x3D;&#x3D;，包含库文件名</p><blockquote><p>FIND_PATH(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表&#x3D;&#x3D;包含这个文件的路径&#x3D;&#x3D;。</p><blockquote><p>FIND_PROGRAM(<VAR> name1 path1 path2 …)</p></blockquote><p>​VAR 变量代表&#x3D;&#x3D;包含这个程序的全路径&#x3D;&#x3D;。</p><blockquote><p>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets…]])</p></blockquote><p>​用来调用预定义在CMAKE_MODULE_PATH 下的Find<name>.cmake 模块，你也可以自己定义Find<name>模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用。</p><blockquote alt="info"><p>FIND_指令示例</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_LIBRARY</span>(libX X11 /usr/lib)</span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">NOT</span> libX)</span><br><span class="line"><span class="keyword">MESSAGE</span>(FATAL_ERROR “libX <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> libX)</span><br></pre></td></tr></table></figure><h3 id="16-IF指令"><a href="#16-IF指令" class="headerlink" title="16.IF指令"></a>16.IF指令</h3><blockquote><p>IF 、ELSE 、ELSEIF 、ENDIF </p></blockquote><p>​出现IF 的地方一定要有&#x3D;&#x3D;对应的ENDIF&#x3D;&#x3D;。出现 ELSEIF 的地方，&#x3D;&#x3D;ENDIF 是可选&#x3D;&#x3D;的。ENDIF、ELSE中内容与IF中内容一致。</p><blockquote alt="info"><p>IF ELSE 用法，注意容易产生歧义</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS “This is windows.”)<span class="comment">#作一些Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ELSE</span>(WIN32)<span class="comment">#容易歧义</span></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS “This is <span class="keyword">not</span> windows”)<span class="comment">#作一些非Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>使用 CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="keyword">ELSE</span>()</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>使用 ELSEIF</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="comment">#do something related to WIN32</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(UNIX)</span><br><span class="line"><span class="comment">#do something related to UNIX</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(APPLE)</span><br><span class="line"><span class="comment">#do something related to APPLE</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure><blockquote><p>常见 IF 表达式</p></blockquote><table><thead><tr><th>IF表达式</th><th>作用</th></tr></thead><tbody><tr><td>IF(var)</td><td>表达式为&#x3D;&#x3D;真&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;NOT&#x3D;&#x3D; var )</td><td>表达式为&#x3D;&#x3D;假&#x3D;&#x3D;</td></tr><tr><td>IF(var1 &#x3D;&#x3D;AND&#x3D;&#x3D; var2)</td><td>两个变量&#x3D;&#x3D;都为真&#x3D;&#x3D;</td></tr><tr><td>IF(var1 &#x3D;&#x3D;OR&#x3D;&#x3D; var2)</td><td>两个变量&#x3D;&#x3D;其中一个为真&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;COMMAND&#x3D;&#x3D; cmd)</td><td>给定的 cmd 确实&#x3D;&#x3D;是命令并可以调用&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;EXISTS&#x3D;&#x3D; dir)、IF(&#x3D;&#x3D;EXISTS&#x3D;&#x3D; file)</td><td>当目录名或者文件名&#x3D;&#x3D;存在&#x3D;&#x3D;</td></tr><tr><td>IF(file1 &#x3D;&#x3D;IS_NEWER_THAN&#x3D;&#x3D; file2)</td><td>当file1 比file2 &#x3D;&#x3D;新&#x3D;&#x3D;，<br />file1&#x2F;file2 其中有&#x3D;&#x3D;一个不存在&#x3D;&#x3D;<br/>文件名请使用完整路径。</td></tr><tr><td>IF(&#x3D;&#x3D;IS_DIRECTORY&#x3D;&#x3D; dirname)</td><td>dirname &#x3D;&#x3D;是目录&#x3D;&#x3D;</td></tr><tr><td>IF(variable &#x3D;&#x3D;MATCHES&#x3D;&#x3D; regex)、IF(string &#x3D;&#x3D;MATCHES&#x3D;&#x3D; regex)</td><td>给定的变量或者字符串&#x3D;&#x3D;能够匹配正则表达式&#x3D;&#x3D; regex</td></tr><tr><td>IF(variable &#x3D;&#x3D;LESS&#x3D;&#x3D; number)<br />IF(variable &#x3D;&#x3D;GREATER&#x3D;&#x3D; number)<br/>IF(string &#x3D;&#x3D;EQUAL&#x3D;&#x3D; number)</td><td>&#x3D;&#x3D;数字比较大小&#x3D;&#x3D;</td></tr><tr><td>IF(variable &#x3D;&#x3D;STRLESS&#x3D;&#x3D; string)<br />IF(string &#x3D;&#x3D;STRGREATER&#x3D;&#x3D; string)<br/>IF(string &#x3D;&#x3D;STREQUAL&#x3D;&#x3D; string)</td><td>&#x3D;&#x3D;字母序比较大小&#x3D;&#x3D;</td></tr><tr><td>IF(&#x3D;&#x3D;DEFINED&#x3D;&#x3D; variable)</td><td>变量&#x3D;&#x3D;被定义&#x3D;&#x3D;</td></tr></tbody></table><h3 id="17-循环指令"><a href="#17-循环指令" class="headerlink" title="17. 循环指令"></a>17. 循环指令</h3><blockquote><p>WHILE 、ENDWHILE 循环</p></blockquote><p>​WHILE(条件)、其中条件可以参考IF指令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHILE</span>(condition)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENDWHILE</span>(condition)</span><br></pre></td></tr></table></figure><blockquote><p>FOREACH 、ENDFOREACH 循环</p></blockquote><blockquote alt="info"><p>遍历</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含字符串的列表</span></span><br><span class="line"><span class="keyword">SET</span>(name_list Alice Bob Charlie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历列表并打印每个元素</span></span><br><span class="line"><span class="keyword">FOREACH</span>(name IN LISTS name_list)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;Name: $&#123;name&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>()</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>范围</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从 0 到 total 以１为步进</span></span><br><span class="line"><span class="keyword">FOREACH</span>(VAR RANGE total)</span><br><span class="line"><span class="keyword">MESSAGE</span>(<span class="variable">$&#123;VAR&#125;</span>)<span class="comment">#使用$&#123;&#125;引用变量</span></span><br><span class="line"><span class="keyword">ENDFOREACH</span>(VAR)</span><br><span class="line"><span class="comment">#语法格式</span></span><br><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE start stop [step])</span><br><span class="line"><span class="comment">#从 start 开始到stop 结束，以step 为步进，</span></span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure><h3 id="18-常用变量"><a href="#18-常用变量" class="headerlink" title="18. 常用变量"></a>18. 常用变量</h3><blockquote><p>CMAKE_BINARY_DIR 、PROJECT_BINARY_DIR 、&lt;项目名&gt;_BINARY_DIR</p></blockquote><p>​&#x3D;&#x3D;工程编译&#x3D;&#x3D;的目录。</p><blockquote><p>CMAKE_SOURCE_DIR 、PROJECT_SOURCE_DIR 、 &lt;项目名&gt;_SOURCE_DIR</p></blockquote><p>​&#x3D;&#x3D;工程顶层&#x3D;&#x3D;目录</p><blockquote><p>CMAKE_CURRENT_SOURCE_DIR</p></blockquote><p>​当前处理的&#x3D;&#x3D;CMakeLists.txt&#x3D;&#x3D;所在的路径</p><blockquote><p>CMAKE_BUILD_TYPE</p></blockquote><p>​CMake 中用来指定&#x3D;&#x3D;构建类型&#x3D;&#x3D;的变量，cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ..</p><blockquote><p>CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG</p></blockquote><p>​cmake -DCMAKE_BUILD_TYPE&#x3D;Debug .. 的&#x3D;&#x3D;编译路径&#x3D;&#x3D;</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/release/<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/Debug)</span><br></pre></td></tr></table></figure><blockquote><p>CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE</p></blockquote><p>​cmake -DCMAKE_BUILD_TYPE&#x3D;Release .. 的&#x3D;&#x3D;编译路径&#x3D;&#x3D;</p><blockquote><p>CMAKE_INSTALL_PREFIX</p></blockquote><p>​指定在运行  make install 或类似安装命令时，&#x3D;&#x3D;项目安装的根目录&#x3D;&#x3D;</p><blockquote><p>CMAKE_CURRRENT_BINARY_DIR</p></blockquote><p>​&#x3D;&#x3D;target 编译&#x3D;&#x3D;目录，ADD_SUBDIRECTORY(src bin) 可以更改这个变量的值</p><blockquote><p>EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH</p></blockquote><p>​重新定义&#x3D;&#x3D;最终结果的存放目录&#x3D;&#x3D;。</p><blockquote><p>PROJECT_NAME</p></blockquote><p>​返回通过PROJECT 指令定义的&#x3D;&#x3D;项目名称&#x3D;&#x3D;。</p><blockquote><p>CMAKE_CURRENT_LIST_FILE</p></blockquote><p>​输出&#x3D;&#x3D;调用这个变量&#x3D;&#x3D;的CMakeLists.txt 的完整路径</p><blockquote><p>CMAKE_CURRENT_LIST_LINE</p></blockquote><p>​输出这个&#x3D;&#x3D;变量所在的行&#x3D;&#x3D;</p><blockquote><p>CMAKE_MODULE_PATH</p></blockquote><p>​定义&#x3D;&#x3D;自己的cmake 模块所在的路径&#x3D;&#x3D;，为了让cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过SET 指令，将自己的cmake 模块路径设置一下。</p><p>​SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}&#x2F;cmake) 这时候你就可以通过INCLUDE 指令来调用自己的模块了。</p><h3 id="19-基础语法"><a href="#19-基础语法" class="headerlink" title="19. 基础语法"></a>19. 基础语法</h3><blockquote><p>变量使用&#x3D;&#x3D;${}&#x3D;&#x3D;方式取值，但是在IF 控制语句中是直接使用变量名。</p></blockquote><blockquote><p>指令(参数1 参数 2…)，参数之间使用&#x3D;&#x3D;空格&#x3D;&#x3D;或&#x3D;&#x3D;分号&#x3D;&#x3D;分开。</p></blockquote><p>​<code> ADD_EXECUTABLE(hello main.c func.c)</code> 或者 <code>ADD_EXECUTABLE(hello main.c;func.c)</code></p><blockquote><p>指令是大小写&#x3D;&#x3D;无关&#x3D;&#x3D;的，参数和变量是大小写&#x3D;&#x3D;相关&#x3D;&#x3D;的。&#x3D;&#x3D;推荐全部使用大写指令&#x3D;&#x3D;。</p></blockquote><blockquote><p>源文件的文件名是中间&#x3D;&#x3D;包含了空格&#x3D;&#x3D;，这时候必须使用&#x3D;&#x3D;双引号&#x3D;&#x3D;。</p></blockquote><p>​<code>SET(SRC_LIST fu nc.c</code> 报错找不到fu和nc.c文件，必须写成 <code>SET(SRC_LIST &quot;fu nc.c&quot;)</code>。</p><blockquote><p>可以&#x3D;&#x3D;忽略&#x3D;&#x3D;掉source 列表中的&#x3D;&#x3D;源文件后缀&#x3D;&#x3D;</p></blockquote><p>​<code>ADD_EXECUTABLE(t1 main)</code>，cmake 会自动的在本目录查找main.c 或者main.cpp等，当然，最好不要偷这个懒，以免这个目录确实存在一个 main.c 一个main。</p><blockquote><p>调用环境变量</p></blockquote><p>​$ENV{NAME} 指令可以调用系统的环境变量。<code>MESSAGE(STATUS “HOME dir: $ENV&#123;HOME&#125;”)</code></p><blockquote><p>设置环境变量值</p></blockquote><p>​SET(ENV{变量名} 值) </p><p><a href="https://www.yuque.com/linuxer/xngi03/cs5y85">参考文章：CMake 零声参考资料</a></p><p><a href="https://www.yuque.com/linuxer/xngi03/qh9lve">参考文章：CMake 零声实战</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="1-makefile规则"><a href="#1-makefile规则" class="headerlink" title="1. makefile规则"></a>1. makefile规则</h2><blockquote><p>​Makefile最重要的二个概念一个是目标（target），另一个就是依赖（dependency）。目标就是指要干什么，或说运行 make 后生成什么，而依赖是告诉 make 如何去做以实现目标。</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/5318bd66f24eaeab0381a.png" alt="image.png" style="zoom:60%;" /><img src="https://telegraph-image-9wl.pages.dev/file/3b17e9c52415e9e5144d2.png" alt="image.png" style="zoom:70%;" /><blockquote><p>&#x3D;&#x3D;make -v&#x3D;&#x3D; 命令查看环境。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make -v</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">GNU Make <span class="number">3.81</span></span><br><span class="line"><span class="built_in">Copyright</span> (C) <span class="number">2006</span>  Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source <span class="keyword">for</span> copying conditions.</span><br><span class="line">There is NO warranty; <span class="keyword">not</span> even <span class="keyword">for</span> MERCHANTABILITY <span class="keyword">or</span> FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">This program built <span class="keyword">for</span> i386-apple-darwin11<span class="number">.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><blockquote><p>打印 hello world，echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">echo <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    "echo"时bash shell命令,"echo"前面必须加"tab"。    </p></blockquote><blockquote><p>不打印命令代码，@echo命令</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端命令</span></span><br><span class="line">$make all</span><br><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><blockquote><p>makefile的&#x3D;&#x3D;目标和依赖&#x3D;&#x3D;，all:test</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile文件内容</span></span><br><span class="line">all:test</span><br><span class="line">@echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">test:</span><br><span class="line">@echo <span class="string">&quot;Just for test&quot;</span></span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make</span><br><span class="line">Just <span class="keyword">for</span> test</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line">$make test</span><br><span class="line">Just <span class="keyword">for</span> test</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>    ":"前的"all"是目标，":"后的"test"是依赖（先决条件），makefile会先按从左到右顺序执行依赖，最后执行目标。    </p></blockquote><blockquote alt="info"><p>    "make"命令后不跟任何目标时，优先执行第一个目标。    </p></blockquote><blockquote alt="warn"><p style="color:red;">一个规则是由目标（targets）、先决条件（prerequisites）以及命令（commands）所组成的。    </p></blockquote><p><a href="https://www.yuque.com/linuxer/xngi03/nfsm1k">参考文章：Makefile 零声参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B+ 树的作用</p></blockquote><ol><li>B+树的内层节点做索引，只有叶子节点存储。</li></ol><blockquote><p>B+ 树的用途</p></blockquote><ol><li>MySQL 的数据存储。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树</title>
      <link href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/"/>
      <url>/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>B树的作用</p></blockquote><ol><li>二叉树的层数太高，B树可减少层高</li><li>B树内节点和叶子节点都可存储数据</li></ol><blockquote><p>B树的用途</p></blockquote><ol><li>磁盘数据查找（每个层高查找一次磁盘）</li></ol><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>一颗M阶B树T，满足以下条件</p></blockquote><ol><li>每个结点至多拥有M颗子树</li><li>根结点至少拥有两颗子树</li><li>除了根结点以外，其余每个分支结点至少拥有M&#x2F;2课子树</li><li>所有的叶结点都在同一层上</li><li>有k课子树的分支结点则存在K-1个关键字，关键字按照递增顺序进行排</li><li>关键字数量满足 <code>ceil(M/2) - 1＜ = n ＜ = M - 1</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSTree::Node* &amp;node和BSTree::Node &amp;node 区别</title>
      <link href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/"/>
      <url>/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>写二叉查找树&#x3D;&#x3D;递归插入&#x3D;&#x3D;代码时，参数用&#x3D;&#x3D;Node* &amp;node&#x3D;&#x3D; 和&#x3D;&#x3D;Node &amp;node&#x3D;&#x3D;有着明显的不同。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><blockquote alt="info"> <p>    Node &node这是一个对对象的引用，使用这种方式，函数可以修改通过<strong style="color:red;">引用传递的对象的内容</strong>，但不能改变调用者中<strong style="color:red;">对象的地址</strong>。    </p></blockquote><blockquote alt="info"> <p>    Node* &node这是一个对指针的引用，使用这种方式，函数能够直接修改<strong style="color:red;">传入的指针本身</strong>。    </p></blockquote># 3. 代码<blockquote><p>下面是二叉搜索树实现递归插入节点。</p></blockquote><h2 id="1-Node-node作为参数"><a href="#1-Node-node作为参数" class="headerlink" title="1. Node &amp;node作为参数"></a>1. Node &amp;node作为参数</h2><blockquote><p>Node &amp;node 作为参数，此时节点为空时不能直接 new，必须通过父节点的左右子树new，否则会丢失。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Node-node作为参数"><a href="#2-Node-node作为参数" class="headerlink" title="2. Node* &amp;node作为参数"></a>2. Node* &amp;node作为参数</h2><blockquote><p>Node* &amp;node 作为参数，节点空时可以直接 new，新节点会自动连接到树上。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h2><h3 id="1-main-cpp"><a href="#1-main-cpp" class="headerlink" title="1. main.cpp"></a>1. main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t.<span class="built_in">insertNodeR</span>(<span class="number">10</span>);</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-bstree-h"><a href="#2-bstree-h" class="headerlink" title="2. bstree.h"></a>2. bstree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey,newValue</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> key; <span class="comment">// 释放键资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bstree_node&lt;K_TYPE&gt; Node;</span><br><span class="line">    Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _inOrder(Node* node);<span class="comment">//inOrder() 递归部分</span></span><br><span class="line">    <span class="type">bool</span> _insertR(Node* node,<span class="type">const</span> K_TYPE &amp;key);<span class="comment">//inserNodeR()递归部分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNode</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insertNodeR</span><span class="params">(<span class="type">const</span> K_TYPE&amp; key)</span></span>;<span class="comment">//插入节点----递归</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//中序遍历节点----递归</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;_root == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. 根节点空直接插入</span></span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span> (key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//2. 递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">        <span class="type">bool</span> isNull;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">            isNull = _insertR(node-&gt;left,key);</span><br><span class="line">             <span class="keyword">if</span>(!isNull)&#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, const K_TYPE &amp;key) &#123;</span></span><br><span class="line"><span class="comment">//    if(node == nullptr)&#123;//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line"><span class="comment">//        node = new Node(key);</span></span><br><span class="line"><span class="comment">//        return true;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    //2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line"><span class="comment">//    if (node-&gt;key &lt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;right,key);</span></span><br><span class="line"><span class="comment">//    &#125; else if (node-&gt;key &gt; key) &#123;</span></span><br><span class="line"><span class="comment">//        return _insertR(node-&gt;left,key);</span></span><br><span class="line"><span class="comment">//    &#125; else &#123;//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line"><span class="comment">//        return false;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版template &lt;class T&gt; 和 template &lt;typename T&gt; 区别</title>
      <link href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>学习二叉查找树时，有的使用 template <class T>，有的使用 template <typename T> 。</p></blockquote><h1 id="2-两者区别"><a href="#2-两者区别" class="headerlink" title="2. 两者区别"></a>2. 两者区别</h1><h2 id="1-C-标准中"><a href="#1-C-标准中" class="headerlink" title="1. C++标准中"></a>1. C++标准中</h2><blockquote alt="info"> <p>    template &lt;typename T&gt; 用于<strong style="color:red;">基础数据类型</strong>， T可以是int char 等    </p></blockquote><blockquote alt="info"> <p>    template &lt;class T&gt; 用于<strong style="color:red;">复杂数据类型</strong>， T可以是string，类 等    </p></blockquote><h2 id="2-实际使用"><a href="#2-实际使用" class="headerlink" title="2. 实际使用"></a>2. 实际使用</h2><blockquote><p>大部分情况，typename和class等价。</p></blockquote><blockquote><p>在C++早期版本中，没有 typename 这个关键字，所以在模板定义的时候便使用了 class。</p></blockquote><p><a href="https://blog.csdn.net/qq_20853741/article/details/125879893">参考文章：模板 template＜typename T＞ 和 template＜class T＞区别</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树基础 ----&gt; 二叉查找树</title>
      <link href="/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>用于二分查找</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><blockquote><p>按照<font title="red">中序排列</font>的二叉树</p></blockquote><ol><li>其左子树下的每个后代节点的值都小于节点n的值。</li><li>其右子树下的每个后代节点的值都大于节点n的值。</li><li>左右子树也均为二叉查找树。</li></ol><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3. 类型"></a>3. 类型</h2><h3 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h3><img src="https://telegraph-image-9wl.pages.dev/file/02d58a1def424af138470.png" alt="图2" style="zoom:125%;" /><blockquote><p>所有的结点都只有左子树的二叉树叫<font title="red">左斜树</font>。</p></blockquote><blockquote><p>所有结点都是只有右子树的二叉树叫<font title="red">右斜树</font>。</p></blockquote><blockquote alt="info"><p>左斜树和右斜树统称为<font title="red">斜树</font>。</p></blockquote><h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/982d7941a6b61a3b1dc88.png" alt="图3" style="zoom:125%;" /><blockquote><ol><li>所有分支结点都存在左子树和右子树。</li><li>所有叶子节点（即没有子节点的节点）都在同一层上。</li></ol></blockquote><blockquote alt="info">    <p>        1. 叶子节点只能出现在最下一层。出现在其它层就不可能达成平衡。    </p>    <p>    2. 非叶子结点的度（结点拥有的子树数目称为结点的度）一定是2。    </p>    <p>    3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。     </p></blockquote><h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h3><img src="https://telegraph-image-9wl.pages.dev/file/a6db59cb75a2d03165d5b.png" alt="图4" style="zoom:125%;" /><blockquote><p>​一颗具有n个结点的二叉树按层编号（按从上至下、从左到右的顺序进行编号），编号为i(1&lt;&#x3D;i&lt;&#x3D;n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。<font title="red">完全二叉树是满二叉树的子集。</font></p></blockquote><blockquote alt="info">    <p>    1.叶子结点只能出现在最下层和次下层。    </p>    <p>    2.最下层的叶子结点集中在树的左部。    </p>    <p>    3.倒数第二层若存在叶子结点，一定在右部连续位置。     </p>    <p>    4.如果结点度为1，则该结点只有左子节点，没有右子节点     </p>    <p>    5.同样结点数目的二叉树，完全二叉树深度最小。     </p></blockquote><blockquote alt="danger">    <p>     满二叉树一定是完全二叉树，但反过来不一定成立。    </p></blockquote>## 4. 代码实现### 1. 二叉树节点定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：newKey</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：二叉查找树节点定义</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="comment">//K_TYPE:二叉查找树节点索引;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bstree_node</span>&#123;</span><br><span class="line">    K_TYPE key; <span class="comment">// 指向键的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *left; <span class="comment">// 指向左子节点的指针</span></span><br><span class="line">    bstree_node&lt;K_TYPE&gt; *right; <span class="comment">// 指向右子节点的指针</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">bstree_node</span>(K_TYPE newKey)</span><br><span class="line">        :<span class="built_in">key</span>(newKey)</span><br><span class="line">        ,<span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        ,<span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">bstree_node</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树框架"><a href="#2-二叉树框架" class="headerlink" title="2. 二叉树框架"></a>2. 二叉树框架</h3><h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h3><blockquote><p>普通插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNode</span>(<span class="type">const</span> K_TYPE &amp;key)&#123;</span><br><span class="line">    <span class="comment">//1. 空树时，直接插入</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//2. 遍历找到插入的位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//cur-&gt;key == key 时，BSTree不允许重复值，插入失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 在当前parent位置插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(parent-&gt;key &gt; key )&#123;<span class="comment">//插在左边</span></span><br><span class="line">        parent-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插在右边</span></span><br><span class="line">        parent-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 节点值</span></span><br><span class="line"><span class="comment">*返回值：是否插入成功</span></span><br><span class="line"><span class="comment">*功能：插入节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">insertNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//递归插入</span></span><br><span class="line">    _insertR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_insertR(BSTree::Node* &amp;node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;<span class="comment">//1. base case 当前节点为base case，表示可以插入</span></span><br><span class="line">        node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点非空，继续递归寻找插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;key &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;right,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> _insertR(node-&gt;left,key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//node-&gt;key == key时，BSTree不允许重复值，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-中序遍历"><a href="#4-中序遍历" class="headerlink" title="4. 中序遍历"></a>4. 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：无</span></span><br><span class="line"><span class="comment">*功能：中序遍历</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">inOrder</span>()&#123;</span><br><span class="line">    _inOrder(_root);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历完成。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">void</span> BSTree&lt;K_TYPE&gt;::_inOrder(Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _inOrder(node-&gt;left);</span><br><span class="line">    cout&lt;&lt;node-&gt;key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    _inOrder(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-查找"><a href="#5-查找" class="headerlink" title="5. 查找"></a>5. 查找</h3><blockquote><p>普通查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点为key</span></span><br><span class="line">    <span class="keyword">if</span>(key == _root-&gt;key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历二叉树，查找</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//此时cur-&gt;key == key</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归查找</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待查找节点值</span></span><br><span class="line"><span class="comment">*返回值：true 找到，false 未找到</span></span><br><span class="line"><span class="comment">*功能：查找key节点----递归</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">findNodeR</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="keyword">return</span> _findR(_root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::_findR(BSTree::Node *node, <span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key == key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//2.递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key &gt; key)&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _findR(node-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-删除"><a href="#6-删除" class="headerlink" title="6. 删除"></a>6. 删除</h3><blockquote><p>普通删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：key 待删除节点值</span></span><br><span class="line"><span class="comment">*返回值：true 成功删除，false 未找到节点，删除失败</span></span><br><span class="line"><span class="comment">*功能：删除key节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">deleteNode</span>(<span class="type">const</span> K_TYPE &amp;key) &#123;</span><br><span class="line">    <span class="comment">//1.根节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(_root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根节点不为空，遍历找到带删除节点位置</span></span><br><span class="line">    Node* cur = _root;</span><br><span class="line">    Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//3.单独讨论只有根节点情况</span></span><br><span class="line">    <span class="keyword">if</span>(_root-&gt;key == key &amp;&amp; _root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; _root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历树</span></span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;key &gt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;key &lt; key)&#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//4.找到删除节点位置，分情况删除节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> )&#123;</span><br><span class="line">                <span class="comment">//1. 左子树、右子树都为空时，叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;left == cur)&#123;</span><br><span class="line">                    parent-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parent-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//2.左子树为空，右子树不为空</span></span><br><span class="line">                <span class="comment">//或者. 左子树、右子树都不为空时</span></span><br><span class="line">                Node* cur_left = cur-&gt;right;</span><br><span class="line">                Node* parent_left = cur;</span><br><span class="line">                <span class="comment">//遍历找到右子树中最小值</span></span><br><span class="line">                <span class="keyword">while</span> (cur_left &amp;&amp; cur_left-&gt;left) &#123;</span><br><span class="line">                    parent_left = cur_left;</span><br><span class="line">                    cur_left = cur_left-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                    <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;right;</span><br><span class="line">                    <span class="comment">//左子树、右子树都不为空时</span></span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                        _root-&gt;left = cur-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_left-&gt;key;</span><br><span class="line">                    parent_left-&gt;right = cur_left-&gt;right;</span><br><span class="line">                    <span class="keyword">delete</span> cur_left;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//3.右子树为空，左子树不为空</span></span><br><span class="line">                Node* cur_right = cur-&gt;left;</span><br><span class="line">                Node* parent_right = cur;</span><br><span class="line">                <span class="comment">//遍历找到左子树中最大值</span></span><br><span class="line">                <span class="keyword">while</span>(cur_right &amp;&amp; cur_right-&gt;right)&#123;</span><br><span class="line">                    parent_right = cur_right;</span><br><span class="line">                    cur_right = cur_right-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur == _root)&#123;</span><br><span class="line">                      <span class="comment">//待删除节点为根节点时</span></span><br><span class="line">                    _root = _root-&gt;left;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">delete</span> cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//用值替换方法删除节点</span></span><br><span class="line">                    cur-&gt;key = cur_right-&gt;key;</span><br><span class="line">                    parent_right-&gt;left = cur_right-&gt;left;</span><br><span class="line">                    <span class="keyword">delete</span> cur_right;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归删除</p></blockquote><p>​在遍历树找到删除元素时采用递归的方式。</p><h3 id="7-深拷贝"><a href="#7-深拷贝" class="headerlink" title="7. 深拷贝"></a>7. 深拷贝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BSTree</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造</span></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K_TYPE&gt;&amp; t)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_root = <span class="built_in">copyTree</span>(t._root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：复制树的根节点</span></span><br><span class="line"><span class="comment">*返回值：true 成功复制，false 复制失败</span></span><br><span class="line"><span class="comment">*功能：复制另一个树，返回另一个树的头节点</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line">bstree_node&lt;K_TYPE&gt;* BSTree&lt;K_TYPE&gt;::<span class="built_in">copyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bstree_node&lt;K_TYPE&gt;* copyNode = <span class="keyword">new</span> <span class="built_in">bstree_node</span>&lt;K_TYPE&gt;(node-&gt;key);</span><br><span class="line">    copyNode-&gt;left = <span class="built_in">copyTree</span>(node-&gt;left);</span><br><span class="line">    copyNode-&gt;right = <span class="built_in">copyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> copyNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-析构"><a href="#8-析构" class="headerlink" title="8. 析构"></a>8. 析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">destroyTree</span><span class="params">(<span class="type">const</span> Node* node)</span></span>;<span class="comment">//销毁树</span></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">BSTree</span>()&#123;</span><br><span class="line">    <span class="built_in">destroyTree</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">*参数：无</span></span><br><span class="line"><span class="comment">*返回值：true 成功销毁，false 销毁失败</span></span><br><span class="line"><span class="comment">*功能：销毁一棵树</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K_TYPE&gt;</span><br><span class="line"><span class="type">bool</span> BSTree&lt;K_TYPE&gt;::<span class="built_in">destroyTree</span>(<span class="type">const</span> Node* node)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">destroyTree</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bstree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">78</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">insertNodeR</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    BSTree&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">    t1._root = t1.<span class="built_in">copyTree</span>(t._root);</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:a)&#123;</span><br><span class="line">        t.<span class="built_in">deleteNode</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">inOrder</span>();</span><br><span class="line">    t1.<span class="built_in">inOrder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/a2076188013/article/details/126515470">参考文章：详解二叉搜索树【C++实现】</a></p><p><a href="https://blog.csdn.net/weixin_43274704/article/details/115793265">参考文章：深度解析红黑树</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题套路</title>
      <link href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/"/>
      <url>/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h2><blockquote><p>动态规划的核心是<font title="red">穷举</font>。</p></blockquote><blockquote><p>递归算法的时间复杂度：<font title="red">子问题个数 X 一个子问题需要时间</font>。</p></blockquote><h3 id="1-总体套路"><a href="#1-总体套路" class="headerlink" title="1. 总体套路"></a>1. 总体套路</h3><blockquote alt="info"><p> 1. 明确 base case ----> 2. 明确 "状态" ----> 3. 明确 "选择" ----> 4. 定义 dp 数组 / 函数的含义</p></blockquote><blockquote alt="warn"><p> 可优化问题：<font title="red">最优子结构 、 重叠子问题</font></p></blockquote><blockquote alt="success"><p> 解决方法：<font title="red">备忘录 、 DP table</font></p></blockquote><h3 id="2-自顶向下递归"><a href="#2-自顶向下递归" class="headerlink" title="2. 自顶向下递归"></a>2. 自顶向下递归</h3><blockquote alt="danger"><p>递归套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(状态<span class="number">1</span>,状态<span class="number">2</span>,...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 选择:所有可能的选择)&#123;</span><br><span class="line"><span class="comment">//此时的状态可能因为做了选择而改变</span></span><br><span class="line">        <span class="keyword">auto</span> result = 求最值(result, <span class="built_in">dp</span>(状态<span class="number">1</span>,状态<span class="number">2</span>,...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自顶向下递归</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">memo</span>(n+<span class="number">1</span>);<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自底向上迭代"><a href="#3-自底向上迭代" class="headerlink" title="3. 自底向上迭代"></a>3. 自底向上迭代</h3><blockquote alt="danger"><p>迭代套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="comment">//初始化 base case</span></span><br><span class="line"><span class="keyword">auto</span> dp[<span class="number">0</span>][<span class="number">0</span>][...] = base_case;</span><br><span class="line"><span class="comment">//进行状态转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">1</span>:状态<span class="number">1</span>的所有取值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">2</span>:状态<span class="number">2</span>的所有取值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...<span class="comment">/*省略所有状态*/</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历所有状态，求最值</span></span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>,选择<span class="number">2.</span>..);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自底向上迭代</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2. 代码优化"></a>2. 代码优化</h2><h3 id="1-重叠子问题"><a href="#1-重叠子问题" class="headerlink" title="1. 重叠子问题"></a>1. 重叠子问题</h3><blockquote><p>递归子树中，存在大量重复分支。</p></blockquote><p>​斐波那契数列，若采用暴力递归，则会产生大量重复分支，该方法时间负责度为$O(2^n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列暴力递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/b8be642671ddeb0b8a004.jpg" style="zoom:50%"><p>​上图为暴力递归的&#x3D;&#x3D;递归树&#x3D;&#x3D;，可以发现，存在&#x3D;&#x3D;大量重复分支&#x3D;&#x3D;，使用&#x3D;&#x3D;备忘录&#x3D;&#x3D;可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> memo[n+<span class="number">1</span>];<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/2.jpg" style="zoom:50%;"><p>​上图为&#x3D;&#x3D;带备忘录递归&#x3D;&#x3D;的递归树，少了许多重复分支的计算，同样使用&#x3D;&#x3D;DP table&#x3D;&#x3D;也能解决这个问题。</p><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/4.jpg" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-优化DP-table-空间"><a href="#2-优化DP-table-空间" class="headerlink" title="2. 优化DP table 空间"></a>2. 优化DP table 空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 空间负责度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​     上述代码空间负责度$O(n)$，实际上很多空间都是冗余的，只需要dp[i-1]和dp[i-2]即可，优化后空间负责度$O(1)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 优化后，空间负责度O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp_i_1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp_i_2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> dp = dp_i_1 + dp_i_2;</span><br><span class="line">        dp_i_1 = dp_i_2;</span><br><span class="line">        dp_i_2 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br></pre></td></tr></table></figure><h2 id="3-应用—-凑硬币"><a href="#3-应用—-凑硬币" class="headerlink" title="3. 应用—-凑硬币"></a>3. 应用—-凑硬币</h2><blockquote><p>​给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p></blockquote><h3 id="1-总体思路"><a href="#1-总体思路" class="headerlink" title="1. 总体思路"></a>1. 总体思路</h3><ol><li>&#x3D;&#x3D;base case&#x3D;&#x3D;  当总金额 amount &lt; 0 时，返回 -1，amount &#x3D;&#x3D; 0时，返回 0 。</li><li>&#x3D;&#x3D;明确状态&#x3D;&#x3D; amount 大小发生变化。</li><li>&#x3D;&#x3D;明确选择&#x3D;&#x3D; 选择硬币。</li><li>&#x3D;&#x3D;明确 dp 函数&#x2F;数组的定义&#x3D;&#x3D; dp输入金额n和数组coins，返回所需最少的硬币个数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> subres = <span class="built_in">coinChange</span>(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span>(subres == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//subres + 1 表示子树最少硬币数+当前硬币</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, subres+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==INT_MAX?<span class="number">-1</span>:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-备忘录优化-—-递归案例"><a href="#2-备忘录优化-—-递归案例" class="headerlink" title="2. 备忘录优化 —- 递归案例"></a>2. 备忘录优化 —- 递归案例</h3><blockquote><p>使用memo，记录 memo[amount] &#x3D; 硬币数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义memo</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化memo，INT_MAX表示memo中没有记录</span></span><br><span class="line">        memo = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case </span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="comment">//备忘录使用</span></span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> subres = <span class="built_in">dp</span>(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (subres == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">min</span>(result, subres + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = result == INT_MAX ? <span class="number">-1</span> : result;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-DP-table-迭代-—-迭代案例"><a href="#3-DP-table-迭代-—-迭代案例" class="headerlink" title="3. DP table 迭代 —- 迭代案例"></a>3. DP table 迭代 —- 迭代案例</h3><blockquote><p>dp 数组的定义：当目标金额为 i  时，至少需要  dp[i] 枚硬币凑出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins)&#123;</span><br><span class="line">            <span class="comment">//coin &gt; i ，硬币 &gt; 总金额，不能凑</span></span><br><span class="line">            <span class="keyword">if</span>(coin&gt;i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转移</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == (amount+<span class="number">1</span>)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/6.jpg" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> labuladong的算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong的算法笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><blockquote><p>红黑树的用途：</p></blockquote><ol><li>Key–Value 查找。</li><li>顺序。</li></ol><blockquote><p>强查找时所用数据结构：</p></blockquote><ul><li><p>rbtree</p></li><li><p>hash</p></li><li><p>b&#x2F;b+ tree</p></li><li><p>跳表</p></li></ul><h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h2><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的</li><li>对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点</li></ol><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="1-红黑树定义"><a href="#1-红黑树定义" class="headerlink" title="1. 红黑树定义"></a>1. 红黑树定义</h3><blockquote><p>节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    KEY_TYPE *key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *parent;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//红黑树颜色</span></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote><p>头节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *nil;<span class="comment">//红黑树都指向一个黑色的叶子节点</span></span><br><span class="line">&#125;rbtree;</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>节点存在问题--------无法复用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义 红黑树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name, type) \</span></span><br><span class="line"><span class="meta">struct name&#123;\</span></span><br><span class="line"><span class="meta">        struct type *left;\</span></span><br><span class="line"><span class="meta">        struct type *right;\</span></span><br><span class="line"><span class="meta">        struct type *parent;\</span></span><br><span class="line"><span class="meta">    unsigned char color;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) node;<span class="comment">//第一个参数为空，表示未命名数据结构</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote alt="success"><p>线程复用<br>一个线程有多个状态：ready、wait、sleep和exit。这些状态都用红黑树实现，因此一个线程需要定义多棵红黑树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) ready;<span class="comment">//上面宏定义的红黑树结构</span></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) wait;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) sleep;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-红黑树的旋转"><a href="#2-红黑树的旋转" class="headerlink" title="2. 红黑树的旋转"></a>2. 红黑树的旋转</h3><blockquote><p>红黑树性质被破坏时（插入新值），进行旋转。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/d61ddf9e7566966d5ac0f.png" style="zoom:50%"><blockquote alt="info"><p>当前的结点是右子树，<font title="red">左旋</font></p></blockquote><p>​node 与父节点交换位置，node 的左子树为父节点，右子树不变。原父节点的左子树不变，右子树为node的左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="comment">//参数：头节点、左旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T-&gt;nil)&#123;<span class="comment">//叶子节点不能左旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *y = x-&gt;right;</span><br><span class="line">    <span class="comment">//交换x的右边和y的左边</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != T-&gt;nil)&#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>当前的结点是左子树，<font title="red">右旋</font></p></blockquote><p>​node 与父节点交换位置，node 的右子树为父节点，左子树不变。原父节点的右子树不变，左子树为node的右子树。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="comment">//参数：头节点、右旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T,rbtree_node *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;<span class="comment">//叶子节点不能右旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">    <span class="comment">//交换y的左边和x的右边</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right != T-&gt;nil)&#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;right)&#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-红黑树的插入"><a href="#3-红黑树的插入" class="headerlink" title="3. 红黑树的插入"></a>3. 红黑树的插入</h3><blockquote><p>插入节点始终红色，根据红黑树性质（判断父亲是否为红色）调整。</p></blockquote><blockquote alt="warn"><p>难点：红色树变色</p></blockquote><blockquote alt="info"><p>    父结点是祖父结点的左子树的情况和右子树情况<font title="red">对称</font>。下面只讨论左子树的三种情况    </p></blockquote><blockquote alt="success"><p>    1. 叔结点是红色的</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ed316a0b512e2382f0b88.png" style="zoom:50%;"><blockquote alt="success"><p>2.叔结点是黑色的，而且当前结点是<font title="red">右孩子</font>。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/9bccd3f7205a1603ac0c8.png" style="zoom:50%;"><blockquote alt="success"><p >3.叔结点是黑色的，而且当前结点是<font title="red">左孩子</font>。   </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/37934bf2d30f32e280afe.png" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="comment">//红黑树插入节点</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;<span class="comment">//从根节点遍历</span></span><br><span class="line">    <span class="comment">//遍历到应该插入z的位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != T-&gt;nil)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//z-&gt;key == x-&gt;key情况，根据业务变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将z插入到红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key )&#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="comment">//z节点染红色</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    <span class="comment">//调整红黑树颜色</span></span><br><span class="line">    <span class="built_in">rbtree_insert_fixup</span>(T,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树颜色调整</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;parent-&gt;color != RED)&#123;<span class="comment">//z节点始终为红色</span></span><br><span class="line">        <span class="comment">//z插入在祖父的左子树时</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)&#123;</span><br><span class="line">            rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;right-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_left_rotate</span>(T,p);<span class="comment">//左旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_right_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//z插入在祖父的右子树时</span></span><br><span class="line">             rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;left-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_right_rotate</span>(T,p);<span class="comment">//右旋</span></span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_left_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 邮件 icon 点击 404</title>
      <link href="/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/"/>
      <url>/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>​在主页面中，点击 icon 的邮件后报错 404 。</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/1a47e264cd5492892b9d5.png" style="zoom:50%;"><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​_config.yml 文件中添加&#x3D;&#x3D;mailto:example:email.com&#x3D;&#x3D;。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/e5eafe32fdf1d570f74cd.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上iCloud下载慢</title>
      <link href="/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h1><blockquote><p>​Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。</p></blockquote><h1 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h1><blockquote><p>​设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
