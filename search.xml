<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划解题套路</title>
      <link href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/"/>
      <url>/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>##框架</p><blockquote><p>动态规划的核心是<font title="red">穷举</font>。</p></blockquote><blockquote><p>递归算法的时间复杂度：<font title="red">子问题个数 X 一个子问题需要时间</font>。</p></blockquote><h3 id="总体套路"><a href="#总体套路" class="headerlink" title="总体套路"></a>总体套路</h3><blockquote alt="info"><p> 1. 明确 base case ----> 2. 明确 "状态" ----> 3. 明确 "选择" ----> 4. 定义 dp 数组 / 函数的含义</p></blockquote><blockquote alt="warn"><p> 可优化问题：<font title="red">最优子结构 、 重叠子问题</font></p></blockquote><blockquote alt="success"><p> 解决方法：<font title="red">备忘录 、 DP table</font></p></blockquote><h3 id="自顶向下递归"><a href="#自顶向下递归" class="headerlink" title="自顶向下递归"></a>自顶向下递归</h3><blockquote alt="danger"><p>递归套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(状态<span class="number">1</span>,状态<span class="number">2</span>,...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 选择:所有可能的选择)&#123;</span><br><span class="line"><span class="comment">//此时的状态可能因为做了选择而改变</span></span><br><span class="line">        <span class="keyword">auto</span> result = 求最值(result, <span class="built_in">dp</span>(状态<span class="number">1</span>,状态<span class="number">2</span>,...));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自顶向下递归</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">memo</span>(n+<span class="number">1</span>);<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上迭代"><a href="#自底向上迭代" class="headerlink" title="自底向上迭代"></a>自底向上迭代</h3><blockquote alt="danger"><p>迭代套路</font></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套路</span></span><br><span class="line"><span class="comment">//初始化 base case</span></span><br><span class="line"><span class="keyword">auto</span> dp[<span class="number">0</span>][<span class="number">0</span>][...] = base_case;</span><br><span class="line"><span class="comment">//进行状态转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">1</span>:状态<span class="number">1</span>的所有取值)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> 状态<span class="number">2</span>:状态<span class="number">2</span>的所有取值)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...<span class="comment">/*省略所有状态*/</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历所有状态，求最值</span></span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>,选择<span class="number">2.</span>..);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>斐波那契数列—-自底向上迭代</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><blockquote><p>递归子树中，存在大量重复分支。</p></blockquote><p>​斐波那契数列，若采用暴力递归，则会产生大量重复分支，该方法时间负责度为$O(2^n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列暴力递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://telegraph-image-9wl.pages.dev/file/b8be642671ddeb0b8a004.jpg" style="zoom:50%"><p>​上图为暴力递归的&#x3D;&#x3D;递归树&#x3D;&#x3D;，可以发现，存在&#x3D;&#x3D;大量重复分支&#x3D;&#x3D;，使用&#x3D;&#x3D;备忘录&#x3D;&#x3D;可以解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带&quot;备忘录&quot;的递归解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> memo[n+<span class="number">1</span>];<span class="comment">//memo初始化全为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(memo,n);<span class="comment">//带memo的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> memo[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. base case</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n== <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. memo中是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(memo[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 计算本次结果</span></span><br><span class="line">    memo[n] = <span class="built_in">helper</span>(memo,n<span class="number">-1</span>) +<span class="built_in">helper</span>(memo,n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/2.jpg" style="zoom:50%;"><p>​上图为&#x3D;&#x3D;带备忘录递归&#x3D;&#x3D;的递归树，少了许多重复分支的计算，同样使用&#x3D;&#x3D;DP table&#x3D;&#x3D;也能解决这个问题。</p><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/4.jpg" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化DP-table-空间"><a href="#优化DP-table-空间" class="headerlink" title="优化DP table 空间"></a>优化DP table 空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 空间负责度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n )</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移方程</span></span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>​     上述代码空间负责度$O(n)$，实际上很多空间都是冗余的，只需要dp[i-1]和dp[i-2]即可，优化后空间负责度$O(1)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP table 优化后，空间负责度O(1)</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> dp_i_1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp_i_2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> dp = dp_i_1 + dp_i_2;</span><br><span class="line">        dp_i_1 = dp_i_2;</span><br><span class="line">        dp_i_2 = dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br></pre></td></tr></table></figure><h2 id="应用—-凑硬币"><a href="#应用—-凑硬币" class="headerlink" title="应用—-凑硬币"></a>应用—-凑硬币</h2><blockquote><p>​给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。</p></blockquote><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><ol><li>&#x3D;&#x3D;base case&#x3D;&#x3D;  当总金额 amount &lt; 0 时，返回 -1，amount &#x3D;&#x3D; 0时，返回 0 。</li><li>&#x3D;&#x3D;明确状态&#x3D;&#x3D; amount 大小发生变化。</li><li>&#x3D;&#x3D;明确选择&#x3D;&#x3D; 选择硬币。</li><li>&#x3D;&#x3D;明确 dp 函数&#x2F;数组的定义&#x3D;&#x3D; dp输入金额n和数组coins，返回所需最少的硬币个数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> result = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">        <span class="type">int</span> subres = <span class="built_in">coinChange</span>(coins, amount - coin);</span><br><span class="line">        <span class="keyword">if</span>(subres == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//subres + 1 表示子树最少硬币数+当前硬币</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, subres+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result==INT_MAX?<span class="number">-1</span>:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备忘录优化-—-递归案例"><a href="#备忘录优化-—-递归案例" class="headerlink" title="备忘录优化 —- 递归案例"></a>备忘录优化 —- 递归案例</h3><blockquote><p>使用memo，记录 memo[amount] &#x3D; 硬币数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义memo</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化memo，INT_MAX表示memo中没有记录</span></span><br><span class="line">        memo = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amount + <span class="number">1</span>, INT_MAX);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base case </span></span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="comment">//备忘录使用</span></span><br><span class="line">        <span class="keyword">if</span> (memo[amount] != INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> memo[amount];</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> coin : coins) &#123;</span><br><span class="line">            <span class="type">int</span> subres = <span class="built_in">dp</span>(coins, amount - coin);</span><br><span class="line">            <span class="keyword">if</span> (subres == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">min</span>(result, subres + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[amount] = result == INT_MAX ? <span class="number">-1</span> : result;</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="DP-table-迭代-—-迭代案例"><a href="#DP-table-迭代-—-迭代案例" class="headerlink" title="DP table 迭代 —- 迭代案例"></a>DP table 迭代 —- 迭代案例</h3><blockquote><p>dp 数组的定义：当目标金额为 i  时，至少需要  dp[i] 枚硬币凑出。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//遍历所有选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> coin:coins)&#123;</span><br><span class="line">            <span class="comment">//coin &gt; i ，硬币 &gt; 总金额，不能凑</span></span><br><span class="line">            <span class="keyword">if</span>(coin&gt;i)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转移</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == (amount+<span class="number">1</span>)?<span class="number">-1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/动态规划详解进阶/6.jpg" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> labuladong的算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labuladong的算法笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树与红黑树</title>
      <link href="/2024/01/27/C-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2024/01/27/C-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>红黑树的用途：</p></blockquote><ol><li>Key–Value 查找。</li><li>顺序。</li></ol><blockquote><p>强查找时所用数据结构：</p></blockquote><ul><li><p>rbtree</p></li><li><p>hash</p></li><li><p>b&#x2F;b+ tree</p></li><li><p>跳表</p></li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的</li><li>对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="红黑树定义"><a href="#红黑树定义" class="headerlink" title="红黑树定义"></a>红黑树定义</h3><blockquote><p>节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *right;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *parent;</span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color;<span class="comment">//红黑树颜色</span></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote><p>头节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *root;<span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span> *nil;<span class="comment">//红黑树都指向一个黑色的叶子节点</span></span><br><span class="line">&#125;rbtree;</span><br></pre></td></tr></table></figure><blockquote alt="warn"><p>节点存在问题--------无法复用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义 红黑树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBTREE_ENTRY(name, type) \</span></span><br><span class="line"><span class="meta">struct name&#123;\</span></span><br><span class="line"><span class="meta">        struct type *left;\</span></span><br><span class="line"><span class="meta">        struct type *right;\</span></span><br><span class="line"><span class="meta">        struct type *parent;\</span></span><br><span class="line"><span class="meta">    unsigned char color;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_rbtree_node</span>&#123;</span><br><span class="line">    <span class="type">int</span> KEY_TYPE;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) node;<span class="comment">//第一个参数为空，表示未命名数据结构</span></span><br><span class="line"></span><br><span class="line">&#125;rbtree_node;</span><br></pre></td></tr></table></figure><blockquote alt="success"><p>线程复用<br>一个线程有多个状态：ready、wait、sleep和exit。这些状态都用红黑树实现，因此一个线程需要定义多棵红黑树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KEY_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">thread</span>&#123;</span><br><span class="line">    KEY_TYPE key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) ready;<span class="comment">//上面宏定义的红黑树结构</span></span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) wait;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) sleep;</span><br><span class="line">    <span class="built_in">RBTREE_ENTRY</span>(,_rbtree_node) exit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h3><blockquote><p>红黑树性质被破坏时（插入新值），进行旋转。</p></blockquote><img src = "https://telegraph-image-9wl.pages.dev/file/d61ddf9e7566966d5ac0f.png" style="zoom:50%"><blockquote alt="info"><p>当前的结点是右子树，<font title="red">左旋</font></p></blockquote><p>​node 与父节点交换位置，node 的左子树为父节点，右子树不变。原父节点的左子树不变，右子树为node的左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="comment">//参数：头节点、左旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_left_rotate</span><span class="params">(rbtree *T,rbtree_node *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == T-&gt;nil)&#123;<span class="comment">//叶子节点不能左旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *y = x-&gt;right;</span><br><span class="line">    <span class="comment">//交换x的右边和y的左边</span></span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left != T-&gt;nil)&#123;</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)&#123;</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote alt="info"><p>当前的结点是左子树，<font title="red">右旋</font></p></blockquote><p>​node 与父节点交换位置，node 的右子树为父节点，左子树不变。原父节点的右子树不变，左子树为node的右子树。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="comment">//参数：头节点、右旋节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(rbtree *T,rbtree_node *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;<span class="comment">//叶子节点不能右旋</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">    <span class="comment">//交换y的左边和x的右边</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right != T-&gt;nil)&#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，判断父节点状态</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;right)&#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换x和y，x的父节点</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><blockquote><p>插入节点始终红色，根据红黑树性质（判断父亲是否为红色）调整。</p></blockquote><blockquote alt="warn"><p>难点：红色树变色</p></blockquote><blockquote alt="info"><p>    父结点是祖父结点的左子树的情况和右子树情况<font title="red">对称</font>。下面只讨论左子树的三种情况    </p></blockquote><blockquote alt="success"><p>    1. 叔结点是红色的</p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/ed316a0b512e2382f0b88.png" style="zoom:50%;"><blockquote alt="success"><p>2.叔结点是黑色的，而且当前结点是<font title="red">右孩子</font>。    </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/9bccd3f7205a1603ac0c8.png" style="zoom:50%;"><blockquote alt="success"><p >3.叔结点是黑色的，而且当前结点是<font title="red">左孩子</font>。   </p></blockquote><img src="https://telegraph-image-9wl.pages.dev/file/37934bf2d30f32e280afe.png" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK 1</span></span><br><span class="line"><span class="comment">//红黑树插入节点</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    rbtree_node *y = T-&gt;nil;</span><br><span class="line">    rbtree_node *x = T-&gt;root;<span class="comment">//从根节点遍历</span></span><br><span class="line">    <span class="comment">//遍历到应该插入z的位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != T-&gt;nil)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &gt; x-&gt;key)&#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//z-&gt;key == x-&gt;key情况，根据业务变化</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将z插入到红黑树中</span></span><br><span class="line">    <span class="keyword">if</span>(y == T-&gt;nil)&#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key )&#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="comment">//z节点染红色</span></span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;nil;</span><br><span class="line">    z-&gt;right = T-&gt;nil;</span><br><span class="line">    <span class="comment">//调整红黑树颜色</span></span><br><span class="line">    <span class="built_in">rbtree_insert_fixup</span>(T,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树颜色调整</span></span><br><span class="line"><span class="comment">//参数：头节点T、插入节点z</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbtree_insert_fixup</span><span class="params">(rbtree *T,rbtree_node *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;parent-&gt;color != RED)&#123;<span class="comment">//z节点始终为红色</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)&#123;<span class="comment">//z插入在祖父的左子树时</span></span><br><span class="line">            rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;right-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_left_rotate</span>(T,p);<span class="comment">//左旋</span></span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_right_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//z插入在祖父的右子树时</span></span><br><span class="line">             rbtree_node *p = z-&gt;parent;<span class="comment">//z的parent节点p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;parent-&gt;left-&gt;color == RED)&#123;<span class="comment">//z的叔父节点RED</span></span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                z = p-&gt;parent;<span class="comment">//回溯红黑树</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//z的叔父节点BLACK</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left == z)&#123;<span class="comment">//z在父节点的右子树时</span></span><br><span class="line">                    <span class="built_in">rbtree_right_rotate</span>(T,p);<span class="comment">//右旋</span></span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                    z = p;<span class="comment">//让左旋转后z为子节点，而非父节点</span></span><br><span class="line">                    p = z-&gt;parent;</span><br><span class="line">                    <span class="comment">//---------------------有问题？---------------------</span></span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;color = BLACK;</span><br><span class="line">                p-&gt;parent-&gt;color = RED;</span><br><span class="line">                <span class="built_in">rbtree_left_rotate</span>(T,p-&gt;parent);<span class="comment">//右旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 零声Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 邮件 icon 点击 404</title>
      <link href="/2024/01/26/Bug-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/"/>
      <url>/2024/01/26/Bug-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-主题-icon-点击后404"><a href="#Hexo-主题-icon-点击后404" class="headerlink" title="Hexo 主题 icon 点击后404"></a>Hexo 主题 icon 点击后404</h1><p>​在主页面中，点击 icon 的邮件后报错 404 。</p><p>#@Q#</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>​_config.yml 文件中添加  <code> mailto:example:email.com</code>。</p><img src = "https://telegraph-image-9wl.pages.dev/file/e5eafe32fdf1d570f74cd.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上iCloud下载慢</title>
      <link href="/2024/01/26/Bug-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2024/01/26/Bug-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-上-iCloud-下载慢"><a href="#Mac-上-iCloud-下载慢" class="headerlink" title="Mac 上 iCloud 下载慢"></a>Mac 上 iCloud 下载慢</h1><p>​Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>​设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据页结构</title>
      <link href="/2024/01/21/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/2024/01/21/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93-5-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h1><p>​数据页大小一般为 16KB。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102144698-9e521ae2-6223-4468-8da7-8b5e3f1f78fe.png#averageHue=%23d19e41&clientId=ue4f6f3bf-827e-4&from=paste&height=313&id=ua85ac9a2&originHeight=783&originWidth=750&originalType=binary&ratio=2&rotation=0&showTitle=false&size=155926&status=done&style=none&taskId=u247d4e71-80b0-4d18-9eb3-0f669c7bd95&title=&width=300" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102221586-ae8ddd99-7c69-422f-8d8b-1086284b4335.png#averageHue=%23e7e1d9&clientId=ue4f6f3bf-827e-4&from=paste&height=300&id=u870f67bf&originHeight=351&originWidth=819&originalType=binary&ratio=2&rotation=0&showTitle=false&size=169389&status=done&style=none&taskId=uafdc73c5-0a02-4efe-9935-ef6e3c922ce&title=&width=700" alt="image.png">w</p><h1 id="单条记录的记录头"><a href="#单条记录的记录头" class="headerlink" title="单条记录的记录头"></a>单条记录的记录头</h1><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102317982-874c714b-7f6f-451b-b915-6fbc5a4d90d2.png#averageHue=%23fbf7f4&clientId=ue4f6f3bf-827e-4&from=paste&height=311&id=u58e923b7&originHeight=466&originWidth=1049&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82907&status=done&style=none&taskId=ucc852ef6-cc44-4fbf-a9aa-5841b577b3b&title=&width=700" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700102345795-f9ff820b-0b94-485e-83f5-aaf53484d64a.png#averageHue=%23f9f9f8&clientId=ue4f6f3bf-827e-4&from=paste&height=275&id=u11bfcf24&originHeight=442&originWidth=1126&originalType=binary&ratio=2&rotation=0&showTitle=false&size=101276&status=done&style=none&taskId=u9b29b8f0-bb7a-4c43-815e-291fd67c309&title=&width=700" alt="image.png"></p><h3 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h3><p>标记该记录是否被删除<strong>。</strong>1 &#x3D; 删除。被删除的记录<strong>不是立即从磁盘移除</strong>，因为重新排列新顺序<strong>需要性能消耗。</strong>被删掉的记录会组成<strong>垃圾链表</strong>，这些链表组成空间叫做<strong>可重用空间</strong>，之后<strong>新数据可插入到这</strong>。<br>删除的过程如下：</p><ul><li>delete_mask 值设 0。</li><li>next_record 值设 0。</li><li>被删除记录的<strong>上一条指向下一条</strong>。</li><li><strong>最大记录</strong>的 n_owned 值减 1。</li></ul><h3 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h3><p>B+树的每层<strong>非叶子节点</strong>中的<strong>最小记录</strong>都会添加该标记。</p><h3 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h3><p>该组内有多少条记录，每个组的<strong>最后一条记录</strong>中存在（组内最大）。<br>Page Directory 中的<strong>槽</strong>指向每组中的最后一条记录，这条记录中有 n_owned。</p><h3 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h3><p>当前记录在<strong>本页的位置。</strong><br><strong>heap_no &#x3D;&#x3D; 0 or 1 <strong>分别表示</strong>最小记录和最大记录</strong>（也称为<strong>伪记录或虚拟记录</strong>）（记录比较大小即比较<strong>主键的大小</strong>），固定大小** 5B 记录头+8B 数据。<strong>其中最小记录数据为 <strong>infimum</strong> ，最大记录数据为 <strong>supremum</strong>。<br>最小记录和最大记录</strong>不存放<strong>在 User Records 部分，</strong>单独放在** Infimum+Supremum 部分。<br>infimum 指比本页中任何记录都要小，supremum 指本页中比任何记录都要大。<br>通过** infimum 和 supremum **对应的两个槽（Page Directory 中），找到一页中的最小值和最大值（infimum 位置 + 1 为最小值，supremum 位置 - 1 为最大值）。</p><h3 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h3><p>记录当前记录类型，0 &#x3D; 普通记录，1 &#x3D; B+树非叶节点，2 &#x3D; 最小记录 Infimum，3 &#x3D; 最大记录 Supremum。</p><h3 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h3><p>从当前记录的真实数据到下一条记录真实数据的偏移量。即 <strong>记录 1 + next_record &#x3D; 记录 2</strong>，本质是一个<strong>链表</strong>，next_record 指向下一条记录。<br>下一条记录指<strong>按照主键值从小到大</strong>的顺序，规定** Infimum 指向主键值最小<strong>的用户记录，</strong>主键值最大的用户数据指向 Supremum<strong>。<br>next_record 指向</strong>真实数据开头<strong>，指向</strong>记录头结尾<strong>（记录头按</strong>逆序**存放）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700103768843-fc6c3973-41f4-47f3-ae4b-3d47e60b2621.png#averageHue=%23f3e0cc&clientId=ue4f6f3bf-827e-4&from=paste&height=350&id=u2eaa8a44&originHeight=487&originWidth=975&originalType=binary&ratio=2&rotation=0&showTitle=false&size=253063&status=done&style=none&taskId=ufb774ede-efbe-42fd-a4b0-f8a3a96de9d&title=&width=700" alt="image.png"></p><h1 id="Page-Directory-页目录"><a href="#Page-Directory-页目录" class="headerlink" title="Page Directory 页目录"></a>Page Directory 页目录</h1><p>为<strong>查找更快</strong>，设置页目录，<strong>大小不确定</strong>。</p><h2 id="页目录制作"><a href="#页目录制作" class="headerlink" title="页目录制作"></a>页目录制作</h2><ol><li>将所有正常记录（含 Infimum 和 Supremum，不含被删除的）划分为<strong>组。</strong></li><li>每个组<strong>最后一条记录（组内最大）</strong> n_owned 表示组有多少条记录。</li><li>将<strong>槽</strong>（<strong>组最后一条记录的地址偏移量</strong>）按顺序放到** Page Directory（页目录） **里。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700104471100-86143d88-e072-4282-8c57-6cb57163c2b6.png#averageHue=%23f8f1ea&clientId=ue4f6f3bf-827e-4&from=paste&height=382&id=ud59dea2a&originHeight=870&originWidth=1596&originalType=binary&ratio=2&rotation=0&showTitle=false&size=235355&status=done&style=none&taskId=u7abb2a50-5076-4634-bbb8-311fb60762e&title=&width=700" alt="image.png"></p><h2 id="分组划分"><a href="#分组划分" class="headerlink" title="分组划分"></a>分组划分</h2><p>划分规则：1）<strong>最小记录</strong>所在组只能有** 1 条<strong>记录。2）</strong>最大记录<strong>所在组含</strong> 1～8 条<strong>。3）</strong>剩下**分组含 <strong>4～8</strong> 条。</p><ol><li>初始页里只有 Infimum 和 Supremum，它们<strong>分属两个分组</strong>。</li><li>插入记录，根据主键值找<strong>比本记录大&amp;&amp;差值最小</strong>的槽。</li><li>该<strong>槽 o_wned 值加 1</strong>，将记录添加到组中。</li><li>当组记录数到 8 时，拆分成两个组，<strong>一个组 4 条，一个组 5 条</strong>。</li><li><strong>新增一个槽</strong>，记录新分组中最大记录偏移量。</li></ol><h2 id="分组查找"><a href="#分组查找" class="headerlink" title="分组查找"></a>分组查找</h2><ol><li>通过<strong>二分法</strong>确定该记录所在槽，并<strong>找到该槽中的最小值</strong>。二分法条件为 high - low &gt; 1 ，因此一般找到的槽为<strong>记录所在槽的前一个</strong>，再 +1 即可找到记录所在槽。</li><li>通过 next_record 属性<strong>遍历</strong>整个槽，找到目标值。</li></ol><h1 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header 页面头部"></a>Page Header 页面头部</h1><p>数据页中存储记录的<strong>状态信息</strong>，<strong>固定 56B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116283402-da81e487-71ae-4f2b-bf42-0ec397d0f1ea.png#averageHue=%23f7f6f5&clientId=ue4f6f3bf-827e-4&from=paste&height=456&id=u98789a28&originHeight=830&originWidth=1273&originalType=binary&ratio=2&rotation=0&showTitle=false&size=286873&status=done&style=none&taskId=u5ab341da-c74f-435a-8da0-0e0e65edeb2&title=&width=700" alt="image.png"></p><h1 id="File-Header-文件头"><a href="#File-Header-文件头" class="headerlink" title="File Header 文件头"></a>File Header 文件头</h1><p>针对<strong>各种页都通用</strong>的信息，<strong>固定 38B</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/21645180/1700116380750-113b6a77-0b8b-4653-8124-337776fc627c.png#averageHue=%23ede9e4&clientId=ue4f6f3bf-827e-4&from=paste&height=303&id=u2f484d54&originHeight=534&originWidth=1234&originalType=binary&ratio=2&rotation=0&showTitle=false&size=272149&status=done&style=none&taskId=ue6837071-eadd-453e-b46c-8a8cad77fba&title=&width=700" alt="image.png"></p><ul><li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT 为指向上一页和下一页的两个链表。（<strong>双向链表</strong>）</li></ul><h1 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h1><p>用于<strong>校验页是否完整</strong>，防止只同步一半的情况发生，<strong>固定 8B</strong>。</p><ul><li>前 4B 表示页的<strong>校验和</strong>。</li><li>后 4B 表示页面最后修改时对应的日志序列位置（<strong>LSN</strong>）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
