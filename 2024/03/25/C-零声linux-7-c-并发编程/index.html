<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++并发编程 | Just花语的博客</title><meta name="author" content="Just花语"><meta name="copyright" content="Just花语"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] C++并发编程c++并发支持库   1. 线程1. thread12345678910111213#include <thread>void func(arg){    ...}std::thread th(func,arg);th.joinable();//线程是否能被join或者detachth.get_id();//获取线程idth.join();">
<meta property="og:type" content="article">
<meta property="og:title" content="C++并发编程">
<meta property="og:url" content="https://justhuayu.github.io/2024/03/25/C-%E9%9B%B6%E5%A3%B0linux-7-c-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Just花语的博客">
<meta property="og:description" content="[TOC] C++并发编程c++并发支持库   1. 线程1. thread12345678910111213#include <thread>void func(arg){    ...}std::thread th(func,arg);th.joinable();//线程是否能被join或者detachth.get_id();//获取线程idth.join();">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://telegraph-image-9wl.pages.dev/file/f665cfdbff34f699fd791.jpg">
<meta property="article:published_time" content="2024-03-25T01:38:00.000Z">
<meta property="article:modified_time" content="2024-03-27T08:57:06.956Z">
<meta property="article:author" content="Just花语">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://telegraph-image-9wl.pages.dev/file/f665cfdbff34f699fd791.jpg"><link rel="shortcut icon" href="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png"><link rel="canonical" href="https://justhuayu.github.io/2024/03/25/C-%E9%9B%B6%E5%A3%B0linux-7-c-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-27 16:57:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://telegraph-image-9wl.pages.dev/file/f665cfdbff34f699fd791.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Just花语的博客"><span class="site-name">Just花语的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-25T01:38:00.000Z" title="发表于 2024-03-25 09:38:00">2024-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://telegraph-image-9wl.pages.dev/file/f665cfdbff34f699fd791.jpg');"></div><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="C-并发编程"><a href="#C-并发编程" class="headerlink" title="C++并发编程"></a>C++并发编程</h1><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread">c++并发支持库</a></p>
<img src="https://telegraph-image-9wl.pages.dev/file/82ca518eed6e220fec4e4.png" alt="image-20240324105819132" style="zoom:63%;">

<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-thread"><a href="#1-thread" class="headerlink" title="1. thread"></a>1. thread</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(arg)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(func,arg)</span></span>;</span><br><span class="line">th.<span class="built_in">joinable</span>();<span class="comment">//线程是否能被join或者detach</span></span><br><span class="line">th.<span class="built_in">get_id</span>();<span class="comment">//获取线程id</span></span><br><span class="line">th.<span class="built_in">join</span>();<span class="comment">//阻塞等待th线程的完成</span></span><br><span class="line">th.<span class="built_in">detach</span>();<span class="comment">//从当前线程分离，独立后台运行</span></span><br><span class="line"><span class="comment">//detach()后不能用join进行同步，只能用其他机制，例如promise，future等进行同步</span></span><br><span class="line"></span><br><span class="line">th.<span class="built_in">swap</span>(th2);<span class="comment">//交换两个thread对象</span></span><br><span class="line">std::<span class="built_in">swap</span>(th,th2)<span class="comment">//可用于重新分配或者管理线程资源</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-jthread"><a href="#2-jthread" class="headerlink" title="2. jthread"></a>2. jthread</h3><ul>
<li>C++20引入，自动的线程管理以及对线程==中断==的支持</li>
<li><code>std::jthread</code> 解决了 <code>std::thread</code> 需要手动调用 <code>join()</code> 或 <code>detach()</code> 来防止资源泄露的问题，并简化了线程的使用，特别是在需要清理资源或请求线程提前结束的情况下。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stop_token&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::stop_token stopToken)</span></span>{</span><br><span class="line">      <span class="comment">// 注册一个停止回调</span></span><br><span class="line">    <span class="function">std::stop_callback <span class="title">callback</span><span class="params">(stopToken, []() {</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">"Cleaning up..."</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 在这里执行必要的清理操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">    })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用while时，将会执行一次，离开作用域时释放资源</span></span><br><span class="line">    <span class="keyword">while</span>(!stopToken.<span class="built_in">stop_requested</span>()){</span><br><span class="line">        ,,,</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">std::jthread <span class="title">jth</span><span class="params">(func)</span></span>;<span class="comment">//不需要join和detach</span></span><br><span class="line"><span class="comment">//当main完成并退出时，jth会自动停止，避免泄漏</span></span><br><span class="line"></span><br><span class="line">jth.<span class="built_in">request_stop</span>();<span class="comment">//外部手动停止</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-this-thread作用域"><a href="#3-this-thread作用域" class="headerlink" title="3. this_thread作用域"></a>3. this_thread作用域</h3><h4 id="1-yield"><a href="#1-yield" class="headerlink" title="1. yield"></a>1. yield</h4><ul>
<li>告诉当前线程向操作系统表明它==愿意放弃其当前的时间片（CPU的执行时间）==，允许其他线程运行</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 提示调度器切换到其他线程</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-get-id"><a href="#2-get-id" class="headerlink" title="2. get_id"></a>2. get_id</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">//获取当前线程id</span></span><br><span class="line">std::thread::id this_id = std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-sleep-for"><a href="#3-sleep-for" class="headerlink" title="3. sleep_for"></a>3. sleep_for</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前线程等待1s</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-sleep-until"><a href="#4-sleep-until" class="headerlink" title="4. sleep_until"></a>4. sleep_until</h4><ul>
<li>阻塞当前线程直到指定的时间点。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 设置一个未来的唤醒时间点，比如从现在开始的5秒后</span></span><br><span class="line"><span class="keyword">auto</span> wakeupTime = now + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 线程休眠直到指定的时间点</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_until</span>(wakeupTime);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-锁和信号量-—-共享资源访问"><a href="#2-锁和信号量-—-共享资源访问" class="headerlink" title="2. 锁和信号量 —- 共享资源访问"></a>2. 锁和信号量 —- 共享资源访问</h2><blockquote>
<p>RALL (Resource Acquisition Is Initialization) 资源获取即初始化风格</p>
</blockquote>
<ol>
<li>获取资源（创建对象）</li>
<li>使用资源</li>
<li>销毁资源（析构对象）</li>
<li>在==析构==时自动销毁，房子内存泄漏。</li>
</ol>
<h3 id="1-6种互斥量"><a href="#1-6种互斥量" class="headerlink" title="1. 6种互斥量"></a>1. 6种互斥量</h3><ol>
<li><code>std::mutex</code>，独占的互斥量，不能递归使用。 </li>
<li><code>std::time_mutex</code>，带超时的独占互斥量，不能递归使用。 </li>
<li><code>std::recursive_mutex</code>，递归互斥量，不带超时功能。 </li>
<li><code>std::recursive_timed_mutex</code>，带超时的递归互斥量。</li>
<li><code>std::shared_mutex</code> 支持共享锁定（多个线程可以同时以只读方式访问共享资源）和独占锁定（单个线程可以访问共享资源进行读写操作）。</li>
<li><code>std::shared_timed_mutex</code> 支持共享锁定和独占锁定，以及超时功能</li>
</ol>
<h3 id="2-通用锁管理"><a href="#2-通用锁管理" class="headerlink" title="2. 通用锁管理"></a>2. 通用锁管理</h3><h4 id="1-lock-guard"><a href="#1-lock-guard" class="headerlink" title="1. lock_guard"></a>1. lock_guard</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mutex;</span><br><span class="line"><span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line"><span class="comment">//创建即加锁，作用域结束，析构解锁</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>创建即加锁，作用域结束自动析构并解锁，无需手工解锁</li>
<li>不能中途解锁，必须等作用域结束才解锁</li>
<li>不能复制</li>
</ol>
<blockquote>
<p>lock_guard 的作用域内，再次加锁（调用函数，函数内加锁），则会==死锁==。</p>
</blockquote>
<blockquote>
<p>lock_guard 的作用域内，出现mutex对象被释放，则会在==析构时出现空指针==错误。</p>
</blockquote>
<ul>
<li>==递归互斥量==可以解决，但是递归互斥量==效率低，代码难读，不建议==</li>
</ul>
<h4 id="2-unique-lock"><a href="#2-unique-lock" class="headerlink" title="2. unique_lock"></a>2. unique_lock</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mutex;</span><br><span class="line"><span class="function"><span class="type">const</span> std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line"><span class="comment">//创建时默认自动加锁，作用域结束，析构解锁</span></span><br><span class="line"><span class="comment">//lock(mutex,std::defer_lock);初始化不加锁</span></span><br><span class="line">lock.<span class="built_in">lock</span>();<span class="comment">//手动加锁</span></span><br><span class="line">lock.<span class="built_in">unlock</span>();<span class="comment">//手动解锁</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>创建时可以不锁定（通过指定第二个参数为 std::defer_lock），而在需要时再锁定</p>
</li>
<li><p>可以随时加锁解锁</p>
</li>
<li><p>作用域规则同 lock_grard，析构时自动释放锁</p>
</li>
<li><p>不可复制，可移动</p>
</li>
<li><p>==条件变量需要该类型的锁作为参数（此时必须使用 unique_lock）==</p>
</li>
</ol>
<h4 id="3-shared-lock"><a href="#3-shared-lock" class="headerlink" title="3. shared_lock"></a>3. shared_lock</h4><ul>
<li>共享锁定，读锁（多个线程可以同时以只读方式访问共享资源）</li>
<li>独占锁定，写锁（单个线程可以访问共享资源进行读写操作）</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line">std::mutex mutex;</span><br><span class="line"><span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line"><span class="comment">////创建时默认自动加锁，作用域结束，析构解锁</span></span><br><span class="line"><span class="comment">//其他shared_lock可以读这些资源，不能写</span></span><br><span class="line"><span class="comment">//unique_lock、lock_guard等写锁则不能读，不能写</span></span><br><span class="line">lock.<span class="built_in">lock</span>(); <span class="comment">// 手动锁定</span></span><br><span class="line">lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br><span class="line">lock.<span class="built_in">try_lock</span>();<span class="comment">//无法获得锁时，不会解锁，用于if-else</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-scoped-locks"><a href="#4-scoped-locks" class="headerlink" title="4. scoped_locks"></a>4. scoped_locks</h4><ul>
<li>对多个互斥量同时加锁</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mutex1,mutex2;</span><br><span class="line"><span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mutex1, mutex2)</span></span>;<span class="comment">//mutex1 和 mutex2 都已被锁定</span></span><br><span class="line"><span class="comment">//创建时默认自动加锁，作用域结束，析构解锁</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>可以接受任意数量的 mutex，并将这些 mutex 传给<code>std::lock</code>来同时上锁，它会对其中一个 mutex 调用 lock()，对其他调用 try_lock()，若 try_lock() 返回 false 则对已经上锁的 mutex 调用 unlock()，然后重新进行下一轮上锁，标准未规定下一轮的上锁顺序，可能不一致，重复此过程直到所有 mutex 上锁，从而达到同时上锁的效果。</li>
</ol>
<h3 id="3-条件变量-condition-variable"><a href="#3-条件变量-condition-variable" class="headerlink" title="3. 条件变量 condition variable"></a>3. 条件变量 condition variable</h3><p>​	多个线程之间需要进行某些同步机制时，如==某个线程的执行需要另一个线程完成后才能进行==，可以使用条件变量。</p>
<p>​	对于==只需要通知一次的情况==，如初始化完成、登录成功等，建议不要使用 condition_variable，使用``std::future`更好。</p>
<p>​	condition_variable 存在一些问题，如==虚假唤醒==，这可以通知增加额外的共享变量来避免。</p>
<blockquote>
<p>针对增加额外的变量这一点，为什么不在另一线程循环检测这个变量，从而达到相同目的而不需要再使用条件变量？</p>
</blockquote>
<ol>
<li>循环检测时，程序在高速运行，==占用过高的cpu==，而条件变量的等待是阻塞，休眠状态下cpu使用率为0，省电！</li>
<li>对于运行中的线程，可能会被操作系统调度，==切换cpu核心==，这样一来，所有的缓存可能失效，而条件变量不会，省时！</li>
</ol>
<h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h4><blockquote>
<p>通知方</p>
</blockquote>
<ol>
<li>获取 std::mutex, 通常是 std::lock_guard</li>
<li>修改共享变量（即使共享变量是原子变量，也需要在互斥对象内进行修改，以保证正确地将修改发布到等待线程）</li>
<li>在 condition_variable 上执行 ==notify_one/notify_all==通知条件变量（该操作不需要锁）</li>
</ol>
<blockquote>
<p>等待方</p>
</blockquote>
<ol>
<li>获取相同的 std::mutex, 使用 std::unique_lock</li>
<li>执行 ==wait，wait_for或wait_until==（该操作会自动释放锁并阻塞）</li>
<li>接收到条件变量通知、超时或者发生虚假唤醒时，线程被唤醒，并自动获取锁。唤醒的线程负责检查共享变量，如果是虚假唤醒，则应继续等待</li>
</ol>
<blockquote alt="info">
    <p>
        std :: condition_variable仅适用于 std::unique_lock, 此限制允许在某些平台上获得最大效率。 
    </p>
    <p>
        std :: condition_variable_any提供可与任何BasicLockable对象一起使用的条件变量，例如std :: shared_lock。
    </p>
</blockquote>

<h4 id="2-condition-variable"><a href="#2-condition-variable" class="headerlink" title="2. condition variable"></a>2. condition variable</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mutex;<span class="comment">//互斥量</span></span><br><span class="line">std::condition_variable cond_var;<span class="comment">//条件变量</span></span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 条件变量关联的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通知方</span></span><br><span class="line">{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cond_var.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待的线程</span></span><br><span class="line">    cond_var.<span class="built_in">notify_all</span>();<span class="comment">//通知多个线程</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待方</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//condition_variable只能用unique_lock</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    cond_var.<span class="built_in">wait</span>(lock, []{<span class="keyword">return</span> ready;}); <span class="comment">// 只有当ready为true时才继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Worker thread is processing data\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p>​	限制对共享资源的并发访问。与条件变量相比，在某些情况下，使用信号量可以更高效。</p>
<ul>
<li>与锁不同，锁一次只能允许==一个线程==访问资源，信号量可以==多个线程==访问资源</li>
</ul>
<h4 id="1-counting-semaphore"><a href="#1-counting-semaphore" class="headerlink" title="1. counting_semaphore"></a>1. counting_semaphore</h4><ul>
<li>C++20标准库中，计数信号量</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="function">std::counting_semaphore&lt;1&gt; <span class="title">sema</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 创建一个初始值为0的信号量</span></span><br><span class="line"><span class="comment">//1表示信号量的最大计数值，调用 release 使其超过最大值会出错，应避免</span></span><br><span class="line">sema.<span class="built_in">release</span>();  <span class="comment">// 增加信号量，信号 加 1</span></span><br><span class="line">sema.<span class="built_in">release</span>(n); <span class="comment">// 信号增加 n</span></span><br><span class="line">sema.<span class="built_in">acquire</span>();  <span class="comment">// 等待信号量，信号 &gt; 0，减 1，否则阻塞</span></span><br><span class="line">sema.<span class="built_in">trt_acquire</span>();<span class="comment">//信号减 1，失败不阻塞</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-binary-semaphore"><a href="#2-binary-semaphore" class="headerlink" title="2. binary_semaphore"></a>2. binary_semaphore</h4><ul>
<li><p><code>counting_semaphore </code>最大值 ==1== 的情况</p>
</li>
<li><p>高效</p>
</li>
<li><p>有 <code>release()</code> ,<code>acquire()</code>,<code>try_acquire()</code>,<code>try_acquire_for()</code></p>
<p><code>try_acquire_until</code>等函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">sema</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//指定超时时间 1s 的等待</span></span><br><span class="line"><span class="type">bool</span> acquired = sema.<span class="built_in">try_acquire_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//在指定的绝对时间点之前获取信号量</span></span><br><span class="line"><span class="keyword">auto</span> deadline = std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">bool</span> acquired = sema.<span class="built_in">try_acquire_until</span>(deadline);</span><br></pre></td></tr></tbody></table></figure>

<p>##3. 闩和屏障 —- 线程同步</p>
<ul>
<li>与信号量和互斥锁的保护共享资源不同，闩和屏障是用于==线程同步==。</li>
</ul>
<h3 id="1-latch-闩"><a href="#1-latch-闩" class="headerlink" title="1. latch 闩"></a>1. latch 闩</h3><ul>
<li>同步原语，用于阻塞一个或多个线程，直到某个事件的发生次数达到指定次数。</li>
<li>一旦达到这个次数，等待的所有线程都会被释放</li>
<li><code>std::latch</code>是单次使用的，意味着它不能被重置。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="function">std::latch <span class="title">latch</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">latch.<span class="built_in">count_down</span>();<span class="comment">//latch数 减1，即latch事件完成</span></span><br><span class="line">latch.<span class="built_in">wait</span>();<span class="comment">//等待latch减为0，即所有线程的latch都已完成</span></span><br><span class="line">latch.<span class="built_in">try_wait</span>();<span class="comment">//不阻塞等待 latch到0</span></span><br><span class="line">latch.<span class="built_in">arrive_and_wait</span>();<span class="comment">//减少latch，并阻塞等待到0，即count_down + wait</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-barrier-屏障"><a href="#2-barrier-屏障" class="headerlink" title="2. barrier 屏障"></a>2. barrier 屏障</h3><ul>
<li>与<code>latch</code>一样，阻塞线程，直到事件发生指定次数。</li>
<li>与<code>latch</code>不同，<code>barrier</code> 可以阻塞一个线程中的多个事件</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="function">std::barrier <span class="title">barrier</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">std::barrier <span class="title">barrier</span><span class="params">(<span class="number">4</span>,func)</span></span>;<span class="comment">//func为回调函数，所有线程都完成后执行func</span></span><br><span class="line">barrier.<span class="built_in">arrive_and_down</span>();<span class="comment">//设置同步点，并减1</span></span><br><span class="line">barrier.<span class="built_in">arrive</span>();<span class="comment">//barrier 减1</span></span><br><span class="line">barrier.<span class="built_in">wait</span>();<span class="comment">//阻塞，等待其他任务完成，即barrier为0</span></span><br><span class="line"><span class="comment">//假设一个并行计算任务由4个线程执行，但是在完成第一阶段后，其中一个线程的任务就结束了，而其他三个线程需要继续执行更多阶段的任务</span></span><br><span class="line">barrier.<span class="built_in">arrive_and_drop</span>();<span class="comment">//用于多事件需要执行次数不同情况</span></span><br><span class="line"><span class="comment">//当前计数减1，后续所有计数减1</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-未来体-—-异步任务"><a href="#4-未来体-—-异步任务" class="headerlink" title="4. 未来体 —- 异步任务"></a>4. 未来体 —- 异步任务</h2><ul>
<li><code>std::future</code>用于从异步操作获取结果。它代表了一个将来某个时间点才会被计算出来的值。</li>
<li>使用<code>std::future</code>可以启动一个异步任务（比如通过<code>std::async</code>），然后在需要结果的时候等待这个结果变得可用</li>
</ul>
<h3 id="1-async"><a href="#1-async" class="headerlink" title="1. async"></a>1. async</h3><ul>
<li>用于简化异步编程。它允许你以异步方式执行任务，这意味着主线程可以继续执行，而不必等待异步任务完成</li>
<li>两种策略，实现==异步和同步==</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; future1 = std::<span class="built_in">async</span>(std::launch::async, func);</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future2 = std::<span class="built_in">async</span>(std::launch::deferred, func);</span><br><span class="line"><span class="comment">//async策略和deferred策略，前者是异步，后者会延迟等待到get/wait函数才执行，即同步</span></span><br><span class="line"></span><br><span class="line">future1.<span class="built_in">get</span>();<span class="comment">//阻塞等待future执行，并获取执行返回的结果</span></span><br><span class="line">future2.<span class="built_in">wait</span>();<span class="comment">//阻塞等待future执行，不获取结果</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-promise"><a href="#2-promise" class="headerlink" title="2. promise"></a>2. promise</h3><ul>
<li>在多线线程之间传递值或通报状态。<code>std::promise</code> 对象==可以存储某一类型的值==，该值可在未来某个时间点被另一个线程检索</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; &amp;&amp;promise)</span></span>{</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">1</span>);<span class="comment">//设置值</span></span><br><span class="line">}</span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>();<span class="comment">//从promise获取值</span></span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(func,std::move(promise))</span></span>;<span class="comment">//多线程执行计算promise</span></span><br><span class="line"><span class="comment">//这里不能传参，只能move，因为promise不能被复制，只能移动</span></span><br><span class="line">future.<span class="built_in">get</span>();<span class="comment">//获取promise值</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-share-future"><a href="#3-share-future" class="headerlink" title="3. share_future"></a>3. share_future</h3><h4 id="1-future"><a href="#1-future" class="headerlink" title="1. future"></a>1. future</h4><ul>
<li><code>std::future</code> 对象是不可复制的，这意味着你不能将它们传递给多个线程或函数，除非使用 <code>std::move</code> 操作</li>
<li>调用了 <code>std::future::get</code> 方法获取结果，<code>future</code>就会被销毁</li>
</ul>
<blockquote>
<p>std::move的好处</p>
</blockquote>
<ul>
<li>保证在任何时刻只有一个 <code>std::future</code> 对象拥有访问共享状态（即异步结果）的权利，这也避免了对共享状态的不确定性访问。</li>
</ul>
<h4 id="2-share-future"><a href="#2-share-future" class="headerlink" title="2. share_future"></a>2. share_future</h4><ul>
<li><code>std::shared_future</code> 对象可以被复制，并且所有复制的 对象都可以访问同一个共享状态</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="comment">// 使用 std::async 创建一个异步任务</span></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, []() { <span class="keyword">return</span> <span class="number">10</span>; });</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 std::future 转换为 std::shared_future</span></span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; sharedFut = fut.<span class="built_in">share</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，sharedFut 可以被安全地复制和在多个线程中使用</span></span><br><span class="line">std::shared_future&lt;<span class="type">int</span>&gt; sharedFutCopy = sharedFut;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-packaged-task"><a href="#4-packaged-task" class="headerlink" title="4. packaged_task"></a>4. packaged_task</h3><ul>
<li>将一个可调用对象包装起来，使其可以异步执行。</li>
<li>结果可以稍后通过一个 <code>std::future</code> 对象来获取。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 创建一个std::packaged_task对象，它封装了myFunction函数</span></span><br><span class="line"><span class="comment">//string(int)表示返回string，参数类型int</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">string</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取与packaged_task关联的future对象</span></span><br><span class="line">std::future&lt;string&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个新线程上异步执行packaged_task</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>)</span></span>; <span class="comment">// 传递10作为myFunction的参数</span></span><br><span class="line">t.<span class="built_in">detach</span>(); <span class="comment">// 让线程独立运行</span></span><br><span class="line"><span class="comment">//直接运行</span></span><br><span class="line"><span class="built_in">task</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从future对象中获取执行结果</span></span><br><span class="line">result.<span class="built_in">get</span>();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="5-原子操作"><a href="#5-原子操作" class="headerlink" title="5. 原子操作"></a>5. 原子操作</h2><h3 id="1-原子类型"><a href="#1-原子类型" class="headerlink" title="1. 原子类型"></a>1. 原子类型</h3><ul>
<li>原子类型用于实现==无锁编程==，允许在多线程环境中对数据进行无竞争的访问和修改。</li>
</ul>
<h4 id="1-atomic"><a href="#1-atomic" class="headerlink" title="1. atomic"></a>1. atomic</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//fetch_sub()减,fetch_and(),fetch_or(),fetch_xor()</span></span><br><span class="line">    atomic.<span class="built_in">fetch_add</span>(<span class="number">1</span>,std::memory_order_relaxed);<span class="comment">//原子增加</span></span><br><span class="line">    std::<span class="built_in">store</span>(&amp;atomic,<span class="number">10</span>);<span class="comment">//atomic值设为10</span></span><br><span class="line">    atomic.<span class="built_in">store</span>(<span class="number">10</span>);<span class="comment">//atomic值设为10</span></span><br><span class="line">    <span class="comment">//atomic的值原子的设为20，并且返回之前的值</span></span><br><span class="line">    <span class="type">int</span> oldValue = std::<span class="built_in">atomic_exchange</span>(&amp;atomic, <span class="number">20</span>);</span><br><span class="line">    std::<span class="built_in">atomic_is_lock_free</span>(&amp;atomic);<span class="comment">//atomic是否是无锁的</span></span><br><span class="line">    atomic.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待 atomic 改变的线程</span></span><br><span class="line"> 	atomic.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有等待 atomic 改变的线程</span></span><br><span class="line">}</span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(func)</span></span>;</span><br><span class="line">atomic.<span class="built_in">wait</span>(<span class="number">0</span>); <span class="comment">// 等待 atomic 从 0 改变</span></span><br><span class="line">atomic.<span class="built_in">load</span>();<span class="comment">//加载原子值</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>如果一个原子操作是无锁的，这意味着它不依赖于内部或外部的锁机制来保证操作的原子性，从而可以提高并发性能。无锁的原子操作直接由==硬件提供支持==。</li>
</ol>
<h4 id="2-atomic-flag"><a href="#2-atomic-flag" class="headerlink" title="2. atomic_flag"></a>2. atomic_flag</h4><ul>
<li><code>std::atomic_flag</code> 是 C++ 中最简单的原子类型，它是一个布尔标志，只能被设置（true）和清除（false）</li>
<li>C++ 标准库中唯一保证是锁自由的原子类型，这意味着它不会造成调用线程的阻塞。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)){</span><br><span class="line">        <span class="comment">//等待锁释放</span></span><br><span class="line">    }    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Task "</span> &lt;&lt; id &lt;&lt; <span class="string">" is running\n"</span>;</span><br><span class="line">    lock.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">}</span><br><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>操作前 <code>std::atomic_flag</code> 是 false（未设置），<code>test_and_set</code> ==返回 false==；如果是 true（已设置），则返回 true。无论哪种情况，操作后 <code>atomic_flag</code> 都会被设置为 true。</li>
<li>使用 <code>clear</code> 操作释放锁，以便其他线程可以通过 <code>test_and_set</code> 成功获取锁。</li>
</ol>
<h3 id="2-内存顺序"><a href="#2-内存顺序" class="headerlink" title="2. 内存顺序**"></a>2. 内存顺序**</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> {</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    <span class="comment">//最宽松的内存顺序。允许最大程度的重排序，不保证操作间的同步，只保证单个操作的原子性。</span></span><br><span class="line">    memory_order_consume, </span><br><span class="line">    <span class="comment">// （已弃用）针对数据依赖性的弱同步顺序，现行为与memory_order_acquire相同。</span></span><br><span class="line">    memory_order_acquire, </span><br><span class="line">    <span class="comment">// 阻止当前操作之后的读或写操作重排序到当前操作之前（用于读取操作），保证对共享数据的更改可见。</span></span><br><span class="line">    memory_order_release, </span><br><span class="line">    <span class="comment">// 阻止当前操作之前的读或写操作重排序到当前操作之后（用于写入操作），保证对共享数据的更改对其他线程可见。</span></span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    <span class="comment">// 同时具有memory_order_acquire和memory_order_release的特性，适用于同时包含读写操作的原子操作。</span></span><br><span class="line">    memory_order_seq_cst  </span><br><span class="line">    <span class="comment">// 顺序一致性内存顺序。提供对所有线程的全局顺序保证，是最严格的内存顺序，防止任何操作的重排序。</span></span><br><span class="line">} memory_order;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/598993031">1. C++11互斥量mutex使用详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35945236/article/details/124505414">2. lock_guard和unique_lock</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guotianqing/article/details/104017649">3.条件变量condition variable的使用逻辑</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="https://telegraph-image-9wl.pages.dev/file/f665cfdbff34f699fd791.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/" title="模版template <class T> 和 template <typename T> 区别"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/de4af16c0a3cb300d0b88.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">模版template &lt;class T&gt; 和 template &lt;typename T&gt; 区别</div></div></a></div><div><a href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/" title="BSTree::Node* &amp;node和BSTree::Node &amp;node 区别"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/40474d496fa9353349be8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-07</div><div class="title">BSTree::Node* &amp;node和BSTree::Node &amp;node 区别</div></div></a></div><div><a href="/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/" title="install_name_tool 解决链接找不到动态库"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/28b4858531838e5b7b127.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-17</div><div class="title">install_name_tool 解决链接找不到动态库</div></div></a></div><div><a href="/2024/02/24/C-%E9%97%AE%E9%A2%98-4-select-%E5%AE%A2%E6%88%B7%E7%AB%AF-printf-%E4%B8%8D%E6%89%93%E5%8D%B0/" title="select() 客户端 printf() 不打印"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/def9ee759192782c7fdf2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-24</div><div class="title">select() 客户端 printf() 不打印</div></div></a></div><div><a href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/4259e776135f8cd61103c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-27</div><div class="title">红黑树</div></div></a></div><div><a href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" title="Linux 命令使用"><img class="cover" src="https://telegraph-image-9wl.pages.dev/file/db50105f0f128110386e2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-21</div><div class="title">Linux 命令使用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">C++并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1. 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-thread"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-jthread"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. jthread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-this-thread%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. this_thread作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-yield"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1. yield</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-get-id"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2. get_id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sleep-for"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3. sleep_for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-sleep-until"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">4. sleep_until</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%94%81%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F-%E2%80%94-%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2. 锁和信号量 —- 共享资源访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E7%A7%8D%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 6种互斥量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E9%94%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 通用锁管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-lock-guard"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. lock_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-unique-lock"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. unique_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-shared-lock"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. shared_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-scoped-locks"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. scoped_locks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-condition-variable"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 条件变量 condition variable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-condition-variable"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. condition variable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-counting-semaphore"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1. counting_semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-binary-semaphore"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2. binary_semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-latch-%E9%97%A9"><span class="toc-number">1.2.5.</span> <span class="toc-text">1. latch 闩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-barrier-%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.6.</span> <span class="toc-text">2. barrier 屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%AA%E6%9D%A5%E4%BD%93-%E2%80%94-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">4. 未来体 —- 异步任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-async"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-promise"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-share-future"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. share_future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-future"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1. future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-share-future"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. share_future</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-packaged-task"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. packaged_task</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">5. 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 原子类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-atomic"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1. atomic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-atomic-flag"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2. atomic_flag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 内存顺序**</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By Just花语</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>