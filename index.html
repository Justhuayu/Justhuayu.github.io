<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Just花语的博客</title><meta name="author" content="Just花语"><meta name="copyright" content="Just花语"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Just花语的博客">
<meta property="og:url" content="https://justhuayu.github.io/index.html">
<meta property="og:site_name" content="Just花语的博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png">
<meta property="article:author" content="Just花语">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png"><link rel="shortcut icon" href="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png"><link rel="canonical" href="https://justhuayu.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Just花语的博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-03-20 20:31:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Just花语的博客"><span class="site-name">Just花语的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Just花语的博客</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/Justhuayu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:justhuayu@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/20/C-%E9%9B%B6%E5%A3%B0linux-22-%E5%86%85%E5%AD%98%E6%B1%A0/" title="内存池"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/b89cb2c0122f47cdf3a26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存池"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/20/C-%E9%9B%B6%E5%A3%B0linux-22-%E5%86%85%E5%AD%98%E6%B1%A0/" title="内存池">内存池</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-20T12:22:00.000Z" title="发表于 2024-03-20 20:22:00">2024-03-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
内存池1. 原理1. 开源内存池
tcmalloc
jemalloc

</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/20/C-%E7%9F%A5%E8%AF%86%E7%82%B9-2-%E4%B8%80%E9%87%8D%E6%8C%87%E9%92%88%E5%BC%BA%E8%BD%AC%E4%BA%8C%E9%87%8D%E6%8C%87%E9%92%88/" title="一重指针强转二重指针"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/72038b7edc2bdce452a5e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一重指针强转二重指针"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/20/C-%E7%9F%A5%E8%AF%86%E7%82%B9-2-%E4%B8%80%E9%87%8D%E6%8C%87%E9%92%88%E5%BC%BA%E8%BD%AC%E4%BA%8C%E9%87%8D%E6%8C%87%E9%92%88/" title="一重指针强转二重指针">一重指针强转二重指针</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-20T02:53:00.000Z" title="发表于 2024-03-20 10:53:00">2024-03-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
一重指针强转二重指针1. threadpool代码###1. 一重转二重
123456789101112131415static inline void__add_task(task_queue_t* queue, task_t* task){    void** link = (void**)task;    *link = NULL;       //相当于task-&gt;next = NULL;    spinlock_lock(&amp;queue-&gt;lock);    //TODO：这两行什么用？Answered    //Answer：1. 一重指针指向类型大小的地址，二重指针指向地址的前8位（指针大小的地址）    //Answer：2. *queue-&gt;tail 表示tail类型大小的指针指向NULL(link)    //Answer：3. queue-&gt;tail 表示tail地址的前8位(二重指针)，即next指向NULL    *queue-&gt;tail = link;    queue-&gt;tail = link ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/20/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-2-threadpool/" title="threadpool"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/8700c274ac71301334cb9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="threadpool"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/20/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-2-threadpool/" title="threadpool">threadpool</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-20T02:00:00.000Z" title="发表于 2024-03-20 10:00:00">2024-03-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">[TOC]
threadpool1. 简介1. 代码实现​        thread_pool.c 和 thread_pool.h​        使用了github上开源的一个原子操作代码：atomic.h、spinlock.h
2. 编译动态库​	    gcc -shared thread_pool.o -o libthread_pool.so -I./ -L./ -lpthread
3. 测试、引应用
include thread_pool.h &amp; link libthread_pool.so
gcc -Wl,-rpath=./ main.c -o main -I./ -L./ -lthread_pool -lpthread

2. 代码段理解1. 一重指针强转二重指针123456789101112131415static inline void__add_task(task_queue_t* queue, task_t* task){    void** link = (void**)task;    *link = NULL;       //相当于ta ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/7de1609f2980b10353cf7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程池"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-19T07:22:00.000Z" title="发表于 2024-03-19 15:22:00">2024-03-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
1. 线程池1. 原理1. 线程池​	管理维持固定线程数量的池式结构

为什么是固定数量？


避免频繁创建销毁
随着数量增加，性能可能下降


如何决定线程池数量？


cpu密集型 ：$n \times proc(核心数)$，通常为$2 \times proc$
io 密集型（网络io、磁盘io）


为什么需要线程池？


某类任务特别耗时，这个耗时会严重影响当前线程处理其他任务，为了不影响当前线程，将该任务抛到线程池中。
复用线程资源
充分利用系统资源
异步执行


线程池是生成消费者模型


生产者线程，发布任务（队列，用于存储任务，调度线程池状态）
消费者线程，取出任务，执行任务

2. 设计线程池1. 接口设计
暴露给用户使用的接口，隐藏具体实现细节


C++：头文件中类暴露
public：所有
protected：子类
private：隐藏


C：头文件 .h 中暴露

2. 数据结构设计
队列：存储任务
任务本身
任务队列

3. 锁1. 互斥锁​	互斥锁是一种独占锁，当线程A加锁成功后，此时互斥锁已经被线程A独占了，只要线程A没有释放手中的锁，线程B ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/19/%E7%A7%91%E7%A0%94-14-Text-Guided-Variational-Image-Generation/" title="Text-Guided Variational Image Generation for Industrial Anomaly Detection and Segmentation"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/590d46d735bef6f03ae35.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Text-Guided Variational Image Generation for Industrial Anomaly Detection and Segmentation"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/19/%E7%A7%91%E7%A0%94-14-Text-Guided-Variational-Image-Generation/" title="Text-Guided Variational Image Generation for Industrial Anomaly Detection and Segmentation">Text-Guided Variational Image Generation for Industrial Anomaly Detection and Segmentation</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-19T01:30:00.000Z" title="发表于 2024-03-19 09:30:00">2024-03-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
论文模型名
CVPR 2024


中英大学（韩国首尔），Mingyu Lee，Jongwon Choi





一种泛用方法，能加到任意模型提点
本文主要工作为生成额外丰富数据集，用于下游模型训练


1. 问题1. 数据集问题
工业制造中获得清晰数据进行异常检测的挑战。

​	异常检测的有效性取决于可用的无缺陷数据的数量和质量，因为这些因素直接影响模型包含目标物体外观不同光谱的能力。最重要的是，很难从视觉上对工业缺陷进行分类，因为错误可以从细微的变化(如薄划痕)到重大的结构缺陷(如缺少组件)不等
2. 不平衡的正常数据问题
正常数据本身可以呈现出接近均匀性，只有少数图像显示出可接受缺陷的微小差异

3. 数据的敏感性
在外观和缺陷程度方面，因为它们可能因所使用的机器类型和捕获条件而有很大差异。最后一个是在过度收集非缺陷数据期间错误地将缺陷数据错误地标记为非缺陷数据的可能性。

2. 创新1. variation-based image generator
保证泛化和鲁棒性

2. keyword-to-prompt generator
解决正常数据缺乏多样性的问题

 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/19/%E7%A7%91%E7%A0%94-%E5%9B%A2%E9%98%9F/" title="团队"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/0a487bb83f3024d2e750c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="团队"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/19/%E7%A7%91%E7%A0%94-%E5%9B%A2%E9%98%9F/" title="团队">团队</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-18T16:00:00.000Z" title="发表于 2024-03-19 00:00:00">2024-03-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
1. Jiaqi Liu
南方科技大学




Deep Industrial Image Anomaly Detection：A Survey
Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt（UCAD）

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/18/%E7%A7%91%E7%A0%94-13-RealNet/" title="RealNet：A Feature Selection Network with Realistic Synthetic Anomaly for Anomaly Detection"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/ecfd72be98b05d5714ff2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RealNet：A Feature Selection Network with Realistic Synthetic Anomaly for Anomaly Detection"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/18/%E7%A7%91%E7%A0%94-13-RealNet/" title="RealNet：A Feature Selection Network with Realistic Synthetic Anomaly for Anomaly Detection">RealNet：A Feature Selection Network with Realistic Synthetic Anomaly for Anomaly Detection</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-18T01:42:00.000Z" title="发表于 2024-03-18 09:42:00">2024-03-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
论文模型名
CVPR 2024


首都师范大学，Ximiao Zhang，Min Xu





从基础数据集构建合成数据集
自监督特征重构，进行异常检测


1. 问题1. 自监督特征重建问题
合成真实多样的异常样本、解决特征冗余和预训练特征的预训练偏差等方面仍然面临挑战

​	由于缺乏可用的异常图像和异常类别的先验知识，现有方法依赖于精心设计的数据增强策略或外部数据进行异常合成，导致合成异常与真实异常的分布差异较大。从而限制了异常检测模型在实际应用中的泛化能力。

由于特征重建的计算量大，缺乏有效的特征选择策略，现有方法要么使用小规模预训练的cnn[33,44,49]进行异常检测，要么从预训练的网络[8,53]中挑选特定层的特征进行重建。


现有的异常检测方法[30,46]对特征选择很敏感。在不同的分类中，用于异常检测的最优预训练特征子集是不同的。

2. 创新1. 数据集SIA
根据SDAS方法，生成异常数据集SIA

2. 强度可控扩散异常合成(SDAS )
一种基于扩散过程的合成策略，能够生成具有不同异常强度的样本，模拟真实异常样本的分布。

3. 异常感知特 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-20-io-uring/" title="io_uring"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/909df8ddf18e2102f454c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="io_uring"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/17/C-%E9%9B%B6%E5%A3%B0linux-20-io-uring/" title="io_uring">io_uring</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-17T13:00:00.000Z" title="发表于 2024-03-17 21:00:00">2024-03-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
io_uring1. 原理1. 异步的读
内存中设计一个==ring，存放读队列==
内核==遍历读队列==，依次执行读
内核执行后的读，放入==另一个ring==中，用于返回


2. 使用条件
内核版本 kernel &gt;=5.10 （uname -a）

安装库==liburing==，该库依赖于
 io_uring_setup io_uring_register io_uring_enter
这三个系统调用 （5.10后才有）


3. 安装 liburing
从github clone 项目
 git clone https://github.com/axboe/liburing.git

./configure

make

sudo make install


4. io_uring 的性能
测试网络echo工具：rust_echo_bench

​	使用命令：cargo run --r ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/17/%E7%A7%91%E7%A0%94-8-FOD/" title="Focus the Discrepancy：Intra-and Inter-Correlation Learning for Image Anomaly Detection"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/cfd73730f5420dccf8477.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Focus the Discrepancy：Intra-and Inter-Correlation Learning for Image Anomaly Detection"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/17/%E7%A7%91%E7%A0%94-8-FOD/" title="Focus the Discrepancy：Intra-and Inter-Correlation Learning for Image Anomaly Detection">Focus the Discrepancy：Intra-and Inter-Correlation Learning for Image Anomaly Detection</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-17T07:00:00.000Z" title="发表于 2024-03-17 15:00:00">2024-03-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
FOD
ICCV 2023


上海交通大学，Xincheng Yao，Ruoqi Li，,Chongyang Zhang（通讯）


1. 问题1. 现有AD方法没有结合patch间互补性​	人类通过两个方面来识别异常:larger patch-wise representation discrepancies和weaker patch-to-normal-patch correlations。然而，以往的AD方法并没有充分结合这两个互补的方面来设计AD模型。
2. 现有AD未充分利用Transformer
现有AD只用Transformer提取特征，未充分利用Transformer的长范围对齐能力

​	与这些作品不同的是，本文明确地利用Transformer的自注意力来建立图像内和图像间的相关性。每个patch的相关分布可以提供更多的空间上下文信息描述，从而揭示更复杂的语义异常模式。
2. 创新1. FOD框架
FOD 可以通过同时发现patch-wise、inter和intra的差异来有效地检测异常。

2. I2Correlation自注意机制
I2Correla ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/17/%E7%A7%91%E7%A0%94-7-SAA/" title="Segment Any Anomaly without Training via Hybrid Prompt Regularization"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/4bed9cb9449e3204e1c13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Segment Any Anomaly without Training via Hybrid Prompt Regularization"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/17/%E7%A7%91%E7%A0%94-7-SAA/" title="Segment Any Anomaly without Training via Hybrid Prompt Regularization">Segment Any Anomaly without Training via Hybrid Prompt Regularization</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-17T05:12:00.000Z" title="发表于 2024-03-17 13:12:00">2024-03-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
SAA+
arxiv2023


华中科技大学，Yunkang Cao、 Xiaohao Xu、Weiming Shen（通讯）




不需要训练
典型的提示工程


1. 问题1. ZSAS（zero-shot anomaly segmentation,）方向大问题
现有的异常分割模型通常依赖于特定领域的微调，限制了它们在无数异常模式中的泛化。

2. 预训练数据与测试数据域转移问题
面对基础模型预训练数据分布与下游异常分割数据集之间的域转移，传统的语言提示可能会失效。

​	某些语言提示，如“异常”，可能无法检测到所需的异常区域。例如，如图2所示，所有“灯芯”都被SAA错误地识别为带有“异常”提示的异常。
3. 粗粒度上下文分割不准确
目标的“异常”程度取决于对象上下文，这对于粗糙的粗粒度语言提示(例如“异常区域”)很难准确表达。

2. 创新1. 引入专家知识
专家知识提供了与开放世界场景中目标相关的异常的详细描述。


引入详细的语言提示，解决预训练模型“歧义”问题。
引入属性提示，解决预训练模型对“count”、“area”等认识不足问题，即具有特定属性描述(如 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/17/%E7%A7%91%E7%A0%94-%E6%A8%A1%E7%89%88/" title="模版"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/a37eea9b3846997e38fe5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="模版"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/17/%E7%A7%91%E7%A0%94-%E6%A8%A1%E7%89%88/" title="模版">模版</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-16T16:00:00.000Z" title="发表于 2024-03-17 00:00:00">2024-03-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
论文模型名
论文期刊


研究团队



1. 问题2. 创新3. 方法4. 结果论文链接
代码链接
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/16/%E7%A7%91%E7%A0%94-12-Survey2024/" title="Deep Industrial Image Anomaly Detection：A Survey"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/017edd72f0a5a9500da0d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Deep Industrial Image Anomaly Detection：A Survey"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/16/%E7%A7%91%E7%A0%94-12-Survey2024/" title="Deep Industrial Image Anomaly Detection：A Survey">Deep Industrial Image Anomaly Detection：A Survey</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-16T01:00:00.000Z" title="发表于 2024-03-16 09:00:00">2024-03-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
作者总结
MIR 2024


南方科技大学，Jiaqi Liu，Guoyang Xie

1. 方法总结
对于图像级异常检测任务的识别，基于记忆库的方法是最有效的神经网络设计。然而，它们在检测像素级异常方面是不够的。
集成学习可以显著提高最先进的异常检测方法的性能。
SSPCAB[96]可以无缝集成到前沿方法中，显著提高基于重建的方法的性能。
few-shot IAD和普通IAD之间的差距正在缩小。换句话说，我们可以利用数据蒸馏算法来减少用于异常检测的数据集的数量。
MemSeg和DRAEM的有效性证明了分割模块在异常检测中的优越性。人工监督往往不如真实监督，用人工监督训练的分割模型往往表现较差。
AU-PR在分割任务中比AU-ROC更有价值

2. 未来方向
多模态IAD数据集。
解决IAD的推理速度问题。
大多数IAD方法使用ImageNet预训练模型从工业图像中提取特征，这不可避免地导致特征漂移问题。因此，迫切需要为工业图像构建预训练模型。
无监督方法和有监督方法应该相辅相成，近年来有监督方法发展缓慢的主要原因是缺乏大量的标记数据集。因此，未来有必要提出具有像素级注 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/14/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="epoll的实现"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/545b3e3037dfad4c22d01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="epoll的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/14/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="epoll的实现">epoll的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-14T08:00:00.000Z" title="发表于 2024-03-14 16:00:00">2024-03-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
#epoll的实现
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/13/C-%E9%9B%B6%E5%A3%B0linux-18-%E7%94%A8%E6%88%B7%E6%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" title="用户态TCP IP协议栈设计实现"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/9a55f81cde0f006c8c042.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用户态TCP IP协议栈设计实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/13/C-%E9%9B%B6%E5%A3%B0linux-18-%E7%94%A8%E6%88%B7%E6%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" title="用户态TCP IP协议栈设计实现">用户态TCP IP协议栈设计实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-13T08:00:00.000Z" title="发表于 2024-03-13 16:00:00">2024-03-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
#用户态TCP IP协议栈设计实现
1. dpdk简介1. tcp/ip协议栈如何设计？
如何拿到网络数据?（网卡的原生数据包）


原生socket 
netmap（长年未更新）
dpdk




==sk_buff==缓存NIC接受到数据包。


dpdk作用




接管物理网卡的 数据，方便协议栈的设计实现


dpdk的性能提升


dpdk对==提高网络并发量无关==。

dpdk==不能解决低延迟问题==。

设置==hugepage提高数据吞吐量==，2M或1G（正常页是4K）

多队列网卡的TX、RX是分开处理的。

多核处理多队列。


2. dpdk编程1. rte_eal_init
初始化


函数初始化EAL（环境抽象层）。
EAL是DPDK的基础部分，负责管理CPU核、内存、设备驱动和其他系统资源的低层次细节。
rte_eal_init必须是应用程序调用的第一个DPDK函数，用于 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/13/%E7%A7%91%E7%A0%94-6-InCTRL/" title="Toward Generalist Anomaly Detection via In-context Residual Learning with Few-shot Sample Prompts"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/d4614dfd2ab10e0213929.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Toward Generalist Anomaly Detection via In-context Residual Learning with Few-shot Sample Prompts"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/13/%E7%A7%91%E7%A0%94-6-InCTRL/" title="Toward Generalist Anomaly Detection via In-context Residual Learning with Few-shot Sample Prompts">Toward Generalist Anomaly Detection via In-context Residual Learning with Few-shot Sample Prompts</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-13T01:55:00.000Z" title="发表于 2024-03-13 09:55:00">2024-03-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
InCTRL
CVPR2024


新加坡管理大学，Jiawen Zhu 、Guansong Pang



1. 问题1. 工业异常检测泛化问题
当前的AD范式侧重于在训练数据上单独构建一个模型

​	它们在应用场景中变得不可行，其中由于数据隐私问题（例如，由于机器遗忘而在训练模型时使用这些数据）或在部署新应用程序时大规模训练数据不可用，不允许在目标数据集上进行训练。
2. CLIP用于工业检测问题
模型的一个显著限制是它们依赖于一组专门针对缺陷的手动提示

​	这种依赖限制了它们的适用性，使其难以扩展到检测其他数据域中的异常，例如，医学图像异常或一类或多类设置中的语义异常。
2. 创新1. few-shot
现实世界的应用中，通常很容易获得少镜头正常图像

​	这几个镜头样本不用于模型训练/调整；它们只是用作样本提示，用于在推理过程中对测试图像进行异常评分。
​	本文方法与当前的少镜头AD方法有根本不同，后者使用这些目标样本及其广泛的增强版本来训练检测模型，这可能导致目标数据集的过拟合，并且无法推广到其他数据集。
3. 方法4. 结果论文链接
代码链接
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/11/C-%E9%97%AE%E9%A2%98-5-git-push-%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/" title="git push 没有访问权限"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/2f0010fc2c9363b56084b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git push 没有访问权限"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/11/C-%E9%97%AE%E9%A2%98-5-git-push-%E6%8A%A5%E9%94%99%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/" title="git push 没有访问权限">git push 没有访问权限</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-11T04:53:00.000Z" title="发表于 2024-03-11 12:53:00">2024-03-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
1. 问题描述
在服务器push代码到github上时，报错git push 没有访问权限



2. 解决办法1. 生成ssh密钥ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
2. 将ssh公钥添加到githubcat ~/.ssh/id_rsa.pub 查看公钥，复制所有内容到github中
3. 开启ssh代理eval "$(ssh-agent -s)" 
ssh-add ~/.ssh/id_rsa
4. 测试连接ssh -T git@github.com
</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/07/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-1-NtyCo/" title="NtyCo"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/9bbf5963543c06ead5ff2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NtyCo"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/07/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-1-NtyCo/" title="NtyCo">NtyCo</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-07T06:00:00.000Z" title="发表于 2024-03-07 14:00:00">2024-03-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">[TOC]
NtyCo1. 简介​	纯c版本的协程实现，汇编切换，调度器实现，包含服务器端案例，客户端并发测试案例。
github:NtyCo
NtyCo的实现
POSIX线程基本操作
2. 函数1. 语法相关1. ifndef1#ifndef _USE_UCONTEXT ... #endif


判断是否定义过 #define _USE_UCONTEXT

多用于跨平台兼容性


2. static 和 extern
static 定义==该文件下==的全局变量
没有static定义的全局变量，其他文件可以用==extern==访问

3. 二重指针和一重指针
二重指针可以==修改地址==，例如函数内calloc一段地址给参数指针。**new_co; *co = calloc; *new_co = co;

一重指针用于修改地址对应的值，==地址不能变，值能变==。


4. PRIu64 和 PRId32
用于格式化输出无符 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-17-%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/" title="协程设计原理"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/07ba302c03e658aa11998.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="协程设计原理"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-17-%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/" title="协程设计原理">协程设计原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-05T11:00:00.000Z" title="发表于 2024-03-05 19:00:00">2024-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
#协程设计原理
1.协程相关问题

1. 为什么要有协程
业务处理时间远小于 IO 耗时，线程切换非常频繁，那么使用协程是不错的选择；
协程的引入简化了异步编程
协程为一些异步编程提供了无锁的解决方案：同步的编程方式，异步的性能。

2. 协程的原语操作
yield 让出
resume 恢复
都是通过switch切换实现

3. 协程的切换
setjmp/longjmp
ucontext
asm code



​	根据cpu的结构，会有一组寄存器reg，切换就是将这组寄存器reg保存起来，然后加载其他的寄存器组。
4. 协程的coroutine如何定义123456789101112131415161718192021struct coroutine(){    int coid;//创建、删除、加入协程时的id    struct context ctx;//cpu上下文    void* (*entry)(void* );//入口函数    void  *args;//入口函数参数    void  *stack;//独立栈 or 共享栈    size_t  ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-16-UDP%E3%80%81KCP%E4%B8%8EQUIC/" title="UDP、KCP与QUIC"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/ab028f619443fff3d5404.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UDP、KCP与QUIC"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/05/C-%E9%9B%B6%E5%A3%B0linux-16-UDP%E3%80%81KCP%E4%B8%8EQUIC/" title="UDP、KCP与QUIC">UDP、KCP与QUIC</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-05T02:04:00.000Z" title="发表于 2024-03-05 10:04:00">2024-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">UDP、KCP与QUIC1. 网络基础1. 如何做到可靠性传输
ACK确认
重传机制
序号机制
重排机制
窗口机制，流量控制

2. TCP与UDP
TCP与UDP特点




TCP与UDP报文格式



3. 自动重传协议ARQ（Automatic Repeat-reQuest）
停止等待
回退n帧
选择重传


停止等待




回退n帧

​	为了克服停等协议长时间等待ACK的缺陷，连续ARQ协议会连续发送一组数据包，然后再等待这些数据包的ACK。





选择重传

​	虽然GBN改善了停等协议中时间等待较长的缺陷，但它依旧存在着性能问题。特别是当窗口长度很大的时候，会使效率大大降低。而SR协议通过让发送方仅重传在接收方丢失或损坏了的分组，从而避免了不必要的重传，提高了效率。




4. RTT 和 RTO
RTO（RetransmissionTimeOut）即重传超时时间。


RTT(Round-TripTime)：往返时延。

​	表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。

链路的传播时间（propa ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/04/C-%E9%9B%B6%E5%A3%B0linux-15-PosixAPI%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/" title="PosixAPI与网络协议栈"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/2c083c2ef5f103cfa9849.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PosixAPI与网络协议栈"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/04/C-%E9%9B%B6%E5%A3%B0linux-15-PosixAPI%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/" title="PosixAPI与网络协议栈">PosixAPI与网络协议栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-04T04:12:00.000Z" title="发表于 2024-03-04 12:12:00">2024-03-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
PosixAPI与网络协议栈1.概述
网络API




TCP与UDP




TCP头



2.API详解1. 建立连接


listen


底层listenfd 对应一个tcb块
tcb块设置为监听状态


accept


条件阻塞，等待TCP三次握手的第一次请求（放入半连接队列）
while(accept_queue == nullpty){ pthread_cond_wait();}

从半连接队列获取和TCP三次握手第三次ack标志相同的tcb
*tcb = get_tcb_from(accept_queue)

分配fd给连接
clientfd = get_tcb_from(accept_queue);
tcb = clientfd
return clientfd



connect


通过网络数据包tcb的五元组(sip, dip,sport,dport,proto)，查找对应的半连接队列节点。


socket


socket 意为插座，分配一个fd，供后续tcb使用


bind


将 tcb的ip和port进行绑定，供 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/04/%E7%A7%91%E7%A0%94-5-UniAD/" title="A Unified Model for Multi-class Anomaly Detection"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/138726b6b4bf6be3f1b30.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A Unified Model for Multi-class Anomaly Detection"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/04/%E7%A7%91%E7%A0%94-5-UniAD/" title="A Unified Model for Multi-class Anomaly Detection">A Unified Model for Multi-class Anomaly Detection</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-04T01:00:00.000Z" title="发表于 2024-03-04 09:00:00">2024-03-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
UniAD
NeurIPS 2022 


上海交通大学，Zhiyuan You，Lei Cui





解决重构时，正常和异常图像都能很好重构问题
从公式出发，用不含平凡解的self-attention用作特征提取器
mask周围的块，让图像块不能从周围块算出来


1. 问题1. 使用统一的框架来检测不同对象类的异常
对有限类别进行模型建模

​	训练数据涵盖了一系列类别的正常样本，并且要求学习到的模型在不进行任何微调的情况下完成所有这些类别的异常检测。分类信息(即类标签)在==训练和推理阶段都是不可访问==的。
2. 重构图像异常检测问题：identity shortcut 标识快捷方式
重建网络在该工作中，返回输入的直接结果，而不考虑内容，因此异常样本也能很好的恢复，从而变得难以检测异常

​	在统一情况下，正态数据的分布更为复杂，“相同捷径”问题被放大。直观地说，要学习一个可以重构各种对象的统一模型，需要模型非常努力地学习联合分布。从这个角度来看，学习“相同的捷径”似乎是一个更容易的解决方案。
2. 创新1. 分层查询解码 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-13-http%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="http 服务器"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/141ba8e44798426fb054e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="http 服务器"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-13-http%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="http 服务器">http 服务器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-02T10:42:00.000Z" title="发表于 2024-03-02 18:42:00">2024-03-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC] 
http 服务器</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-14-reactor%E5%8F%8D%E5%BA%94%E5%A0%86/" title="reactor反应堆"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/3b49e61cd3af580e810df.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="reactor反应堆"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/02/C-%E9%9B%B6%E5%A3%B0linux-14-reactor%E5%8F%8D%E5%BA%94%E5%A0%86/" title="reactor反应堆">reactor反应堆</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-02T10:42:00.000Z" title="发表于 2024-03-02 18:42:00">2024-03-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC] 
reactor反应堆1. 网络IO
io函数都有两个作用


io 检测==是否就绪==
io 操作




accept 作用时机

​	TCP三次握手时，==server==第一次收到消息，将其放入==半连接==队列，第二次收到消息，将其放入==全连接==队列。
​	accept检测==全连接队列==是否有数据。

connect 成功条件

​	TCP三次握手时，==client==收到服务端确认回复时，表示建立成功。

read = 0 被动断开

​	TCP四次挥手时，==client==发送==FIN==数据包，里面有==EoF==数据段。==server== ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/02/%E7%A7%91%E7%A0%94-4-AnomalyGPT/" title="AnomalyGPT"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/48e47db1fa6ec57ffd202.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AnomalyGPT"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/02/%E7%A7%91%E7%A0%94-4-AnomalyGPT/" title="AnomalyGPT">AnomalyGPT</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-02T01:00:00.000Z" title="发表于 2024-03-02 09:00:00">2024-03-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
AnomalyGPT
AAAI 2024


中国科学院自动化研究所，Zhaopeng Gu，Bingke Zhu


</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/03/01/C-%E7%9F%A5%E8%AF%86%E7%82%B9-1-malloc%E3%80%81calloc%E5%92%8Crealloc%E5%8C%BA%E5%88%AB/" title="malloc、calloc和realloc区别"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/34da2adcc11d36193971f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="malloc、calloc和realloc区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/01/C-%E7%9F%A5%E8%AF%86%E7%82%B9-1-malloc%E3%80%81calloc%E5%92%8Crealloc%E5%8C%BA%E5%88%AB/" title="malloc、calloc和realloc区别">malloc、calloc和realloc区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-01T13:53:00.000Z" title="发表于 2024-03-01 21:53:00">2024-03-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
malloc、calloc和realloc区别1. 使用1. malloc
malloc


void* malloc (size_t size);
从堆申请==size==字节数 ==未初始化==空间。
成功返回地址，失败NULL。

2. calloc
calloc


void* calloc (size_t num, size_t size);
从堆申请==num X size==字节数 ==初始化0==空间。
成功返回地址，失败NULL。

3. realloc
realloc


void* realloc (void* ptr, size_t size);
从已经分配好的内存中==重新分配，不会初始化==
==没有申请==，和malloc一样，字节分配
==申请过==的：
= ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/27/C-%E9%9B%B6%E5%A3%B0linux-12-epoll-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="epoll 系统调用"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/78de4c1779029fc98c459.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="epoll 系统调用"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/27/C-%E9%9B%B6%E5%A3%B0linux-12-epoll-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="epoll 系统调用">epoll 系统调用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-27T04:40:00.000Z" title="发表于 2024-02-27 12:40:00">2024-02-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
epoll 系统调用1. epoll​	 epoll 是 Linux 特有的 I/O 多路复用机制，==Mac、windows 不支持==。
1. epoll的数据结构​	epoll 要为两个集合选择数据结构

所有 fd 的总集
就绪 fd 的总集


所有 fd 的总集 —-&gt; ==红黑树==

​	首先，对于==一个 fd ，其底层对应一个 TCB==，这是典型的 ==kv 型==数据结构，那么只能从 hash、b/b+树和红黑树进行选择。

==hash== 查询快，但是我们创建 epoll 时并==不知道究竟需要多大的数组==，如果 hash 不断==扩容成本很高==，且==hash的查询不稳定==。

= ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/24/C-%E9%97%AE%E9%A2%98-4-select-%E5%AE%A2%E6%88%B7%E7%AB%AF-printf-%E4%B8%8D%E6%89%93%E5%8D%B0/" title="select() 客户端 printf() 不打印"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/def9ee759192782c7fdf2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="select() 客户端 printf() 不打印"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/24/C-%E9%97%AE%E9%A2%98-4-select-%E5%AE%A2%E6%88%B7%E7%AB%AF-printf-%E4%B8%8D%E6%89%93%E5%8D%B0/" title="select() 客户端 printf() 不打印">select() 客户端 printf() 不打印</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-24T02:53:00.000Z" title="发表于 2024-02-24 10:53:00">2024-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
1.问题背景
​	在学习 select() 函数实现多路 IO 复用时，遇到问题：客户端能够正常收发数据，而服务端却只能打印客户端第一次发送的数据，后续这个客户端发送数据都无法打印，只能打印新客户端第一次发送的数据。


    
    


2. 解决办法
​	printf() 在终端打印时，是行缓冲，需要 '\n' 或者 fflush(stdout) 刷新后才能正常打印。

3. stdout 的三种缓冲策略1. 无缓冲​	标准错误输出（stderr）通常是无缓冲的，输出操作将直接写入目标（例如终端或文件），不经过缓冲区。
2. 行缓冲​	当输出被定向到终端（如控制台或命令行界面）时，stdout通常是行缓冲的。在行缓冲模式下，输出数据会被存储在缓冲区中，直到缓冲区满、手动刷新（使用fflush函数），或者遇到换行符（\n）时才实际写入目标。
3. 全缓冲​	当输出被重定向到文件或者程序不是直接与终端交互时（例如，通过管道连接到另一个程序），stdout通常是全缓冲的。在全缓冲模式下，输出数据会被积累在缓冲区中，直到缓冲区满或者调用fflush函数时才 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/23/%E7%A7%91%E7%A0%94-%E5%BC%95%E7%94%A8/" title="论文引用记录"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/0eba3bbe1d962a623a857.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文引用记录"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/23/%E7%A7%91%E7%A0%94-%E5%BC%95%E7%94%A8/" title="论文引用记录">论文引用记录</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-23T02:50:00.000Z" title="发表于 2024-02-23 10:50:00">2024-02-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
工业异常检测1. UCAD​	UCAD (Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt)，AAAI 2024，github（未上传）。

相关工作 —- 无监督工业异常检测==两大类==


    
        Feature-embedding-based methods
    
    
       &nbsp;&nbsp;&nbsp;&nbsp;Feature-embedding-based methods can be further cate-gorized into four subcategories, including teacher-student model (Bergmann et al. 2020; Salehi et al. 2021; Deng and Li 2022; Tien et al. 2023), one-class classification meth-ods (Li et al ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/22/%E7%A7%91%E7%A0%94-3-UCAD/" title="Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/2a512fa3e06ff4c31a979.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/22/%E7%A7%91%E7%A0%94-3-UCAD/" title="Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt">Unsupervised Continual Anomaly Detection with Contrastively-learned Prompt</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-22T02:00:00.000Z" title="发表于 2024-02-22 10:00:00">2024-02-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
UCAD
AAAI 2024


南方科技大学，Jiaqi Liu，Kai Wu，Feng Zheng





第一个异常检测无监督增量学习
构建memory(Knowledge)，用于新类查找最相似


1. 问题###1. 增量训练任务
​	不可预测的缺陷使得获得工业异常检测==获得足够的标记数据不可行==。
2. 持续学习用于UAD（无监督异常检测）的问题
​	持续学习方法主要==依赖于监督==注释，而 UAD 缺乏监督。

​	当前的UAD方法依次为==不同的类训练单独的模型==，导致灾难性遗忘和沉重的计算负担。

​	一些方法只关注类内连续异常，==忽略类间异常==。

​	IDDM 和 LeMo 只关注类内连续异常，DNE（Towards Continual Adaptation in Industrial Anomaly Detection）和作者类似，但 DNE 仅存储类级信息的限制，它不能进行细粒 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/" title="网络 io 与 select，poll"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/883007a9a06e0155b15a9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络 io 与 select，poll"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-11-%E7%BD%91%E7%BB%9C-io-%E4%B8%8E-select%EF%BC%8Cpoll%EF%BC%8Cepoll/" title="网络 io 与 select，poll">网络 io 与 select，poll</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-21T09:00:00.000Z" title="发表于 2024-02-21 17:00:00">2024-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
网络 io 与 select，poll1. 简单的WebSocket
    
    

### 1. socket 函数


函数原型

1234567#include &lt;sys/socket.h&gt;int socket(	int af,//地址类型，ipv4: AF_INET; ipv6: AF_INET6。af(address family)	int type,//套接字类型，TCP: SOCK_STREAM; UDP: SOCK_DGRAM。DGRAM(datagram socket)	int protocol//协议类型，一般设0，自动选择);//返回值：成功为 新创建socket的文件描述符，失败为 -1。


使用案例

1234567#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;int listen_socket = socket(AF_INET,SOCK_STREAM,0);if(-1 == listen_socket ){    perror("socket()  ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" title="Linux 命令使用"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/db50105f0f128110386e2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 命令使用"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/21/C-%E9%9B%B6%E5%A3%B0linux-10-Linux-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" title="Linux 命令使用">Linux 命令使用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-21T08:00:00.000Z" title="发表于 2024-02-21 16:00:00">2024-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
Linux 命令使用</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/" title="Hexo 中插入 Latex 公式 hexo -g 报错"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/3de6dcf9d1781ee01eca5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 中插入 Latex 公式 hexo -g 报错"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/21/Bug-3-Hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F%E6%8A%A5%E9%94%99/" title="Hexo 中插入 Latex 公式 hexo -g 报错">Hexo 中插入 Latex 公式 hexo -g 报错</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-21T07:00:00.000Z" title="发表于 2024-02-21 15:00:00">2024-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Bug/">Bug</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Bug/Hexo/">Hexo</a></span></div><div class="content">[TOC]
1. 问题背景
在md文档中插入了 $Latex$ 公式，使用 hexo -g时报错如下：




​	出现这种情况是因为 $Latex$ 公式块中有{{}}这样的双花括号，与另外的某些模块，如 Nunjucks 模块发生了冲突。

2. 解决办法
​	将{{}}改为{}单花括号即可。

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/" title="ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/610c334d0084c2b8c8875.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/21/%E7%A7%91%E7%A0%94-2-ClipSAM/" title="ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation">ClipSAM：CLIP and SAM Collaboration for Zero-Shot Anomaly Segmentation</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-21T01:00:00.000Z" title="发表于 2024-02-21 09:00:00">2024-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
ClipSAM
arxiv 2023


复旦大学，Shengze Li，Jianjian Cao，Tao Chen





CLIP + SAM 作 ZSAD
CLIP粗分割，SAM细分割，本质还是SAM


1. 问题1. ZSAD（零样本异常检测）任务​	需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。
2. CLIP 用于ZSAS问题
​	CLIP主要关注不同输入之间的全局特征对齐，==导致局部异常部分的分割不精确==。

3. SAM 用于ZSAS问题
​	SAM会==产生大量冗余掩码==，==需要合适的提示==。==简单的文本提示不能有效描述异常区域==，导致异常定位性能欠佳，SAM功能利用率不足。同时，==模糊的提示会产生冗余的掩码==。

2. 创新1. CLIP 和 SAM 协同
​	CLIP进行==异常定位和粗 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/" title="分布式版本控制 Git"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/22e8af7497db4a7530510.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式版本控制 Git"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/20/C-%E9%9B%B6%E5%A3%B0linux-9-Git/" title="分布式版本控制 Git">分布式版本控制 Git</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-20T10:00:00.000Z" title="发表于 2024-02-20 18:00:00">2024-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
Git1. 基本概念1. 仓库
git init –bare

​	==初始化==裸仓库 

git clone …

​	==克隆==远程仓库
2. ssh 协议
ssh-keygen -t rsa 


生成 rsa 公钥(.pub)和私钥，使用-f ~/.ssh/名字 参数指定文件路径和名字。
生成目录：/Users/用户/.ssh，使用 open ~/.ssh 直接在 finder 打开。


ssh-copy-id -i ~/.ssh/名字.pub username@hostname

​	将公钥内容拷贝至==服务器.ssh==文件夹中==authorized_keys==文件中。本地目录可以使用ssh免密登陆服务器。

git clone ssh://justhuayu@ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/" title="AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/bde3dbfce428b9d30dc25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/20/%E7%A7%91%E7%A0%94-1-AnomalyCLIP/" title="AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection">AnomalyCLIP：Object-agnostic Prompt Learning for Zero-shot Anomaly Detection</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-19T16:00:00.000Z" title="发表于 2024-02-20 00:00:00">2024-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/">科研</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a></span></div><div class="content">[TOC]
AnomalyCLIP
ICLR 2024


浙江大学 Qihang Zhou，Shibo He, Jiming Chen





CLIP + Prompt 做ZSAD
CLIP每个中间层训练一个Text Encoder Prompt


1. 问题1. ZSAD（零样本异常检测）任务​	需要使用辅助数据训练的检测模型来检测异常，而目标数据集中没有任何训练样本。
2. CLIP用于异常检测存在的问题
​	==CLIP主要针对的是前景对象的类语义，而不是图像中的异常/正常==，这限制了它们在理解视觉异常/正常时的泛化能力，导致ZSAD性能较弱。

3. 之前的文本提示存在问题
​	使用手动定义的文本提示或可学习的提示，通常会导致快速嵌入，选择全局特征进行有效的对象语义对齐，==未能捕捉到异常，这种异常通常表现为细粒度的局部特征==。

2. 创新1. 对象无关文本提示在ZSAD上的有效性
​	首次揭示了学习正常和异常的==对象无关文本提示=&amp; ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/" title="install_name_tool 解决链接找不到动态库"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/28b4858531838e5b7b127.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="install_name_tool 解决链接找不到动态库"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/17/C-%E9%97%AE%E9%A2%98-3-install-name-tool%E8%A7%A3%E5%86%B3%E9%93%BE%E6%8E%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8A%A8%E6%80%81%E5%BA%93/" title="install_name_tool 解决链接找不到动态库">install_name_tool 解决链接找不到动态库</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-17T11:03:00.000Z" title="发表于 2024-02-17 19:03:00">2024-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
1. 问题背景
在学习cmake时，遇到链接动态库后，运行二进制文件找不到动态库的问题。


​	工程目录如下图


​	在CMakeLists.txt文件中代码如下
1234567891011CMAKE_MINIMUM_REQUIRED(VERSION 2.8.4)ADD_EXECUTABLE(main main.c)#添加项目头文件目录INCLUDE_DIRECTORIES(../include/hello)#设置项目lib库目录SET(LIB_PATH ${PROJECT_SOURCE_DIR}/lib)#链接动态库和项目TARGET_LINK_LIBRARIES(main ${LIB_PATH}/libhello.dylib)#在bin目录下生成二进制文件SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)

​	我需要链接 libhello.dylib，但是打印链接路径却为


​	这里的第一行 libhello.1.dylib 就是 libhello ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/" title="CMake"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/ecd911b3d25ad0d19b329.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/17/C-%E9%9B%B6%E5%A3%B0linux-8-1-CMake/" title="CMake">CMake</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-16T16:00:00.000Z" title="发表于 2024-02-17 00:00:00">2024-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
CMake1. CMake使用1. 内部构建

==cmake .==  ，’ . ‘ 表示在当前目录构建。
在当前目录 ==make==，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。


2. 外部构建

创建目录 ==mkdir build==。
构建 ==cmake ..== ，’ .. ‘ 表示从上层构建。（其他路径构建用 ==cmake &lt;工程的全路径&gt;==）
在当前目录 ==make==，表示当前目录进行 ‘make’ 实际构建，生成可执行文件。


通过外部编译进行工程构建，PROJECT_SOURCE_DIR 仍然指代工程路径，即cmake/t1 而 PROJECT_BINARY_DIR 则指代编译路径，即cmake/t1/build

3. 约定目录
子目录==src ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/" title="Makefile"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/57abc79d14222701072c8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Makefile"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-8-Makefile/" title="Makefile">Makefile</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-15T05:27:00.000Z" title="发表于 2024-02-15 13:27:00">2024-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
Makefile1. makefile规则
​	Makefile最重要的二个概念一个是目标（target），另一个就是依赖（dependency）。目标就是指要干什么，或说运行 make 后生成什么，而依赖是告诉 make 如何去做以实现目标。






==make -v== 命令查看环境。

123456789//终端命令$make -v//结果GNU Make 3.81Copyright (C) 2006  Free Software Foundation, Inc.This is free software; see the source for copying conditions.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE.This program built for i386-apple-darwin11.3.0


打印 hello world，echo命令

12345678//终端命令$ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/" title="B+树"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/911ee69c2f4ba2e15d7cf.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B+树"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-1-B-%E6%A0%91/" title="B+树">B+树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-15T02:09:00.000Z" title="发表于 2024-02-15 10:09:00">2024-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
B+ 树1. 作用
B+ 树的作用


B+树的内层节点做索引，只有叶子节点存储。


B+ 树的用途


MySQL 的数据存储。

</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/" title="B树"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/ef24b06465da1157f2652.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B树"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/15/C-%E9%9B%B6%E5%A3%B0linux-2-B%E6%A0%91/" title="B树">B树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-15T01:27:00.000Z" title="发表于 2024-02-15 09:27:00">2024-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
B树1. 作用
B树的作用


二叉树的层数太高，B树可减少层高
B树内节点和叶子节点都可存储数据


B树的用途


磁盘数据查找（每个层高查找一次磁盘）

2. 性质
一颗M阶B树T，满足以下条件


每个结点至多拥有M颗子树
根结点至少拥有两颗子树
除了根结点以外，其余每个分支结点至少拥有M/2课子树
所有的叶结点都在同一层上
有k课子树的分支结点则存在K-1个关键字，关键字按照递增顺序进行排
关键字数量满足 ceil(M/2) - 1＜ = n ＜ = M - 1

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/" title="BSTree::Node* &amp;node和BSTree::Node &amp;node 区别"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/40474d496fa9353349be8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BSTree::Node* &amp;node和BSTree::Node &amp;node 区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/07/C-%E9%97%AE%E9%A2%98-2-Node-node%E5%92%8CNode-node/" title="BSTree::Node* &amp;node和BSTree::Node &amp;node 区别">BSTree::Node* &amp;node和BSTree::Node &amp;node 区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-07T13:47:00.000Z" title="发表于 2024-02-07 21:47:00">2024-02-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
1. 问题背景
写二叉查找树==递归插入==代码时，参数用==Node* &amp;node== 和==Node &amp;node==有着明显的不同。

2. 两者区别 
    Node &amp;node这是一个对对象的引用，使用这种方式，函数可以修改通过引用传递的对象的内容，但不能改变调用者中对象的地址。
    

 
    Node* &amp;node这是一个对指针的引用，使用这种方式，函数能够直接修改传入的指针本身。
    
# 3. 代码


下面是二叉搜索树实现递归插入节点。

1. Node &amp;node作为参数
Node &amp;node 作为参数，此时节点为空时不能直接 new，必须通过父节点的左右子树new，否则会丢失。

123456789101112131415161718192021222324template &lt;typename K_TYPE&gt;bool BSTree&lt;K_TYPE&gt;::_insertR ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/" title="模版template <class T> 和 template <typename T> 区别"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/de4af16c0a3cb300d0b88.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="模版template <class T> 和 template <typename T> 区别"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/06/C-%E9%97%AE%E9%A2%98-1-template-%E4%B8%ADclass%E5%92%8Ctypename%E5%8C%BA%E5%88%AB/" title="模版template <class T> 和 template <typename T> 区别">模版template &lt;class T&gt; 和 template &lt;typename T&gt; 区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-06T13:49:00.000Z" title="发表于 2024-02-06 21:49:00">2024-02-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%97%AE%E9%A2%98/">问题</a></span></div><div class="content">[TOC]
1. 问题背景
学习二叉查找树时，有的使用 template ，有的使用 template  。

2. 两者区别1. C++标准中 
    template &lt;typename T&gt; 用于基础数据类型， T可以是int char 等
    

 
    template &lt;class T&gt; 用于复杂数据类型， T可以是string，类 等
    

2. 实际使用
大部分情况，typename和class等价。


在C++早期版本中，没有 typename 这个关键字，所以在模板定义的时候便使用了 class。

参考文章：模板 template＜typename T＞ 和 template＜class T＞区别
</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" title="红黑树基础 ----> 二叉查找树"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/1c883f7f427a1722a25a3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树基础 ----> 二叉查找树"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/06/C-%E9%9B%B6%E5%A3%B0linux-1-1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/" title="红黑树基础 ----> 二叉查找树">红黑树基础 ----&gt; 二叉查找树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-06T10:17:10.000Z" title="发表于 2024-02-06 18:17:10">2024-02-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
二叉查找树1. 作用
用于二分查找



2. 性质
按照中序排列的二叉树


其左子树下的每个后代节点的值都小于节点n的值。
其右子树下的每个后代节点的值都大于节点n的值。
左右子树也均为二叉查找树。

3. 类型1. 斜树


所有的结点都只有左子树的二叉树叫左斜树。


所有结点都是只有右子树的二叉树叫右斜树。

左斜树和右斜树统称为斜树。

2. 满二叉树



所有分支结点都存在左子树和右子树。
所有叶子节点（即没有子节点的节点）都在同一层上。



    
        1. 叶子节点只能出现在最下一层。出现在其它层就不可能达成平衡。
    
    
    2. 非叶子结点的度（结点拥有的子树数目称为结点的度）一定是2。
    
    
    3. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。
     


3. 完全二叉树


​	一颗具有n个结点的二叉树按层编号（按从上至下、从左到右的顺序进行编号），编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。完全 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/" title="动态规划解题套路"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/a4cc4db3d0d0eb2693937.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态规划解题套路"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/06/Labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/" title="动态规划解题套路">动态规划解题套路</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-06T02:55:10.000Z" title="发表于 2024-02-06 10:55:10">2024-02-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">labuladong的算法笔记</a></span></div><div class="content">[TOC]
动态规划1. 框架
动态规划的核心是穷举。


递归算法的时间复杂度：子问题个数 X 一个子问题需要时间。

1. 总体套路 1. 明确 base case ----&gt; 2. 明确 "状态" ----&gt; 3. 明确 "选择" ----&gt; 4. 定义 dp 数组 / 函数的含义

 可优化问题：最优子结构 、 重叠子问题

 解决方法：备忘录 、 DP table

2. 自顶向下递归递归套路

12345678//套路void dp(状态1,状态2,...){    for(auto 选择:所有可能的选择){		//此时的状态可能因为做了选择而改变        auto result = 求最值(result, dp(状态1,状态2,...));    }    return result;}


斐波那契数列—-自顶向下递归

12345678910111213141516171819//带"备忘录"的递归解法int fib(int n){    vector&lt;int&gt;memo(n+1); ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/4259e776135f8cd61103c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/01/27/C-%E9%9B%B6%E5%A3%B0linux-1-%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树">红黑树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-01-27T14:28:10.000Z" title="发表于 2024-01-27 22:28:10">2024-01-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/">零声Linux</a></span></div><div class="content">[TOC]
红黑树1. 作用
红黑树的用途：


Key–Value 查找。
顺序。


强查找时所用数据结构：


rbtree

hash

b/b+ tree

跳表


2. 性质
每个结点是红的或者黑的
根结点是黑的
每个叶子结点是黑的
如果一个结点是红的，则它的两个儿子都是黑的
对每个结点，从该结点到其子孙结点的所有路径上的包含相同数目的黑结点

3. 代码实现1. 红黑树定义
节点

1234567891011typedef int KEY_TYPE;typedef struct _rbtree_node{    KEY_TYPE *key;	    void *value;	        struct _rbtree_node *left;    struct _rbtree_node *right;    struct _rbtree_node *parent;        unsigned char color;	//红黑树颜色}rbtree_node;


头节点

1234typedef struct _rbtree{ ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/" title="Hexo 邮件 icon 点击 404"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/24c45b63febdfb2c32b49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo 邮件 icon 点击 404"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/01/26/Bug-2-Hexo%E4%B8%BB%E9%A2%98%E9%82%AE%E4%BB%B6404/" title="Hexo 邮件 icon 点击 404">Hexo 邮件 icon 点击 404</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-01-26T15:09:00.000Z" title="发表于 2024-01-26 23:09:00">2024-01-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Bug/">Bug</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Bug/Hexo/">Hexo</a></span></div><div class="content">[TOC]
1. 问题背景
​	在主页面中，点击 icon 的邮件后报错 404 。



2. 解决办法
​	_config.yml 文件中添加==mailto:example:email.com==。

</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/" title="Mac上iCloud下载慢"><img class="post-bg" src="https://telegraph-image-9wl.pages.dev/file/eb36de35fdf08b519b5fe.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mac上iCloud下载慢"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/01/26/Bug-1-Mac%E4%B8%8AiCloud%E4%B8%8B%E8%BD%BD%E6%85%A2/" title="Mac上iCloud下载慢">Mac上iCloud下载慢</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-01-26T04:17:00.000Z" title="发表于 2024-01-26 12:17:00">2024-01-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Bug/">Bug</a><i class="fas fa-angle-right article-meta-link"></i><a class="article-meta__categories" href="/categories/Bug/Mac/">Mac</a></span></div><div class="content">[TOC]
1. 问题背景
​	Mac 上开启了 icloud 同步云盘内容，但是下载很慢，导致桌面和文稿中文件一直被同步占用，无法进行复制或删除等操作。

2. 解决办法
​	设置中关闭 icloud 同步。具体在，设置 &gt;&gt; Apple ID &gt;&gt; iCloud &gt;&gt; iCloud云盘 ，关闭 “同步此 mac” 和 “桌面和文稿文件夹” 选项。

</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://telegraph-image-9wl.pages.dev/file/3dff73595485fb9078401.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">Just花语</div><div class="author-info__description">Just花语</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Justhuayu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Justhuayu" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:justhuayu@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">想要成为编程高手</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="epoll的实现"><img src="https://telegraph-image-9wl.pages.dev/file/545b3e3037dfad4c22d01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="epoll的实现"></a><div class="content"><a class="title" href="/2024/03/14/C-%E9%9B%B6%E5%A3%B0linux-19-epoll%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="epoll的实现">epoll的实现</a><time datetime="2024-03-20T12:31:12.906Z" title="更新于 2024-03-20 20:31:12">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/C-%E9%9B%B6%E5%A3%B0linux-22-%E5%86%85%E5%AD%98%E6%B1%A0/" title="内存池"><img src="https://telegraph-image-9wl.pages.dev/file/b89cb2c0122f47cdf3a26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存池"></a><div class="content"><a class="title" href="/2024/03/20/C-%E9%9B%B6%E5%A3%B0linux-22-%E5%86%85%E5%AD%98%E6%B1%A0/" title="内存池">内存池</a><time datetime="2024-03-20T12:14:49.127Z" title="更新于 2024-03-20 20:14:49">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><img src="https://telegraph-image-9wl.pages.dev/file/7de1609f2980b10353cf7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程池"></a><div class="content"><a class="title" href="/2024/03/19/C-%E9%9B%B6%E5%A3%B0linux-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><time datetime="2024-03-20T12:13:02.895Z" title="更新于 2024-03-20 20:13:02">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-2-threadpool/" title="threadpool"><img src="https://telegraph-image-9wl.pages.dev/file/8700c274ac71301334cb9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="threadpool"></a><div class="content"><a class="title" href="/2024/03/20/C-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-2-threadpool/" title="threadpool">threadpool</a><time datetime="2024-03-20T04:16:44.499Z" title="更新于 2024-03-20 12:16:44">2024-03-20</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Bug/"><span class="card-category-list-name">Bug</span><span class="card-category-list-count">3</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Bug/Hexo/"><span class="card-category-list-name">Hexo</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Bug/Mac/"><span class="card-category-list-name">Mac</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">29</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E6%BA%90%E7%A0%81/"><span class="card-category-list-name">源码</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E9%97%AE%E9%A2%98/"><span class="card-category-list-name">问题</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E9%9B%B6%E5%A3%B0Linux/"><span class="card-category-list-name">零声Linux</span><span class="card-category-list-count">20</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="card-category-list-name">数据结构与算法</span><span class="card-category-list-count">1</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">labuladong的算法笔记</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94/"><span class="card-category-list-name">科研</span><span class="card-category-list-count">14</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">论文笔记</span><span class="card-category-list-count">14</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Bug/" style="font-size: 1.22em; color: rgb(42, 96, 89)">Bug</a><a href="/tags/labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" style="font-size: 1.15em; color: rgb(191, 138, 122)">labuladong的算法笔记</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.3em; color: rgb(25, 84, 4)">数据结构</a><a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 1.41em; color: rgb(24, 119, 102)">科研</a><a href="/tags/C/" style="font-size: 1.45em; color: rgb(166, 90, 77)">C++</a><a href="/tags/%E9%97%AE%E9%A2%98/" style="font-size: 1.34em; color: rgb(163, 193, 172)">问题</a><a href="/tags/git/" style="font-size: 1.15em; color: rgb(109, 96, 190)">git</a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.26em; color: rgb(79, 10, 69)">工具</a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.38em; color: rgb(165, 64, 22)">网络</a><a href="/tags/%E7%BB%84%E4%BB%B6/" style="font-size: 1.19em; color: rgb(66, 111, 29)">组件</a><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 1.19em; color: rgb(5, 84, 27)">源码</a><a href="/tags/NtyCo/" style="font-size: 1.19em; color: rgb(104, 19, 160)">NtyCo</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">2024年03月</span><span class="card-archive-list-count">25</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">2024年02月</span><span class="card-archive-list-count">19</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">2024年01月</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">47</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishdate="2024-01-19T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">55.9k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastpushdate="2024-03-20T12:31:16.610Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By Just花语</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>